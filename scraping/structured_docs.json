[
    {
        "title": "Quickstart¶",
        "content": [
            "Eager to get started? This page gives a good introduction in how to get started\nwith Requests.",
            "First, make sure that:",
            "Requests is installed",
            "Requests is up-to-date",
            "Let’s get started with some simple examples."
        ],
        "code": []
    },
    {
        "title": "Make a Request¶",
        "content": [
            "Making a request with Requests is very simple.",
            "Begin by importing the Requests module:",
            "Now, let’s try to get a webpage. For this example, let’s get GitHub’s public\ntimeline:",
            "Now, we have a Response object called r. We can\nget all the information we need from this object.",
            "Requests’ simple API means that all forms of HTTP request are as obvious. For\nexample, this is how you make an HTTP POST request:",
            "Nice, right? What about the other HTTP request types: PUT, DELETE, HEAD and\nOPTIONS? These are all just as simple:",
            "That’s all well and good, but it’s also only the start of what Requests can\ndo."
        ],
        "code": [
            ">>> import requests",
            ">>> r = requests.get('https://api.github.com/events')",
            "Response",
            "r",
            ">>> r = requests.post('https://httpbin.org/post', data={'key': 'value'})",
            ">>> r = requests.put('https://httpbin.org/put', data={'key': 'value'})\n>>> r = requests.delete('https://httpbin.org/delete')\n>>> r = requests.head('https://httpbin.org/get')\n>>> r = requests.options('https://httpbin.org/get')"
        ]
    },
    {
        "title": "Passing Parameters In URLs¶",
        "content": [
            "You often want to send some sort of data in the URL’s query string. If\nyou were constructing the URL by hand, this data would be given as key/value\npairs in the URL after a question mark, e.g. httpbin.org/get?key=val.\nRequests allows you to provide these arguments as a dictionary of strings,\nusing the params keyword argument. As an example, if you wanted to pass\nkey1=value1 and key2=value2 to httpbin.org/get, you would use the\nfollowing code:",
            "You can see that the URL has been correctly encoded by printing the URL:",
            "Note that any dictionary key whose value is None will not be added to the\nURL’s query string.",
            "You can also pass a list of items as a value:"
        ],
        "code": [
            "httpbin.org/get?key=val",
            "params",
            "key1=value1",
            "key2=value2",
            "httpbin.org/get",
            ">>> payload = {'key1': 'value1', 'key2': 'value2'}\n>>> r = requests.get('https://httpbin.org/get', params=payload)",
            ">>> print(r.url)\nhttps://httpbin.org/get?key2=value2&key1=value1",
            "None",
            ">>> payload = {'key1': 'value1', 'key2': ['value2', 'value3']}\n\n>>> r = requests.get('https://httpbin.org/get', params=payload)\n>>> print(r.url)\nhttps://httpbin.org/get?key1=value1&key2=value2&key2=value3"
        ]
    },
    {
        "title": "Response Content¶",
        "content": [
            "We can read the content of the server’s response. Consider the GitHub timeline\nagain:",
            "Requests will automatically decode content from the server. Most unicode\ncharsets are seamlessly decoded.",
            "When you make a request, Requests makes educated guesses about the encoding of\nthe response based on the HTTP headers. The text encoding guessed by Requests\nis used when you access r.text. You can find out what encoding Requests is\nusing, and change it, using the r.encoding property:",
            "If you change the encoding, Requests will use the new value of r.encoding\nwhenever you call r.text. You might want to do this in any situation where\nyou can apply special logic to work out what the encoding of the content will\nbe. For example, HTML and XML have the ability to specify their encoding in\ntheir body. In situations like this, you should use r.content to find the\nencoding, and then set r.encoding. This will let you use r.text with\nthe correct encoding.",
            "Requests will also use custom encodings in the event that you need them. If\nyou have created your own encoding and registered it with the codecs\nmodule, you can simply use the codec name as the value of r.encoding and\nRequests will handle the decoding for you."
        ],
        "code": [
            ">>> import requests\n\n>>> r = requests.get('https://api.github.com/events')\n>>> r.text\n'[{\"repository\":{\"open_issues\":0,\"url\":\"https://github.com/...",
            "r.text",
            "r.encoding",
            ">>> r.encoding\n'utf-8'\n>>> r.encoding = 'ISO-8859-1'",
            "r.encoding",
            "r.text",
            "r.content",
            "r.encoding",
            "r.text",
            "codecs",
            "r.encoding"
        ]
    },
    {
        "title": "Binary Response Content¶",
        "content": [
            "You can also access the response body as bytes, for non-text requests:",
            "The gzip and deflate transfer-encodings are automatically decoded for you.",
            "The br  transfer-encoding is automatically decoded for you if a Brotli library\nlike brotli or brotlicffi is installed.",
            "For example, to create an image from binary data returned by a request, you can\nuse the following code:"
        ],
        "code": [
            ">>> r.content\nb'[{\"repository\":{\"open_issues\":0,\"url\":\"https://github.com/...",
            "gzip",
            "deflate",
            "br",
            ">>> from PIL import Image\n>>> from io import BytesIO\n\n>>> i = Image.open(BytesIO(r.content))"
        ]
    },
    {
        "title": "JSON Response Content¶",
        "content": [
            "There’s also a builtin JSON decoder, in case you’re dealing with JSON data:",
            "In case the JSON decoding fails, r.json() raises an exception. For example, if\nthe response gets a 204 (No Content), or if the response contains invalid JSON,\nattempting r.json() raises requests.exceptions.JSONDecodeError. This wrapper exception\nprovides interoperability for multiple exceptions that may be thrown by different\npython versions and json serialization libraries.",
            "It should be noted that the success of the call to r.json() does not\nindicate the success of the response. Some servers may return a JSON object in a\nfailed response (e.g. error details with HTTP 500). Such JSON will be decoded\nand returned. To check that a request is successful, use\nr.raise_for_status() or check r.status_code is what you expect."
        ],
        "code": [
            ">>> import requests\n\n>>> r = requests.get('https://api.github.com/events')\n>>> r.json()\n[{'repository': {'open_issues': 0, 'url': 'https://github.com/...",
            "r.json()",
            "r.json()",
            "requests.exceptions.JSONDecodeError",
            "r.json()",
            "r.raise_for_status()",
            "r.status_code"
        ]
    },
    {
        "title": "Raw Response Content¶",
        "content": [
            "In the rare case that you’d like to get the raw socket response from the\nserver, you can access r.raw. If you want to do this, make sure you set\nstream=True in your initial request. Once you do, you can do this:",
            "In general, however, you should use a pattern like this to save what is being\nstreamed to a file:",
            "Using Response.iter_content will handle a lot of what you would otherwise\nhave to handle when using Response.raw directly. When streaming a\ndownload, the above is the preferred and recommended way to retrieve the\ncontent. Note that chunk_size can be freely adjusted to a number that\nmay better fit your use cases.",
            "Note",
            "An important note about using Response.iter_content versus Response.raw.\nResponse.iter_content will automatically decode the gzip and deflate\ntransfer-encodings.  Response.raw is a raw stream of bytes – it does not\ntransform the response content.  If you really need access to the bytes as they\nwere returned, use Response.raw."
        ],
        "code": [
            "r.raw",
            "stream=True",
            ">>> r = requests.get('https://api.github.com/events', stream=True)\n\n>>> r.raw\n<urllib3.response.HTTPResponse object at 0x101194810>\n\n>>> r.raw.read(10)\nb'\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x03'",
            "with open(filename, 'wb') as fd:\n    for chunk in r.iter_content(chunk_size=128):\n        fd.write(chunk)",
            "Response.iter_content",
            "Response.raw",
            "chunk_size",
            "Response.iter_content",
            "Response.raw",
            "Response.iter_content",
            "gzip",
            "deflate",
            "Response.raw",
            "Response.raw"
        ]
    },
    {
        "title": "Custom Headers¶",
        "content": [
            "If you’d like to add HTTP headers to a request, simply pass in a dict to the\nheaders parameter.",
            "For example, we didn’t specify our user-agent in the previous example:",
            "Note: Custom headers are given less precedence than more specific sources of information. For instance:",
            "Authorization headers set with headers= will be overridden if credentials\nare specified in .netrc, which in turn will be overridden by the  auth=\nparameter. Requests will search for the netrc file at ~/.netrc, ~/_netrc,\nor at the path specified by the NETRC environment variable.",
            "Authorization headers will be removed if you get redirected off-host.",
            "Proxy-Authorization headers will be overridden by proxy credentials provided in the URL.",
            "Content-Length headers will be overridden when we can determine the length of the content.",
            "Furthermore, Requests does not change its behavior at all based on which custom headers are specified. The headers are simply passed on into the final request.",
            "Note: All header values must be a string, bytestring, or unicode. While permitted, it’s advised to avoid passing unicode header values."
        ],
        "code": [
            "dict",
            "headers",
            ">>> url = 'https://api.github.com/some/endpoint'\n>>> headers = {'user-agent': 'my-app/0.0.1'}\n\n>>> r = requests.get(url, headers=headers)",
            ".netrc",
            "auth=",
            "string"
        ]
    },
    {
        "title": "More complicated POST requests¶",
        "content": [
            "Typically, you want to send some form-encoded data — much like an HTML form.\nTo do this, simply pass a dictionary to the data argument. Your\ndictionary of data will automatically be form-encoded when the request is made:",
            "The data argument can also have multiple values for each key. This can be\ndone by making data either a list of tuples or a dictionary with lists\nas values. This is particularly useful when the form has multiple elements that\nuse the same key:",
            "There are times that you may want to send data that is not form-encoded. If\nyou pass in a string instead of a dict, that data will be posted directly.",
            "For example, the GitHub API v3 accepts JSON-Encoded POST/PATCH data:",
            "Please note that the above code will NOT add the Content-Type header\n(so in particular it will NOT set it to application/json).",
            "If you need that header set and you don’t want to encode the dict yourself,\nyou can also pass it directly using the json parameter (added in version 2.4.2)\nand it will be encoded automatically:",
            "Note, the json parameter is ignored if either data or files is passed."
        ],
        "code": [
            "data",
            ">>> payload = {'key1': 'value1', 'key2': 'value2'}\n\n>>> r = requests.post('https://httpbin.org/post', data=payload)\n>>> print(r.text)\n{\n  ...\n  \"form\": {\n    \"key2\": \"value2\",\n    \"key1\": \"value1\"\n  },\n  ...\n}",
            "data",
            "data",
            ">>> payload_tuples = [('key1', 'value1'), ('key1', 'value2')]\n>>> r1 = requests.post('https://httpbin.org/post', data=payload_tuples)\n>>> payload_dict = {'key1': ['value1', 'value2']}\n>>> r2 = requests.post('https://httpbin.org/post', data=payload_dict)\n>>> print(r1.text)\n{\n  ...\n  \"form\": {\n    \"key1\": [\n      \"value1\",\n      \"value2\"\n    ]\n  },\n  ...\n}\n>>> r1.text == r2.text\nTrue",
            "string",
            "dict",
            ">>> import json\n\n>>> url = 'https://api.github.com/some/endpoint'\n>>> payload = {'some': 'data'}\n\n>>> r = requests.post(url, data=json.dumps(payload))",
            "Content-Type",
            "application/json",
            "dict",
            "json",
            ">>> url = 'https://api.github.com/some/endpoint'\n>>> payload = {'some': 'data'}",
            ">>> r = requests.post(url, json=payload)",
            "json",
            "data",
            "files"
        ]
    },
    {
        "title": "POST a Multipart-Encoded File¶",
        "content": [
            "Requests makes it simple to upload Multipart-encoded files:",
            "You can set the filename, content_type and headers explicitly:",
            "If you want, you can send strings to be received as files:",
            "In the event you are posting a very large file as a multipart/form-data\nrequest, you may want to stream the request. By default, requests does not\nsupport this, but there is a separate package which does -\nrequests-toolbelt. You should read the toolbelt’s documentation for more details about how to use it.",
            "For sending multiple files in one request refer to the advanced\nsection.",
            "Warning",
            "It is strongly recommended that you open files in binary\nmode. This is because Requests may attempt to provide\nthe Content-Length header for you, and if it does this value\nwill be set to the number of bytes in the file. Errors may occur\nif you open the file in text mode."
        ],
        "code": [
            ">>> url = 'https://httpbin.org/post'\n>>> files = {'file': open('report.xls', 'rb')}\n\n>>> r = requests.post(url, files=files)\n>>> r.text\n{\n  ...\n  \"files\": {\n    \"file\": \"<censored...binary...data>\"\n  },\n  ...\n}",
            ">>> url = 'https://httpbin.org/post'\n>>> files = {'file': ('report.xls', open('report.xls', 'rb'), 'application/vnd.ms-excel', {'Expires': '0'})}\n\n>>> r = requests.post(url, files=files)\n>>> r.text\n{\n  ...\n  \"files\": {\n    \"file\": \"<censored...binary...data>\"\n  },\n  ...\n}",
            ">>> url = 'https://httpbin.org/post'\n>>> files = {'file': ('report.csv', 'some,data,to,send\\nanother,row,to,send\\n')}\n\n>>> r = requests.post(url, files=files)\n>>> r.text\n{\n  ...\n  \"files\": {\n    \"file\": \"some,data,to,send\\\\nanother,row,to,send\\\\n\"\n  },\n  ...\n}",
            "multipart/form-data",
            "requests",
            "requests-toolbelt",
            "Content-Length"
        ]
    },
    {
        "title": "Response Status Codes¶",
        "content": [
            "We can check the response status code:",
            "Requests also comes with a built-in status code lookup object for easy\nreference:",
            "If we made a bad request (a 4XX client error or 5XX server error response), we\ncan raise it with\nResponse.raise_for_status():",
            "But, since our status_code for r was 200, when we call\nraise_for_status() we get:",
            "All is well."
        ],
        "code": [
            ">>> r = requests.get('https://httpbin.org/get')\n>>> r.status_code\n200",
            ">>> r.status_code == requests.codes.ok\nTrue",
            "Response.raise_for_status()",
            ">>> bad_r = requests.get('https://httpbin.org/status/404')\n>>> bad_r.status_code\n404\n\n>>> bad_r.raise_for_status()\nTraceback (most recent call last):\n  File \"requests/models.py\", line 832, in raise_for_status\n    raise http_error\nrequests.exceptions.HTTPError: 404 Client Error",
            "status_code",
            "r",
            "200",
            "raise_for_status()",
            ">>> r.raise_for_status()\nNone"
        ]
    },
    {
        "title": "Response Headers¶",
        "content": [
            "We can view the server’s response headers using a Python dictionary:",
            "The dictionary is special, though: it’s made just for HTTP headers. According to\nRFC 7230, HTTP Header names\nare case-insensitive.",
            "So, we can access the headers using any capitalization we want:",
            "It is also special in that the server could have sent the same header multiple\ntimes with different values, but requests combines them so they can be\nrepresented in the dictionary within a single mapping, as per\nRFC 7230:",
            "A recipient MAY combine multiple header fields with the same field name\ninto one “field-name: field-value” pair, without changing the semantics\nof the message, by appending each subsequent field value to the combined\nfield value in order, separated by a comma."
        ],
        "code": [
            ">>> r.headers\n{\n    'content-encoding': 'gzip',\n    'transfer-encoding': 'chunked',\n    'connection': 'close',\n    'server': 'nginx/1.0.4',\n    'x-runtime': '148ms',\n    'etag': '\"e1ca502697e5c9317743dc078f67693f\"',\n    'content-type': 'application/json'\n}",
            ">>> r.headers['Content-Type']\n'application/json'\n\n>>> r.headers.get('content-type')\n'application/json'"
        ]
    },
    {
        "title": "Cookies¶",
        "content": [
            "If a response contains some Cookies, you can quickly access them:",
            "To send your own cookies to the server, you can use the cookies\nparameter:",
            "Cookies are returned in a RequestsCookieJar,\nwhich acts like a dict but also offers a more complete interface,\nsuitable for use over multiple domains or paths.  Cookie jars can\nalso be passed in to requests:"
        ],
        "code": [
            ">>> url = 'http://example.com/some/cookie/setting/url'\n>>> r = requests.get(url)\n\n>>> r.cookies['example_cookie_name']\n'example_cookie_value'",
            "cookies",
            ">>> url = 'https://httpbin.org/cookies'\n>>> cookies = dict(cookies_are='working')\n\n>>> r = requests.get(url, cookies=cookies)\n>>> r.text\n'{\"cookies\": {\"cookies_are\": \"working\"}}'",
            "RequestsCookieJar",
            "dict",
            ">>> jar = requests.cookies.RequestsCookieJar()\n>>> jar.set('tasty_cookie', 'yum', domain='httpbin.org', path='/cookies')\n>>> jar.set('gross_cookie', 'blech', domain='httpbin.org', path='/elsewhere')\n>>> url = 'https://httpbin.org/cookies'\n>>> r = requests.get(url, cookies=jar)\n>>> r.text\n'{\"cookies\": {\"tasty_cookie\": \"yum\"}}'"
        ]
    },
    {
        "title": "Redirection and History¶",
        "content": [
            "By default Requests will perform location redirection for all verbs except\nHEAD.",
            "We can use the history property of the Response object to track redirection.",
            "The Response.history list contains the\nResponse objects that were created in order to\ncomplete the request. The list is sorted from the oldest to the most recent\nresponse.",
            "For example, GitHub redirects all HTTP requests to HTTPS:",
            "If you’re using GET, OPTIONS, POST, PUT, PATCH or DELETE, you can disable\nredirection handling with the allow_redirects parameter:",
            "If you’re using HEAD, you can enable redirection as well:"
        ],
        "code": [
            "history",
            "Response.history",
            "Response",
            ">>> r = requests.get('http://github.com/')\n\n>>> r.url\n'https://github.com/'\n\n>>> r.status_code\n200\n\n>>> r.history\n[<Response [301]>]",
            "allow_redirects",
            ">>> r = requests.get('http://github.com/', allow_redirects=False)\n\n>>> r.status_code\n301\n\n>>> r.history\n[]",
            ">>> r = requests.head('http://github.com/', allow_redirects=True)\n\n>>> r.url\n'https://github.com/'\n\n>>> r.history\n[<Response [301]>]"
        ]
    },
    {
        "title": "Timeouts¶",
        "content": [
            "You can tell Requests to stop waiting for a response after a given number of\nseconds with the timeout parameter. Nearly all production code should use\nthis parameter in nearly all requests. Failure to do so can cause your program\nto hang indefinitely:",
            "Note",
            "timeout is not a time limit on the entire response download;\nrather, an exception is raised if the server has not issued a\nresponse for timeout seconds (more precisely, if no bytes have been\nreceived on the underlying socket for timeout seconds). If no timeout is specified explicitly, requests do\nnot time out."
        ],
        "code": [
            "timeout",
            ">>> requests.get('https://github.com/', timeout=0.001)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nrequests.exceptions.Timeout: HTTPConnectionPool(host='github.com', port=80): Request timed out. (timeout=0.001)",
            "timeout",
            "timeout",
            "timeout"
        ]
    },
    {
        "title": "Errors and Exceptions¶",
        "content": [
            "In the event of a network problem (e.g. DNS failure, refused connection, etc),\nRequests will raise a ConnectionError exception.",
            "Response.raise_for_status() will\nraise an HTTPError if the HTTP request\nreturned an unsuccessful status code.",
            "If a request times out, a Timeout exception is\nraised.",
            "If a request exceeds the configured number of maximum redirections, a\nTooManyRedirects exception is raised.",
            "All exceptions that Requests explicitly raises inherit from\nrequests.exceptions.RequestException.",
            "Ready for more? Check out the advanced section.",
            "Requests is an elegant and simple HTTP library for Python, built for\n  human beings. You are currently looking at the documentation of the\n  development release."
        ],
        "code": [
            "ConnectionError",
            "Response.raise_for_status()",
            "HTTPError",
            "Timeout",
            "TooManyRedirects",
            "requests.exceptions.RequestException"
        ]
    },
    {
        "title": "Useful Links",
        "content": [],
        "code": []
    },
    {
        "title": "Table of Contents",
        "content": [],
        "code": []
    },
    {
        "title": "Related Topics",
        "content": [],
        "code": []
    },
    {
        "title": "Quick search",
        "content": [],
        "code": []
    }
]