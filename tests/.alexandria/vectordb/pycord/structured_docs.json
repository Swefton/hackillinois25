[
    {
        "title": "Abstract Base Classes#",
        "content": [
            "An abstract base class (also known as an abc) is a class that models can inherit\nto get their behaviour. Abstract base classes should not be instantiated.\nThey are mainly there for usage with isinstance() and issubclass().",
            "This library has a module related to abstract base classes, in which all the ABCs are subclasses of\ntyping.Protocol.",
            "An ABC that details the common operations on a Discord model.",
            "Almost all Discord models meet this\nabstract base class.",
            "If you want to create a snowflake on your own, consider using\nObject.",
            "The model’s unique ID.",
            "int",
            "An ABC that details the common operations on a Discord user.",
            "The following implement this ABC:",
            "User",
            "ClientUser",
            "Member",
            "This ABC must also implement Snowflake.",
            "The user’s username.",
            "str",
            "The user’s discriminator.",
            "Note",
            "If the user has migrated to the new username system, this will always be “0”.",
            "str",
            "The user’s global name.",
            "New in version 2.5.",
            "str",
            "The avatar asset the user has.",
            "Asset",
            "If the user is a bot account.",
            "bool",
            "Returns the user’s display name.",
            "Returns a string that allows you to mention the given user.",
            "An ABC that details the common operations on a private Discord channel.",
            "The following implement this ABC:",
            "DMChannel",
            "GroupChannel",
            "This ABC must also implement Snowflake.",
            "The user presenting yourself.",
            "ClientUser",
            "An ABC that details the common operations on a Discord guild channel.",
            "The following implement this ABC:",
            "TextChannel",
            "VoiceChannel",
            "CategoryChannel",
            "StageChannel",
            "ForumChannel",
            "This ABC must also implement Snowflake.",
            "The channel name.",
            "str",
            "The guild the channel belongs to.",
            "Guild",
            "The position in the channel list. This is a number that starts at 0.\ne.g. the top channel is position 0.",
            "int",
            "Returns a list of roles that have been overridden from\ntheir default values in the roles attribute.",
            "The string that allows you to mention the channel.",
            "Returns a URL that allows the client to jump to the channel.",
            "New in version 2.0.",
            "Returns the channel’s creation time in UTC.",
            "Returns the channel-specific overwrites for a member or a role.",
            "obj (Union[Role, User]) – The role or user denoting\nwhose overwrite to get.",
            "The permission overwrites for this object.",
            "PermissionOverwrite",
            "Returns all of the channel’s overwrites.",
            "This is returned as a dictionary where the key contains the target which\ncan be either a Role or a Member and the value is the\noverwrite as a PermissionOverwrite.",
            "The channel’s permission overwrites.",
            "Dict[Union[Role, Member], PermissionOverwrite]",
            "The category this channel belongs to.",
            "If there is no category then this is None.",
            "Whether the permissions for this channel are synced with the\ncategory it belongs to.",
            "If there is no category then this is False.",
            "New in version 1.3.",
            "Handles permission resolution for the Member\nor Role.",
            "This function takes into consideration the following cases:",
            "Guild owner",
            "Guild roles",
            "Channel overrides",
            "Member overrides",
            "If a Role is passed, then it checks the permissions\nsomeone with that role would have, which is essentially:",
            "The default role permissions",
            "The permissions of the role used as a parameter",
            "The default role permission overwrites",
            "The permission overwrites of the role used as a parameter",
            "Changed in version 2.0: The object passed in can now be a role object.",
            "obj (Union[Member, Role]) – The object to resolve permissions for. This could be either\na member or a role. If it’s a role then member overwrites\nare not computed.",
            "The resolved permissions for the member or role.",
            "Permissions",
            "This function is a coroutine.",
            "Deletes the channel.",
            "You must have manage_channels permission to use this.",
            "reason (Optional[str]) – The reason for deleting this channel.\nShows up on the audit log.",
            "Forbidden – You do not have proper permissions to delete the channel.",
            "NotFound – The channel was not found or was already deleted.",
            "HTTPException – Deleting the channel failed.",
            "None",
            "This function is a coroutine.",
            "Sets the channel specific permission overwrites for a target in the\nchannel.",
            "The target parameter should either be a Member or a\nRole that belongs to guild.",
            "The overwrite parameter, if given, must either be None or\nPermissionOverwrite. For convenience, you can pass in\nkeyword arguments denoting Permissions attributes. If this is\ndone, then you cannot mix the keyword arguments with the overwrite\nparameter.",
            "If the overwrite parameter is None, then the permission\noverwrites are deleted.",
            "You must have the manage_roles permission to use this.",
            "Note",
            "This method replaces the old overwrites with the ones given.",
            "Examples",
            "Setting allow and deny:",
            "Deleting overwrites",
            "Using PermissionOverwrite",
            "target (Union[Member, Role]) – The member or role to overwrite permissions for.",
            "overwrite (Optional[PermissionOverwrite]) – The permissions to allow and deny to the target, or None to\ndelete the overwrite.",
            "**permissions – A keyword argument list of permissions to set for ease of use.\nCannot be mixed with overwrite.",
            "reason (Optional[str]) – The reason for doing this action. Shows up on the audit log.",
            "Forbidden – You do not have permissions to edit channel specific permissions.",
            "HTTPException – Editing channel specific permissions failed.",
            "NotFound – The role or member being edited is not part of the guild.",
            "InvalidArgument – The overwrite parameter invalid or the target type was not\n    Role or Member.",
            "This function is a coroutine.",
            "Clones this channel. This creates a channel with the same properties\nas this channel.",
            "You must have the manage_channels permission to\ndo this.",
            "New in version 1.1.",
            "name (Optional[str]) – The name of the new channel. If not provided, defaults to this\nchannel name.",
            "reason (Optional[str]) – The reason for cloning this channel. Shows up on the audit log.",
            "self (GCH) –",
            "The channel that was created.",
            "abc.GuildChannel",
            "Forbidden – You do not have the proper permissions to create this channel.",
            "HTTPException – Creating the channel failed.",
            "This function is a coroutine.",
            "A rich interface to help move a channel relative to other channels.",
            "If exact position movement is required, edit should be used instead.",
            "You must have the manage_channels permission to\ndo this.",
            "Note",
            "Voice channels will always be sorted below text channels.\nThis is a Discord limitation.",
            "New in version 1.7.",
            "beginning (bool) – Whether to move the channel to the beginning of the\nchannel list (or category if given).\nThis is mutually exclusive with end, before, and after.",
            "end (bool) – Whether to move the channel to the end of the\nchannel list (or category if given).\nThis is mutually exclusive with beginning, before, and after.",
            "before (Snowflake) – The channel that should be before our current channel.\nThis is mutually exclusive with beginning, end, and after.",
            "after (Snowflake) – The channel that should be after our current channel.\nThis is mutually exclusive with beginning, end, and before.",
            "offset (int) – The number of channels to offset the move by. For example,\nan offset of 2 with beginning=True would move\nit 2 after the beginning. A positive number moves it below\nwhile a negative number moves it above. Note that this\nnumber is relative and computed after the beginning,\nend, before, and after parameters.",
            "category (Optional[Snowflake]) – The category to move this channel under.\nIf None is given then it moves it out of the category.\nThis parameter is ignored if moving a category channel.",
            "sync_permissions (bool) – Whether to sync the permissions with the category (if given).",
            "reason (str) – The reason for the move.",
            "InvalidArgument – An invalid position was given or a bad mix of arguments was passed.",
            "Forbidden – You do not have permissions to move the channel.",
            "HTTPException – Moving the channel failed.",
            "None",
            "This function is a coroutine.",
            "Creates an instant invite from a text or voice channel.",
            "You must have the create_instant_invite permission to\ndo this.",
            "max_age (int) – How long the invite should last in seconds. If it’s 0 then the invite\ndoesn’t expire. Defaults to 0.",
            "max_uses (int) – How many uses the invite could be used for. If it’s 0 then there\nare unlimited uses. Defaults to 0.",
            "temporary (bool) – Denotes that the invite grants temporary membership\n(i.e. they get kicked after they disconnect). Defaults to False.",
            "unique (bool) – Indicates if a unique invite URL should be created. Defaults to True.\nIf this is set to False then it will return a previously created\ninvite.",
            "reason (Optional[str]) – The reason for creating this invite. Shows up on the audit log.",
            "target_type (Optional[InviteTarget]) – The type of target for the voice channel invite, if any.\n\nNew in version 2.0.",
            "The type of target for the voice channel invite, if any.",
            "New in version 2.0.",
            "target_user (Optional[User]) – The user whose stream to display for this invite, required if target_type is TargetType.stream.\nThe user must be streaming in the channel.\n\nNew in version 2.0.",
            "The user whose stream to display for this invite, required if target_type is TargetType.stream.\nThe user must be streaming in the channel.",
            "New in version 2.0.",
            "target_application_id (Optional[int]) – The id of the embedded application for the invite, required if target_type is\nTargetType.embedded_application.\n\nNew in version 2.0.",
            "The id of the embedded application for the invite, required if target_type is\nTargetType.embedded_application.",
            "New in version 2.0.",
            "target_event (Optional[ScheduledEvent]) – The scheduled event object to link to the event.\nShortcut to Invite.set_scheduled_event()\nSee Invite.set_scheduled_event() for more\ninfo on event invite linking.\n\nNew in version 2.0.",
            "The scheduled event object to link to the event.\nShortcut to Invite.set_scheduled_event()",
            "See Invite.set_scheduled_event() for more\ninfo on event invite linking.",
            "New in version 2.0.",
            "The invite that was created.",
            "Invite",
            "HTTPException – Invite creation failed.",
            "NotFound – The channel that was passed is a category or an invalid channel.",
            "This function is a coroutine.",
            "Returns a list of all active instant invites from this channel.",
            "You must have manage_channels to get this information.",
            "The list of invites that are currently active.",
            "List[Invite]",
            "Forbidden – You do not have proper permissions to get the information.",
            "HTTPException – An error occurred while fetching the information.",
            "An ABC that details the common operations on a model that can send messages.",
            "The following implement this ABC:",
            "TextChannel",
            "VoiceChannel",
            "StageChannel",
            "DMChannel",
            "GroupChannel",
            "User",
            "Member",
            "Context",
            "Thread",
            "ApplicationContext",
            "Returns an AsyncIterator that enables receiving the destination’s message history.",
            "You must have read_message_history permissions to use this.",
            "limit (Optional[int]) – The number of messages to retrieve.\nIf None, retrieves every message in the channel. Note, however,\nthat this would make it a slow operation.",
            "before (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages before this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages after this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "around (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages around this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.\nWhen using this argument, the maximum limit is 101. Note that if the limit is an\neven number, then this will return at most limit + 1 messages.",
            "oldest_first (Optional[bool]) – If set to True, return messages in oldest->newest order. Defaults to True if\nafter is specified, otherwise False.",
            "Message – The message with the message data parsed.",
            "Forbidden – You do not have permissions to get channel message history.",
            "HTTPException – The request to get message history failed.",
            "HistoryIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "All parameters are optional.",
            "Returns a context manager that allows you to type for an indefinite period of time.",
            "This is useful for denoting long computations in your bot.\n:rtype: Typing",
            "Note",
            "This is both a regular context manager and an async context manager.\nThis means that both with and async with work with this.",
            "Example Usage:",
            "This function is a coroutine.",
            "Sends a message to the destination with the content given.",
            "The content must be a type that can convert to a string through str(content).\nIf the content is set to None (the default), then the embed parameter must\nbe provided.",
            "To upload a single file, the file parameter should be used with a\nsingle File object. To upload multiple files, the files\nparameter should be used with a list of File objects.\nSpecifying both parameters will lead to an exception.",
            "To upload a single embed, the embed parameter should be used with a\nsingle Embed object. To upload multiple embeds, the embeds\nparameter should be used with a list of Embed objects.\nSpecifying both parameters will lead to an exception.",
            "content (Optional[str]) – The content of the message to send.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "embed (Embed) – The rich embed for the content.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "nonce (Union[str, int]) – The nonce to use for sending this message. If the message was successfully sent,\nthen the message will have a nonce with this value.",
            "enforce_nonce (Optional[bool]) – Whether nonce is enforced to be validated.\n\nNew in version 2.5.",
            "Whether nonce is enforced to be validated.",
            "New in version 2.5.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent. If the deletion fails,\nthen it is silently ignored.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "New in version 1.4.",
            "reference (Union[Message, MessageReference, PartialMessage]) – A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.\n\nNew in version 1.6.",
            "A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.",
            "New in version 1.6.",
            "mention_author (Optional[bool]) – If set, overrides the replied_user attribute of allowed_mentions.\n\nNew in version 1.6.",
            "If set, overrides the replied_user attribute of allowed_mentions.",
            "New in version 1.6.",
            "view (discord.ui.View) – A Discord UI View to add to the message.",
            "embeds (List[Embed]) – A list of embeds to upload. Must be a maximum of 10.\n\nNew in version 2.0.",
            "A list of embeds to upload. Must be a maximum of 10.",
            "New in version 2.0.",
            "stickers (Sequence[Union[GuildSticker, StickerItem]]) – A list of stickers to upload. Must be a maximum of 3.\n\nNew in version 2.0.",
            "A list of stickers to upload. Must be a maximum of 3.",
            "New in version 2.0.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "silent (bool) – Whether to suppress push and desktop notifications for the message.\n\nNew in version 2.4.",
            "Whether to suppress push and desktop notifications for the message.",
            "New in version 2.4.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size,\n    you specified both file and files,\n    or you specified both embed and embeds,\n    or the reference object is not a Message,\n    MessageReference or PartialMessage.",
            "This function is a coroutine.",
            "Triggers a typing indicator to the destination.",
            "Typing indicator will go away after 10 seconds, or after a message is sent.",
            "None",
            "This function is a coroutine.",
            "Retrieves a single Message from the destination.",
            "id (int) – The message ID to look for.",
            "The message asked for.",
            "Message",
            "NotFound – The specified message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "This function is a coroutine.",
            "Retrieves all messages that are currently pinned in the channel.",
            "Note",
            "Due to a limitation with the Discord API, the Message\nobjects returned by this method do not contain complete\nMessage.reactions data.",
            "The messages that are currently pinned.",
            "List[Message]",
            "HTTPException – Retrieving the pinned messages failed.",
            "Returns a bool indicating whether you have the permissions to send the object(s).",
            "Indicates whether you have the permissions to send the object(s).",
            "bool",
            "TypeError – An invalid type has been passed.",
            "An ABC that details the common operations on a channel that can\nconnect to a voice server.",
            "The following implement this ABC:",
            "VoiceChannel",
            "StageChannel",
            "Note",
            "This ABC is not decorated with typing.runtime_checkable(), so will fail isinstance()/issubclass()\nchecks."
        ],
        "code": [
            "abc",
            "isinstance()",
            "issubclass()",
            "typing.Protocol",
            "Object",
            "int",
            "User",
            "ClientUser",
            "Member",
            "Snowflake",
            "str",
            "str",
            "str",
            "Asset",
            "bool",
            "DMChannel",
            "GroupChannel",
            "Snowflake",
            "ClientUser",
            "TextChannel",
            "VoiceChannel",
            "CategoryChannel",
            "StageChannel",
            "ForumChannel",
            "Snowflake",
            "str",
            "Guild",
            "int",
            "roles",
            "Role",
            "User",
            "PermissionOverwrite",
            "Role",
            "Member",
            "PermissionOverwrite",
            "Role",
            "Member",
            "PermissionOverwrite",
            "None",
            "False",
            "Member",
            "Role",
            "Role",
            "Member",
            "Role",
            "Permissions",
            "manage_channels",
            "str",
            "target",
            "Member",
            "Role",
            "overwrite",
            "None",
            "PermissionOverwrite",
            "Permissions",
            "overwrite",
            "overwrite",
            "None",
            "manage_roles",
            "await message.channel.set_permissions(message.author, read_messages=True,\n                                                      send_messages=False)",
            "await channel.set_permissions(member, overwrite=None)",
            "PermissionOverwrite",
            "overwrite = discord.PermissionOverwrite()\noverwrite.send_messages = False\noverwrite.read_messages = True\nawait channel.set_permissions(member, overwrite=overwrite)",
            "Member",
            "Role",
            "PermissionOverwrite",
            "None",
            "overwrite",
            "str",
            "Role",
            "Member",
            "manage_channels",
            "str",
            "str",
            "abc.GuildChannel",
            "edit",
            "manage_channels",
            "bool",
            "end",
            "before",
            "after",
            "bool",
            "beginning",
            "before",
            "after",
            "Snowflake",
            "beginning",
            "end",
            "after",
            "Snowflake",
            "beginning",
            "end",
            "before",
            "int",
            "2",
            "beginning=True",
            "beginning",
            "end",
            "before",
            "after",
            "Snowflake",
            "None",
            "bool",
            "str",
            "None",
            "create_instant_invite",
            "int",
            "0",
            "int",
            "0",
            "bool",
            "False",
            "bool",
            "False",
            "str",
            "InviteTarget",
            "User",
            "int",
            "ScheduledEvent",
            "Invite.set_scheduled_event()",
            "Invite.set_scheduled_event()",
            "Invite",
            "manage_channels",
            "Invite",
            "TextChannel",
            "VoiceChannel",
            "StageChannel",
            "DMChannel",
            "GroupChannel",
            "User",
            "Member",
            "Context",
            "Thread",
            "ApplicationContext",
            "AsyncIterator",
            "read_message_history",
            "int",
            "None",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "bool",
            "True",
            "True",
            "after",
            "False",
            "Message",
            "counter = 0\nasync for message in channel.history(limit=200):\n    if message.author == client.user:\n        counter += 1",
            "messages = await channel.history(limit=123).flatten()\n# messages is now a list of Message...",
            "Typing",
            "with",
            "async with",
            "async with channel.typing():\n    # simulate something heavy\n    await asyncio.sleep(10)\n\nawait channel.send('done!')",
            "str(content)",
            "None",
            "embed",
            "file",
            "File",
            "files",
            "list",
            "File",
            "embed",
            "Embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "Embed",
            "File",
            "File",
            "str",
            "int",
            "bool",
            "nonce",
            "float",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "Message",
            "MessageReference",
            "PartialMessage",
            "Message",
            "to_reference()",
            "Message",
            "replied_user",
            "allowed_mentions",
            "mention_author",
            "bool",
            "replied_user",
            "allowed_mentions",
            "discord.ui.View",
            "Embed",
            "GuildSticker",
            "StickerItem",
            "bool",
            "bool",
            "Poll",
            "Message",
            "files",
            "file",
            "files",
            "embed",
            "embeds",
            "reference",
            "Message",
            "MessageReference",
            "PartialMessage",
            "None",
            "Message",
            "int",
            "Message",
            "Message",
            "Message.reactions",
            "Message",
            "bool",
            "bool",
            "VoiceChannel",
            "StageChannel",
            "typing.runtime_checkable()",
            "isinstance()",
            "issubclass()",
            "Snowflake",
            "id",
            "User",
            "name",
            "discriminator",
            "global_name",
            "avatar",
            "bot",
            "display_name",
            "mention",
            "PrivateChannel",
            "me",
            "GuildChannel",
            "name",
            "guild",
            "position",
            "changed_roles",
            "mention",
            "jump_url",
            "created_at",
            "overwrites_for()",
            "overwrites",
            "category",
            "permissions_synced",
            "permissions_for()",
            "delete()",
            "set_permissions()",
            "clone()",
            "move()",
            "create_invite()",
            "invites()",
            "Messageable",
            "history()",
            "typing()",
            "send()",
            "trigger_typing()",
            "fetch_message()",
            "pins()",
            "can_send()",
            "Connectable"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/abcs.html"
    },
    {
        "title": "Cogs#",
        "content": [
            "The base class that all cogs must inherit from.",
            "A cog is a collection of commands, listeners, and optional state to\nhelp group commands together. More information on them can be found on\nthe Cogs page.",
            "When inheriting from this class, the options shown in CogMeta\nare equally valid here.",
            "A list of ApplicationCommands that are\ndefined inside this cog.\n\nNote\nThis does not include subcommands.",
            "A list of ApplicationCommands that are\ndefined inside this cog.",
            "Note",
            "This does not include subcommands.",
            "List[ApplicationCommand]",
            "Returns the cog’s specified name, not the class name.",
            "Returns the cog’s description, typically the cleaned docstring.",
            "An iterator that recursively walks through this cog’s commands and subcommands.",
            "Union[Command, Group] – A command or group from the cog.",
            "Generator[ApplicationCommand, None, None]",
            "Returns a list of (name, function) listener pairs that are defined in this cog.",
            "The listeners defined in this cog.",
            "List[Tuple[str, coroutine]]",
            "A decorator that marks a function as a listener.",
            "This is the cog equivalent of Bot.listen().",
            "name (str) – The name of the event being listened to. If not provided, it\ndefaults to the function’s name.",
            "once (bool) – If this listener should only be called once after each cog load.\nDefaults to false.",
            "TypeError – The function is not a coroutine function or a string was not passed as\n    the name.",
            "Callable[[TypeVar(FuncT, bound= Callable[..., Any])], TypeVar(FuncT, bound= Callable[..., Any])]",
            "Checks whether the cog has an error handler.\n:rtype: bool",
            "New in version 1.7.",
            "A special method that is called when the cog gets removed.",
            "This function cannot be a coroutine. It must be a regular\nfunction.",
            "Subclasses must replace this if they want special unloading behaviour.",
            "None",
            "A special method that registers as a Bot.check_once()\ncheck.",
            "This function can be a coroutine and must take a sole parameter,\nctx, to represent the Context or ApplicationContext.",
            "ctx (Context) – The invocation context.",
            "bool",
            "A special method that registers as a Bot.check()\ncheck.",
            "This function can be a coroutine and must take a sole parameter,\nctx, to represent the Context or ApplicationContext.",
            "ctx (Context) – The invocation context.",
            "bool",
            "A special method that registers as a check()\nfor every command and subcommand in this cog.",
            "This function can be a coroutine and must take a sole parameter,\nctx, to represent the Context or ApplicationContext.",
            "ctx (Context) – The invocation context.",
            "bool",
            "A special method that is called whenever an error\nis dispatched inside this cog.",
            "This is similar to on_command_error() except only applying\nto the commands inside this cog.",
            "This must be a coroutine.",
            "ctx (ApplicationContext) – The invocation context where the error happened.",
            "error (ApplicationCommandError) – The error that happened.",
            "None",
            "A special method that acts as a cog local pre-invoke hook.",
            "This is similar to ApplicationCommand.before_invoke().",
            "This must be a coroutine.",
            "ctx (ApplicationContext) – The invocation context.",
            "None",
            "A special method that acts as a cog local post-invoke hook.",
            "This is similar to ApplicationCommand.after_invoke().",
            "This must be a coroutine.",
            "ctx (ApplicationContext) – The invocation context.",
            "None",
            "A metaclass for defining a cog.",
            "Note that you should probably not use this directly. It is exposed\npurely for documentation purposes along with making custom metaclasses to intermix\nwith other metaclasses such as the abc.ABCMeta metaclass.",
            "For example, to create an abstract cog mixin class, the following would be done.",
            "Note",
            "When passing an attribute of a metaclass that is documented below, note\nthat you must pass it as a keyword-only argument to the class creation\nlike the following example:",
            "The cog name. By default, it is the name of the class with no modification.",
            "str",
            "The cog description. By default, it is the cleaned docstring of the class.",
            "New in version 1.6.",
            "str",
            "A list of attributes to apply to every command inside this cog. The dictionary\nis passed into the Command options at __init__.\nIf you specify attributes inside the command attribute in the class, it will\noverride the one specified inside this attribute. For example:",
            "dict",
            "A shortcut to command_attrs, what guild_ids should all application commands have\nin the cog. You can override this by setting guild_ids per command.",
            "New in version 2.0.",
            "Optional[List[int]]",
            "args (Any) –",
            "kwargs (Any) –"
        ],
        "code": [
            "CogMeta",
            "list",
            "ApplicationCommand",
            "ApplicationCommand",
            "Command",
            "Group",
            "Generator",
            "ApplicationCommand",
            "None",
            "None",
            "list",
            "str",
            "Bot.listen()",
            "str",
            "bool",
            "Callable",
            "TypeVar",
            "FuncT",
            "Callable",
            "...",
            "Any",
            "TypeVar",
            "FuncT",
            "Callable",
            "...",
            "Any",
            "bool",
            "None",
            "Bot.check_once()",
            "ctx",
            "Context",
            "ApplicationContext",
            "Context",
            "bool",
            "Bot.check()",
            "ctx",
            "Context",
            "ApplicationContext",
            "Context",
            "bool",
            "check()",
            "ctx",
            "Context",
            "ApplicationContext",
            "Context",
            "bool",
            "on_command_error()",
            "ApplicationContext",
            "ApplicationCommandError",
            "None",
            "ApplicationCommand.before_invoke()",
            "ApplicationContext",
            "None",
            "ApplicationCommand.after_invoke()",
            "ApplicationContext",
            "None",
            "abc.ABCMeta",
            "import abc\n\nclass CogABCMeta(discord.CogMeta, abc.ABCMeta):\n    pass\n\nclass SomeMixin(metaclass=abc.ABCMeta):\n    pass\n\nclass SomeCogMixin(SomeMixin, discord.Cog, metaclass=CogABCMeta):\n    pass",
            "class MyCog(discord.Cog, name='My Cog'):\n    pass",
            "str",
            "str",
            "Command",
            "__init__",
            "class MyCog(discord.Cog, command_attrs=dict(hidden=True)):\n    @discord.slash_command()\n    async def foo(self, ctx):\n        pass # hidden -> True\n\n    @discord.slash_command(hidden=False)\n    async def bar(self, ctx):\n        pass # hidden -> False",
            "dict",
            "command_attrs",
            "guild_ids",
            "guild_ids",
            "int",
            "Any",
            "Any",
            "Cog",
            "get_commands()",
            "qualified_name",
            "description",
            "walk_commands()",
            "get_listeners()",
            "listener()",
            "has_error_handler()",
            "cog_unload()",
            "bot_check_once()",
            "bot_check()",
            "cog_check()",
            "cog_command_error()",
            "cog_before_invoke()",
            "cog_after_invoke()",
            "CogMeta",
            "name",
            "description",
            "command_attrs",
            "guild_ids"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/cogs.html"
    },
    {
        "title": "Sinks#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/api/sinks.html"
    },
    {
        "title": "Core#",
        "content": [
            "Filters for Sink",
            "New in version 2.0.",
            "container – Container of all Filters.",
            "A sink “stores” recorded audio data.",
            "Can be subclassed for extra customizablilty.",
            "Warning",
            "It is recommended you use\nthe officially provided sink classes,\nsuch as WaveSink.",
            "just replace the following like so:",
            "New in version 2.0.",
            "ClientException – An invalid encoding type was specified.",
            "ClientException – Audio may only be formatted after recording is finished.",
            "Gets all audio files.",
            "Gets the audio file(s) of one specific user.",
            "user (Union[str, int]) –",
            "Handles data that’s been completely decrypted and decoded and is ready to be saved to file.",
            "New in version 2.0.",
            "Writes audio data.",
            "ClientException – The AudioData is already finished writing.",
            "Finishes and cleans up the audio data.",
            "ClientException – The AudioData is already finished writing.",
            "Called when audio data is formatted.",
            "ClientException – The AudioData is still writing.",
            "Handles raw data from Discord so that it can be decrypted and decoded to be used.",
            "New in version 2.0."
        ],
        "code": [
            "Sink",
            "WaveSink",
            "vc.start_recording(\n    MySubClassedSink(),\n    finished_callback,\n    ctx.channel,\n)",
            "Union",
            "str",
            "int"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/sinks.html"
    },
    {
        "title": "Sink Classes#",
        "content": [
            "A special sink for .wav(wave) files.",
            "New in version 2.0.",
            "Formats the recorded audio.",
            "WaveSinkError – Audio may only be formatted after recording is finished.",
            "WaveSinkError – Formatting the audio failed.",
            "A special sink for .mp3 files.",
            "New in version 2.0.",
            "Formats the recorded audio.",
            "MP3SinkError – Audio may only be formatted after recording is finished.",
            "MP3SinkError – Formatting the audio failed.",
            "A special sink for .mp4 files.",
            "New in version 2.0.",
            "Formats the recorded audio.",
            "MP4SinkError – Audio may only be formatted after recording is finished.",
            "MP4SinkError – Formatting the audio failed.",
            "A special sink for .m4a files.",
            "New in version 2.0.",
            "Formats the recorded audio.",
            "M4ASinkError – Audio may only be formatted after recording is finished.",
            "M4ASinkError – Formatting the audio failed.",
            "A special sink for .mkv files.",
            "New in version 2.0.",
            "Formats the recorded audio.",
            "MKVSinkError – Audio may only be formatted after recording is finished.",
            "MKVSinkError – Formatting the audio failed.",
            "A special sink for .mka files.",
            "New in version 2.0.",
            "Formats the recorded audio.",
            "MKASinkError – Audio may only be formatted after recording is finished.",
            "MKASinkError – Formatting the audio failed.",
            "A special sink for .ogg files.",
            "New in version 2.0.",
            "Formats the recorded audio.",
            "OGGSinkError – Audio may only be formatted after recording is finished.",
            "OGGSinkError – Formatting the audio failed."
        ],
        "code": [
            "Filters",
            "Sink",
            "get_all_audio()",
            "get_user_audio()",
            "AudioData",
            "write()",
            "cleanup()",
            "on_format()",
            "RawData",
            "WaveSink",
            "format_audio()",
            "MP3Sink",
            "format_audio()",
            "MP4Sink",
            "format_audio()",
            "M4ASink",
            "format_audio()",
            "MKVSink",
            "format_audio()",
            "MKASink",
            "format_audio()",
            "OGGSink",
            "format_audio()"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/sinks.html"
    },
    {
        "title": "API Reference#",
        "content": [
            "The following section outlines the API of Pycord.",
            "Note",
            "This module uses the Python logging module to log diagnostic and errors\nin an output independent way.  If the logging module is not configured,\nthese logs will not be output anywhere.  See Setting Up Logging for\nmore information on how to set up and use the logging module with\nPycord.",
            "Table of Contents"
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/api/index.html"
    },
    {
        "title": "Welcome to Pycord#",
        "content": [
            "Pycord is a modern, easy to use, feature-rich, and async ready API wrapper\nfor Discord.",
            "Features:",
            "Modern Pythonic API using async/await syntax",
            "Sane rate limit handling that prevents 429s",
            "Command extension to aid with bot creation",
            "Easy to use with an object oriented design",
            "Optimised for both speed and memory"
        ],
        "code": [
            "async",
            "await"
        ],
        "url": "https://docs.pycord.dev/en/stable/index.html"
    },
    {
        "title": "Getting started#",
        "content": [
            "Is this your first time using the library? This is the place to get started!",
            "First steps: Installing Pycord | Quickstart | Setting Up Logging | Guide",
            "Working with Discord: Creating a Bot Account | A Primer to Gateway Intents",
            "Examples: Many examples are available in the repository."
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/index.html"
    },
    {
        "title": "Getting help#",
        "content": [
            "If you’re having trouble with something, these resources might help.",
            "Try the Frequently Asked Questions first, it’s got answers to all common questions.",
            "Ask us and hang out with us in our Discord server.",
            "If you’re looking for something specific, try the index or searching.",
            "Report bugs in the issue tracker."
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/index.html"
    },
    {
        "title": "Manuals#",
        "content": [
            "These pages go into great detail about everything the API can do."
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/index.html"
    },
    {
        "title": "Core API#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/index.html"
    },
    {
        "title": "Extensions#",
        "content": [
            "These extensions help you during development when it comes to common tasks.",
            "discord.ext.commands - Bot commands framework",
            "discord.ext.tasks - asyncio.Task helpers",
            "discord.ext.pages - A pagination extension module",
            "discord.ext.bridge - A module that bridges slash commands to prefixed commands"
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/index.html"
    },
    {
        "title": "Meta#",
        "content": [
            "If you’re looking for something related to the project itself, it’s here.",
            "Changelog - The changelog for the library.",
            "Version Guarantees - The version guarantees for the library.",
            "Migrating to v1.0 - How to migrate from v0.x to v1.x.",
            "Migrating to v2.0 - How to migrate from v1.x to v2.x."
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/index.html"
    },
    {
        "title": "Voice Related#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/api/voice.html"
    },
    {
        "title": "Objects#",
        "content": [
            "Represents a Discord voice connection.",
            "You do not create these, you typically get them from\ne.g. VoiceChannel.connect().",
            "The voice connection session ID.",
            "str",
            "The voice connection token.",
            "str",
            "The endpoint we are connecting to.",
            "str",
            "The voice channel connected to.",
            "abc.Connectable",
            "The event loop that the voice client is running on.",
            "asyncio.AbstractEventLoop",
            "Warning",
            "In order to use PCM based AudioSources, you must have the opus library\ninstalled on your system and loaded through opus.load_opus().\nOtherwise, your AudioSources must be opus encoded (e.g. using FFmpegOpusAudio)\nor the library will not be able to transmit audio.",
            "client (Client) –",
            "channel (Connectable) –",
            "The guild we’re connected to, if applicable.",
            "The user connected to voice (i.e. ourselves).",
            "Latency between a HEARTBEAT and a HEARTBEAT_ACK in seconds.",
            "This could be referred to as the Discord Voice WebSocket latency and is\nan analogue of user’s voice latencies as seen in the Discord client.",
            "New in version 1.4.",
            "Average of most recent 20 HEARTBEAT latencies in seconds.",
            "New in version 1.4.",
            "This function is a coroutine.",
            "Disconnects this voice client from voice.",
            "force (bool) –",
            "None",
            "This function is a coroutine.",
            "Moves you to a different voice channel.",
            "channel (abc.Connectable) – The channel to move to. Must be a voice channel.",
            "None",
            "Indicates if the voice client is connected to voice.",
            "bool",
            "Plays an AudioSource.",
            "The finalizer, after is called after the source has been exhausted\nor an error occurred.",
            "If an error happens while the audio player is running, the exception is\ncaught and the audio player is then stopped. If no after callback is\npassed, any caught exception will be displayed as if it were raised.",
            "source (AudioSource) – The audio source we’re reading from.",
            "after (Callable[[Optional[Exception]], Any]) – The finalizer that is called after the stream is exhausted.\nThis function must have a single parameter, error, that\ndenotes an optional exception that was raised during playing.",
            "wait_finish (bool) – If True, an awaitable will be returned, which can be used to wait for\naudio to stop playing. This awaitable will return an exception if raised,\nor None when no exception is raised.\nIf False, None is returned and the function does not block.\n\nNew in version v2.5.",
            "If True, an awaitable will be returned, which can be used to wait for\naudio to stop playing. This awaitable will return an exception if raised,\nor None when no exception is raised.",
            "If False, None is returned and the function does not block.",
            "New in version v2.5.",
            "ClientException – Already playing audio or not connected.",
            "TypeError – Source is not a AudioSource or after is not a callable.",
            "OpusNotLoaded – Source is not opus encoded and opus is not loaded.",
            "None | asyncio.Future",
            "Takes an audio packet received from Discord and decodes it into pcm audio data.\nIf there are no users talking in the channel, None will be returned.",
            "You must be connected to receive audio.",
            "New in version 2.0.",
            "data (bytes) – Bytes received by Discord via the UDP connection used for sending and receiving voice data.",
            "The bot will begin recording audio from the current voice channel it is in.\nThis function uses a thread so the current code line will not be stopped.\nMust be in a voice channel to use.\nMust not be already recording.",
            "New in version 2.0.",
            "sink (Sink) – A Sink which will “store” all the audio data.",
            "callback (coroutine) – A function which is called after the bot has stopped recording.",
            "*args – Args which will be passed to the callback function.",
            "sync_start (bool) – If True, the recordings of subsequent users will start with silence.\nThis is useful for recording audio just as it was heard.",
            "RecordingException – Not connected to a voice channel.",
            "RecordingException – Already recording.",
            "RecordingException – Must provide a Sink object.",
            "Stops the recording.\nMust be already recording.",
            "New in version 2.0.",
            "RecordingException – Not currently recording.",
            "Pauses or unpauses the recording.\nMust be already recording.",
            "New in version 2.0.",
            "RecordingException – Not currently recording.",
            "Indicates if we’re currently playing audio.",
            "bool",
            "Indicates if we’re playing audio, but if we’re paused.",
            "bool",
            "Stops playing audio.",
            "None",
            "Pauses the audio playing.",
            "None",
            "Resumes the audio playing.",
            "None",
            "The audio source being played, if playing.",
            "This property can also be used to change the audio source currently being played.",
            "Sends an audio packet composed of the data.",
            "You must be connected to play audio.",
            "data (bytes) – The bytes-like object denoting PCM or Opus voice data.",
            "encode (bool) – Indicates if data should be encoded into Opus.",
            "ClientException – You are not connected.",
            "opus.OpusError – Encoding the data failed.",
            "None",
            "A class that represents the Discord voice protocol.",
            "This is an abstract class. The library provides a concrete implementation\nunder VoiceClient.",
            "This class allows you to implement a protocol to allow for an external\nmethod of sending voice, such as Lavalink or a native library implementation.",
            "These classes are passed to abc.Connectable.connect.",
            "client (Client) – The client (or its subclasses) that started the connection request.",
            "channel (abc.Connectable) – The voice channel that is being connected to.",
            "This function is a coroutine.",
            "An abstract method that is called when the client’s voice state\nhas changed. This corresponds to VOICE_STATE_UPDATE.",
            "data (dict) – The raw voice state payload.",
            "The raw voice state payload.",
            "None",
            "This function is a coroutine.",
            "An abstract method that is called when initially connecting to voice.\nThis corresponds to VOICE_SERVER_UPDATE.",
            "data (dict) – The raw voice server update payload.",
            "The raw voice server update payload.",
            "None",
            "This function is a coroutine.",
            "An abstract method called when the client initiates the connection request.",
            "When a connection is requested initially, the library calls the constructor\nunder __init__ and then calls connect(). If connect() fails at\nsome point then disconnect() is called.",
            "Within this method, to start the voice connection flow it is recommended to\nuse Guild.change_voice_state() to start the flow. After which,\non_voice_server_update() and on_voice_state_update() will be called.\nThe order that these two are called is unspecified.",
            "timeout (float) – The timeout for the connection.",
            "reconnect (bool) – Whether reconnection is expected.",
            "None",
            "This function is a coroutine.",
            "An abstract method called when the client terminates the connection.",
            "See cleanup().",
            "force (bool) – Whether the disconnection was forced.",
            "None",
            "This method must be called to ensure proper clean-up during a disconnect.",
            "It is advisable to call this from within disconnect() when you are\ncompletely done with the voice protocol instance.",
            "This method removes it from the internal state cache that keeps track of\ncurrently alive voice clients. Failure to clean-up will cause subsequent\nconnections to report that it’s still connected.",
            "None",
            "Represents an audio stream.",
            "The audio stream can be Opus encoded or not, however if the audio stream\nis not Opus encoded then the audio format must be 16-bit 48KHz stereo PCM.",
            "Warning",
            "The audio source reads are done in a separate thread.",
            "Reads 20ms worth of audio.",
            "Subclasses must implement this.",
            "If the audio is complete, then returning an empty\nbytes-like object to signal this is the way to do so.",
            "If is_opus() method returns True, then it must return\n20ms worth of Opus encoded audio. Otherwise, it must be 20ms\nworth of 16-bit 48KHz stereo PCM, which is about 3,840 bytes\nper frame (20ms worth of audio).",
            "A bytes like object that represents the PCM or Opus data.",
            "bytes",
            "Checks if the audio source is already encoded in Opus.",
            "bool",
            "Called when clean-up is needed to be done.",
            "Useful for clearing buffer data or processes after\nit is done playing audio.",
            "None",
            "Represents raw 16-bit 48KHz stereo PCM audio source.",
            "A file-like object that reads byte data representing raw PCM.",
            "file object",
            "stream (BufferedIOBase) –",
            "Reads 20ms worth of audio.",
            "Subclasses must implement this.",
            "If the audio is complete, then returning an empty\nbytes-like object to signal this is the way to do so.",
            "If is_opus() method returns True, then it must return\n20ms worth of Opus encoded audio. Otherwise, it must be 20ms\nworth of 16-bit 48KHz stereo PCM, which is about 3,840 bytes\nper frame (20ms worth of audio).",
            "A bytes like object that represents the PCM or Opus data.",
            "bytes",
            "Represents an FFmpeg (or AVConv) based AudioSource.",
            "User created AudioSources using FFmpeg differently from how FFmpegPCMAudio and\nFFmpegOpusAudio work should subclass this.",
            "New in version 1.3.",
            "source (str | io.BufferedIOBase) –",
            "executable (str) –",
            "args (Any) –",
            "subprocess_kwargs (Any) –",
            "Called when clean-up is needed to be done.",
            "Useful for clearing buffer data or processes after\nit is done playing audio.",
            "None",
            "An audio source from FFmpeg (or AVConv).",
            "This launches a sub-process to a specific input file given.",
            "Warning",
            "You must have the ffmpeg or avconv executable in your path environment\nvariable in order for this to work.",
            "source (Union[str, io.BufferedIOBase]) – The input that ffmpeg will take and convert to PCM bytes.\nIf pipe is True then this is a file-like object that is\npassed to the stdin of ffmpeg.",
            "executable (str) – The executable name (and path) to use. Defaults to ffmpeg.",
            "pipe (bool) – If True, denotes that source parameter will be passed\nto the stdin of ffmpeg. Defaults to False.",
            "stderr (Optional[file object]) – A file-like object to pass to the Popen constructor.\nCould also be an instance of subprocess.PIPE.",
            "before_options (Optional[str]) – Extra command line arguments to pass to ffmpeg before the -i flag.",
            "options (Optional[str]) – Extra command line arguments to pass to ffmpeg after the -i flag.",
            "ClientException – The subprocess failed to be created.",
            "Reads 20ms worth of audio.",
            "Subclasses must implement this.",
            "If the audio is complete, then returning an empty\nbytes-like object to signal this is the way to do so.",
            "If is_opus() method returns True, then it must return\n20ms worth of Opus encoded audio. Otherwise, it must be 20ms\nworth of 16-bit 48KHz stereo PCM, which is about 3,840 bytes\nper frame (20ms worth of audio).",
            "A bytes like object that represents the PCM or Opus data.",
            "bytes",
            "Checks if the audio source is already encoded in Opus.",
            "bool",
            "An audio source from FFmpeg (or AVConv).",
            "This launches a sub-process to a specific input file given.  However, rather than\nproducing PCM packets like FFmpegPCMAudio does that need to be encoded to\nOpus, this class produces Opus packets, skipping the encoding step done by the library.",
            "Alternatively, instead of instantiating this class directly, you can use\nFFmpegOpusAudio.from_probe() to probe for bitrate and codec information.  This\ncan be used to opportunistically skip pointless re-encoding of existing Opus audio data\nfor a boost in performance at the cost of a short initial delay to gather the information.\nThe same can be achieved by passing copy to the codec parameter, but only if you\nknow that the input source is Opus encoded beforehand.",
            "New in version 1.3.",
            "Warning",
            "You must have the ffmpeg or avconv executable in your path environment\nvariable in order for this to work.",
            "source (Union[str, io.BufferedIOBase]) – The input that ffmpeg will take and convert to Opus bytes.\nIf pipe is True then this is a file-like object that is\npassed to the stdin of ffmpeg.",
            "bitrate (int) – The bitrate in kbps to encode the output to.  Defaults to 128.",
            "codec (Optional[str]) – The codec to use to encode the audio data.  Normally this would be\njust libopus, but is used by FFmpegOpusAudio.from_probe() to\nopportunistically skip pointlessly re-encoding Opus audio data by passing\ncopy as the codec value.  Any values other than copy, opus, or\nlibopus will be considered libopus.  Defaults to libopus.\n\nWarning\nDo not provide this parameter unless you are certain that the audio input is\nalready Opus encoded.  For typical use FFmpegOpusAudio.from_probe()\nshould be used to determine the proper value for this parameter.",
            "The codec to use to encode the audio data.  Normally this would be\njust libopus, but is used by FFmpegOpusAudio.from_probe() to\nopportunistically skip pointlessly re-encoding Opus audio data by passing\ncopy as the codec value.  Any values other than copy, opus, or\nlibopus will be considered libopus.  Defaults to libopus.",
            "Warning",
            "Do not provide this parameter unless you are certain that the audio input is\nalready Opus encoded.  For typical use FFmpegOpusAudio.from_probe()\nshould be used to determine the proper value for this parameter.",
            "executable (str) – The executable name (and path) to use. Defaults to ffmpeg.",
            "pipe (bool) – If True, denotes that source parameter will be passed\nto the stdin of ffmpeg. Defaults to False.",
            "stderr (Optional[file object]) – A file-like object to pass to the Popen constructor.\nCould also be an instance of subprocess.PIPE.",
            "before_options (Optional[str]) – Extra command line arguments to pass to ffmpeg before the -i flag.",
            "options (Optional[str]) – Extra command line arguments to pass to ffmpeg after the -i flag.",
            "ClientException – The subprocess failed to be created.",
            "This function is a coroutine.",
            "A factory method that creates a FFmpegOpusAudio after probing\nthe input source for audio codec and bitrate information.",
            "source – Identical to the source parameter for the constructor.",
            "method (Optional[Union[str, Callable[str, str]]]) – The probing method used to determine bitrate and codec information. As a string, valid\nvalues are native to use ffprobe (or avprobe) and fallback to use ffmpeg\n(or avconv).  As a callable, it must take two string arguments, source and\nexecutable.  Both parameters are the same values passed to this factory function.\nexecutable will default to ffmpeg if not provided as a keyword argument.",
            "kwargs – The remaining parameters to be passed to the FFmpegOpusAudio constructor,\nexcluding bitrate and codec.",
            "An instance of this class.",
            "FFmpegOpusAudio",
            "AttributeError – Invalid probe method, must be 'native' or 'fallback'.",
            "TypeError – Invalid value for probe parameter, must be str or a callable.",
            "Examples",
            "Use this function to create an FFmpegOpusAudio instance instead of the constructor:",
            "If you are on Windows and don’t have ffprobe installed, use the fallback method\nto probe using ffmpeg instead:",
            "Using a custom method of determining codec and bitrate:",
            "This function is a coroutine.",
            "Probes the input source for bitrate and codec information.",
            "source (str) – Identical to the source parameter for FFmpegOpusAudio.",
            "method (str | Callable[[str, str], tuple[str | None, int | None]] | None) – Identical to the method parameter for FFmpegOpusAudio.from_probe().",
            "executable (str) – Identical to the executable parameter for FFmpegOpusAudio.",
            "A 2-tuple with the codec and bitrate of the input source.",
            "Optional[Tuple[Optional[str], Optional[int]]]",
            "AttributeError – Invalid probe method, must be 'native' or 'fallback'.",
            "TypeError – Invalid value for probe parameter, must be str or a callable.",
            "Reads 20ms worth of audio.",
            "Subclasses must implement this.",
            "If the audio is complete, then returning an empty\nbytes-like object to signal this is the way to do so.",
            "If is_opus() method returns True, then it must return\n20ms worth of Opus encoded audio. Otherwise, it must be 20ms\nworth of 16-bit 48KHz stereo PCM, which is about 3,840 bytes\nper frame (20ms worth of audio).",
            "A bytes like object that represents the PCM or Opus data.",
            "bytes",
            "Checks if the audio source is already encoded in Opus.",
            "bool",
            "Transforms a previous AudioSource to have volume controls.",
            "This does not work on audio sources that have AudioSource.is_opus()\nset to True.",
            "original (AudioSource) – The original AudioSource to transform.",
            "volume (float) – The initial volume to set it to.\nSee volume for more info.",
            "TypeError – Not an audio source.",
            "ClientException – The audio source is opus encoded.",
            "Retrieves or sets the volume as a floating point percentage (e.g. 1.0 for 100%).",
            "Called when clean-up is needed to be done.",
            "Useful for clearing buffer data or processes after\nit is done playing audio.",
            "None",
            "Reads 20ms worth of audio.",
            "Subclasses must implement this.",
            "If the audio is complete, then returning an empty\nbytes-like object to signal this is the way to do so.",
            "If is_opus() method returns True, then it must return\n20ms worth of Opus encoded audio. Otherwise, it must be 20ms\nworth of 16-bit 48KHz stereo PCM, which is about 3,840 bytes\nper frame (20ms worth of audio).",
            "A bytes like object that represents the PCM or Opus data.",
            "bytes"
        ],
        "code": [
            "VoiceChannel.connect()",
            "str",
            "str",
            "str",
            "abc.Connectable",
            "asyncio.AbstractEventLoop",
            "opus.load_opus()",
            "FFmpegOpusAudio",
            "Client",
            "Connectable",
            "bool",
            "None",
            "abc.Connectable",
            "None",
            "bool",
            "AudioSource",
            "after",
            "AudioSource",
            "Exception",
            "error",
            "AudioSource",
            "bytes",
            "Sink",
            "bool",
            "bool",
            "bool",
            "None",
            "None",
            "None",
            "bytes",
            "bool",
            "data",
            "None",
            "VoiceClient",
            "abc.Connectable.connect",
            "Client",
            "abc.Connectable",
            "VOICE_STATE_UPDATE",
            "dict",
            "None",
            "VOICE_SERVER_UPDATE",
            "dict",
            "None",
            "__init__",
            "connect()",
            "connect()",
            "disconnect()",
            "Guild.change_voice_state()",
            "on_voice_server_update()",
            "on_voice_state_update()",
            "float",
            "bool",
            "None",
            "cleanup()",
            "bool",
            "None",
            "disconnect()",
            "None",
            "is_opus()",
            "True",
            "bytes",
            "bool",
            "None",
            "BufferedIOBase",
            "is_opus()",
            "True",
            "bytes",
            "FFmpegPCMAudio",
            "FFmpegOpusAudio",
            "None",
            "str",
            "io.BufferedIOBase",
            "pipe",
            "True",
            "str",
            "ffmpeg",
            "bool",
            "True",
            "source",
            "False",
            "subprocess.PIPE",
            "str",
            "-i",
            "str",
            "-i",
            "is_opus()",
            "True",
            "bytes",
            "bool",
            "FFmpegPCMAudio",
            "FFmpegOpusAudio.from_probe()",
            "copy",
            "codec",
            "str",
            "io.BufferedIOBase",
            "pipe",
            "True",
            "int",
            "128",
            "str",
            "libopus",
            "FFmpegOpusAudio.from_probe()",
            "copy",
            "copy",
            "opus",
            "libopus",
            "libopus",
            "libopus",
            "FFmpegOpusAudio.from_probe()",
            "str",
            "ffmpeg",
            "bool",
            "True",
            "source",
            "False",
            "subprocess.PIPE",
            "str",
            "-i",
            "str",
            "-i",
            "FFmpegOpusAudio",
            "source",
            "str",
            "str",
            "str",
            "native",
            "fallback",
            "source",
            "executable",
            "executable",
            "ffmpeg",
            "FFmpegOpusAudio",
            "bitrate",
            "codec",
            "FFmpegOpusAudio",
            "'native'",
            "'fallback'",
            "probe",
            "str",
            "FFmpegOpusAudio",
            "source = await discord.FFmpegOpusAudio.from_probe(\"song.webm\")\nvoice_client.play(source)",
            "fallback",
            "source = await discord.FFmpegOpusAudio.from_probe(\"song.webm\", method='fallback')\nvoice_client.play(source)",
            "def custom_probe(source, executable):\n    # some analysis code here\n    return codec, bitrate\n\nsource = await discord.FFmpegOpusAudio.from_probe(\"song.webm\", method=custom_probe)\nvoice_client.play(source)",
            "source",
            "FFmpegOpusAudio",
            "method",
            "FFmpegOpusAudio.from_probe()",
            "str",
            "executable",
            "FFmpegOpusAudio",
            "str",
            "int",
            "'native'",
            "'fallback'",
            "probe",
            "str",
            "is_opus()",
            "True",
            "bytes",
            "bool",
            "AudioSource",
            "AudioSource.is_opus()",
            "True",
            "AudioSource",
            "float",
            "volume",
            "1.0",
            "None",
            "is_opus()",
            "True",
            "bytes"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/voice.html"
    },
    {
        "title": "Opus Library#",
        "content": [
            "Loads the libopus shared library for use with voice.",
            "If this function is not called then the library uses the function\nctypes.util.find_library() and then loads that one if available.",
            "Not loading a library and attempting to use PCM based AudioSources will\nlead to voice not working.",
            "This function propagates the exceptions thrown.",
            "Warning",
            "The bitness of the library must match the bitness of your python\ninterpreter. If the library is 64-bit then your python interpreter\nmust be 64-bit as well. Usually if there’s a mismatch in bitness then\nthe load will throw an exception.",
            "Note",
            "On Windows, this function should not need to be called as the binaries\nare automatically loaded.",
            "Note",
            "On Windows, the .dll extension is not necessary. However, on Linux\nthe full extension is required to load the library, e.g. libopus.so.1.\nOn Linux however, ctypes.util.find_library() will usually find the library automatically\nwithout you having to call this.",
            "name (str) – The filename of the shared library.",
            "None",
            "Function to check if opus lib is successfully loaded either\nvia the ctypes.util.find_library() call of load_opus().",
            "This must return True for voice to work.",
            "Indicates if the opus library has been loaded.",
            "bool"
        ],
        "code": [
            "ctypes.util.find_library()",
            "libopus.so.1",
            "ctypes.util.find_library()",
            "str",
            "None",
            "ctypes.util.find_library()",
            "load_opus()",
            "True",
            "bool",
            "VoiceClient",
            "session_id",
            "token",
            "endpoint",
            "channel",
            "loop",
            "guild",
            "user",
            "latency",
            "average_latency",
            "disconnect()",
            "move_to()",
            "is_connected()",
            "play()",
            "unpack_audio()",
            "start_recording()",
            "stop_recording()",
            "toggle_pause()",
            "is_playing()",
            "is_paused()",
            "stop()",
            "pause()",
            "resume()",
            "source",
            "send_audio_packet()",
            "VoiceProtocol",
            "on_voice_state_update()",
            "on_voice_server_update()",
            "connect()",
            "disconnect()",
            "cleanup()",
            "AudioSource",
            "read()",
            "is_opus()",
            "cleanup()",
            "PCMAudio",
            "stream",
            "read()",
            "FFmpegAudio",
            "cleanup()",
            "FFmpegPCMAudio",
            "read()",
            "is_opus()",
            "FFmpegOpusAudio",
            "from_probe()",
            "probe()",
            "read()",
            "is_opus()",
            "PCMVolumeTransformer",
            "volume",
            "cleanup()",
            "read()",
            "load_opus()",
            "is_loaded()"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/voice.html"
    },
    {
        "title": "Welcome to Pycord#",
        "content": [
            "Pycord is a modern, easy to use, feature-rich, and async ready API wrapper\nfor Discord.",
            "Features:",
            "Modern Pythonic API using async/await syntax",
            "Sane rate limit handling that prevents 429s",
            "Command extension to aid with bot creation",
            "Easy to use with an object oriented design",
            "Optimised for both speed and memory"
        ],
        "code": [
            "async",
            "await"
        ],
        "url": "https://docs.pycord.dev/en/stable/"
    },
    {
        "title": "Getting started#",
        "content": [
            "Is this your first time using the library? This is the place to get started!",
            "First steps: Installing Pycord | Quickstart | Setting Up Logging | Guide",
            "Working with Discord: Creating a Bot Account | A Primer to Gateway Intents",
            "Examples: Many examples are available in the repository."
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/"
    },
    {
        "title": "Getting help#",
        "content": [
            "If you’re having trouble with something, these resources might help.",
            "Try the Frequently Asked Questions first, it’s got answers to all common questions.",
            "Ask us and hang out with us in our Discord server.",
            "If you’re looking for something specific, try the index or searching.",
            "Report bugs in the issue tracker."
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/"
    },
    {
        "title": "Manuals#",
        "content": [
            "These pages go into great detail about everything the API can do."
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/"
    },
    {
        "title": "Core API#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/"
    },
    {
        "title": "Extensions#",
        "content": [
            "These extensions help you during development when it comes to common tasks.",
            "discord.ext.commands - Bot commands framework",
            "discord.ext.tasks - asyncio.Task helpers",
            "discord.ext.pages - A pagination extension module",
            "discord.ext.bridge - A module that bridges slash commands to prefixed commands"
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/"
    },
    {
        "title": "Meta#",
        "content": [
            "If you’re looking for something related to the project itself, it’s here.",
            "Changelog - The changelog for the library.",
            "Version Guarantees - The version guarantees for the library.",
            "Migrating to v1.0 - How to migrate from v0.x to v1.x.",
            "Migrating to v2.0 - How to migrate from v1.x to v2.x."
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/"
    },
    {
        "title": "Data Classes#",
        "content": [
            "Some classes are just there to be data containers, this lists them.",
            "Unlike models you are allowed to create\nmost of these yourself, even if they can also be used to hold attributes.",
            "Nearly all classes here have __slots__ defined which means that it is\nimpossible to have dynamic attributes to the data classes.",
            "The only exception to this rule is Object, which is made with\ndynamic attributes in mind.",
            "Represents a generic Discord object.",
            "The purpose of this class is to allow you to create ‘miniature’\nversions of data classes if you want to pass in just an ID. Most functions\nthat take in a specific data class with an ID can also take in this class\nas a substitute instead. Note that even though this is the case, not all\nobjects (if any) actually inherit from this class.",
            "There are also some cases where some WebSocket events are received\nin strange order and when such events happened you would\nreceive this class rather than the actual data class. These cases are\nextremely rare.",
            "Checks if two objects are equal.",
            "Checks if two objects are not equal.",
            "Returns the object’s hash.",
            "The ID of the object.",
            "int",
            "id (Union[SupportsInt, str, bytes, bytearray]) –",
            "Returns the snowflake’s creation time in UTC.",
            "Returns the worker id that made the snowflake.",
            "Returns the process id that made the snowflake.",
            "Returns the increment id that made the snowflake.",
            "Represents a discord.SelectMenu’s option.",
            "These can be created by users.",
            "New in version 2.0.",
            "The label of the option. This is displayed to users.\nCan only be up to 100 characters.",
            "str",
            "The value of the option. This is not displayed to users.\nIf not provided when constructed then it defaults to the\nlabel. Can only be up to 100 characters.",
            "str",
            "An additional description of the option, if any.\nCan only be up to 100 characters.",
            "Optional[str]",
            "Whether this option is selected by default.",
            "bool",
            "label (str) –",
            "value (str) –",
            "description (str | None) –",
            "emoji (str | Emoji | PartialEmoji | None) –",
            "default (bool) –",
            "The emoji of the option, if available.",
            "Wraps up a Discord gateway intent flag.",
            "Similar to Permissions, the properties provided are two way.\nYou can set and retrieve individual bits using the properties as if they\nwere regular bools.",
            "To construct an object you can pass keyword arguments denoting the flags\nto enable or disable.",
            "This is used to disable certain gateway features that are unnecessary to\nrun your bot. To make use of this, it is passed to the intents keyword\nargument of Client.",
            "New in version 1.5.",
            "Checks if two flags are equal.",
            "Checks if two flags are not equal.",
            "Adds two flags together. Equivalent to x | y.",
            "Subtracts two flags from each other.",
            "Returns the union of two flags. Equivalent to x + y.",
            "Returns the intersection of two flags.",
            "Returns the inverse of a flag.",
            "Return the flag’s hash.",
            "Returns an iterator of (name, value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.",
            "The raw value. You should query flags via the properties\nrather than using this raw value.",
            "int",
            "kwargs (bool) –",
            "A factory method that creates a Intents with everything enabled.",
            "A factory method that creates a Intents with everything disabled.",
            "A factory method that creates a Intents with everything enabled\nexcept presences, members, and message_content.",
            "Whether guild related events are enabled.",
            "This corresponds to the following events:",
            "on_guild_join()",
            "on_guild_remove()",
            "on_guild_available()",
            "on_guild_unavailable()",
            "on_guild_channel_update()",
            "on_guild_channel_create()",
            "on_guild_channel_delete()",
            "on_guild_channel_pins_update()",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "Client.guilds",
            "Guild and all its attributes.",
            "Client.get_channel()",
            "Client.get_all_channels()",
            "It is highly advisable to leave this intent enabled for your bot to function.",
            "bool",
            "Whether guild member related events are enabled.",
            "This corresponds to the following events:",
            "on_member_join()",
            "on_member_remove()",
            "on_raw_member_remove()",
            "on_member_update()",
            "on_user_update()",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "Client.get_all_members()",
            "Client.get_user()",
            "Guild.chunk()",
            "Guild.fetch_members()",
            "Guild.get_member()",
            "Guild.members",
            "Member.roles",
            "Member.nick",
            "Member.premium_since",
            "User.name",
            "User.avatar",
            "User.discriminator",
            "For more information go to the member intent documentation.",
            "Note",
            "This intent is privileged, meaning that bots in over 100 guilds that require this\nintent would need to request this intent on the Developer Portal.",
            "bool",
            "Alias of moderation.",
            "Changed in version 2.5: Changed to an alias.",
            "bool",
            "Whether guild moderation related events are enabled.",
            "This corresponds to the following events:",
            "on_audit_log_entry()",
            "on_member_ban()",
            "on_member_unban()",
            "This does not correspond to any attributes or classes in the library in terms of cache.",
            "bool",
            "Alias of emojis_and_stickers.",
            "Changed in version 2.0: Changed to an alias.",
            "bool",
            "Whether guild emoji and sticker related events are enabled.",
            "New in version 2.0.",
            "This corresponds to the following events:",
            "on_guild_emojis_update()",
            "on_guild_stickers_update()",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "Emoji",
            "GuildSticker",
            "Client.get_emoji()",
            "Client.get_sticker()",
            "Client.emojis()",
            "Client.stickers()",
            "Guild.emojis",
            "Guild.stickers",
            "bool",
            "Whether guild integration related events are enabled.",
            "This corresponds to the following events:",
            "on_guild_integrations_update()",
            "on_integration_create()",
            "on_integration_update()",
            "on_raw_integration_delete()",
            "This does not correspond to any attributes or classes in the library in terms of cache.",
            "bool",
            "Whether guild webhook related events are enabled.",
            "This corresponds to the following events:",
            "on_webhooks_update()",
            "This does not correspond to any attributes or classes in the library in terms of cache.",
            "bool",
            "Whether guild invite related events are enabled.",
            "This corresponds to the following events:",
            "on_invite_create()",
            "on_invite_delete()",
            "This does not correspond to any attributes or classes in the library in terms of cache.",
            "bool",
            "Whether guild voice state related events are enabled.",
            "This corresponds to the following events:",
            "on_voice_state_update()",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "VoiceChannel.members",
            "VoiceChannel.voice_states",
            "StageChannel.members",
            "StageChannel.speakers",
            "StageChannel.listeners",
            "StageChannel.moderators",
            "StageChannel.voice_states",
            "Member.voice",
            "Note",
            "This intent is required to connect to voice.",
            "bool",
            "Whether guild presence related events are enabled.",
            "This corresponds to the following events:",
            "on_presence_update()",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "Member.activities",
            "Member.status",
            "Member.raw_status",
            "For more information go to the presence intent documentation.",
            "Note",
            "This intent is privileged, meaning that bots in over 100 guilds that require this\nintent would need to request this intent on the Developer Portal.",
            "bool",
            "Whether guild and direct message related events are enabled.",
            "This is a shortcut to set or get both guild_messages and dm_messages.",
            "This corresponds to the following events:",
            "on_message() (both guilds and DMs)",
            "on_message_edit() (both guilds and DMs)",
            "on_message_delete() (both guilds and DMs)",
            "on_raw_message_delete() (both guilds and DMs)",
            "on_raw_message_edit() (both guilds and DMs)",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "Message",
            "Client.cached_messages",
            "Client.get_message()",
            "Client.polls",
            "Client.get_poll()",
            "Note that due to an implicit relationship this also corresponds to the following events:",
            "on_reaction_add() (both guilds and DMs)",
            "on_reaction_remove() (both guilds and DMs)",
            "on_reaction_clear() (both guilds and DMs)",
            "Note",
            "message_content is required to receive the actual content of guild messages.",
            "bool",
            "Whether guild message related events are enabled.",
            "See also dm_messages for DMs or messages for both.",
            "This corresponds to the following events:",
            "on_message() (only for guilds)",
            "on_message_edit() (only for guilds)",
            "on_message_delete() (only for guilds)",
            "on_raw_message_delete() (only for guilds)",
            "on_raw_message_edit() (only for guilds)",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "Message",
            "Client.cached_messages (only for guilds)",
            "Client.get_message() (only for guilds)",
            "Client.polls (only for guilds)",
            "Client.get_poll() (only for guilds)",
            "Note that due to an implicit relationship this also corresponds to the following events:",
            "on_reaction_add() (only for guilds)",
            "on_reaction_remove() (only for guilds)",
            "on_reaction_clear() (only for guilds)",
            "Without the message_content intent enabled,\nthe following fields are either an empty string or empty array:",
            "Message.content",
            "Message.embeds",
            "Message.attachments",
            "Message.components",
            "Message.poll",
            "For more information go to the message content intent documentation.",
            "bool",
            "Whether direct message related events are enabled.",
            "See also guild_messages for guilds or messages for both.",
            "This corresponds to the following events:",
            "on_message() (only for DMs)",
            "on_message_edit() (only for DMs)",
            "on_message_delete() (only for DMs)",
            "on_raw_message_delete() (only for DMs)",
            "on_raw_message_edit() (only for DMs)",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "Message",
            "Client.cached_messages (only for DMs)",
            "Client.get_message() (only for DMs)",
            "Client.polls (only for DMs)",
            "Client.get_poll() (only for DMs)",
            "Note that due to an implicit relationship this also corresponds to the following events:",
            "on_reaction_add() (only for DMs)",
            "on_reaction_remove() (only for DMs)",
            "on_reaction_clear() (only for DMs)",
            "bool",
            "Whether guild and direct message reaction related events are enabled.",
            "This is a shortcut to set or get both guild_reactions and dm_reactions.",
            "This corresponds to the following events:",
            "on_reaction_add() (both guilds and DMs)",
            "on_reaction_remove() (both guilds and DMs)",
            "on_reaction_clear() (both guilds and DMs)",
            "on_raw_reaction_add() (both guilds and DMs)",
            "on_raw_reaction_remove() (both guilds and DMs)",
            "on_raw_reaction_clear() (both guilds and DMs)",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "Message.reactions (both guild and DM messages)",
            "bool",
            "Whether guild message reaction related events are enabled.",
            "See also dm_reactions for DMs or reactions for both.",
            "This corresponds to the following events:",
            "on_reaction_add() (only for guilds)",
            "on_reaction_remove() (only for guilds)",
            "on_reaction_clear() (only for guilds)",
            "on_raw_reaction_add() (only for guilds)",
            "on_raw_reaction_remove() (only for guilds)",
            "on_raw_reaction_clear() (only for guilds)",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "Message.reactions (only for guild messages)",
            "bool",
            "Whether direct message reaction related events are enabled.",
            "See also guild_reactions for guilds or reactions for both.",
            "This corresponds to the following events:",
            "on_reaction_add() (only for DMs)",
            "on_reaction_remove() (only for DMs)",
            "on_reaction_clear() (only for DMs)",
            "on_raw_reaction_add() (only for DMs)",
            "on_raw_reaction_remove() (only for DMs)",
            "on_raw_reaction_clear() (only for DMs)",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "Message.reactions (only for DM messages)",
            "bool",
            "Whether guild and direct message typing related events are enabled.",
            "This is a shortcut to set or get both guild_typing and dm_typing.",
            "This corresponds to the following events:",
            "on_typing() (both guilds and DMs)",
            "This does not correspond to any attributes or classes in the library in terms of cache.",
            "bool",
            "Whether guild and direct message typing related events are enabled.",
            "See also dm_typing for DMs or typing for both.",
            "This corresponds to the following events:",
            "on_typing() (only for guilds)",
            "This does not correspond to any attributes or classes in the library in terms of cache.",
            "bool",
            "Whether guild and direct message typing related events are enabled.",
            "See also guild_typing for guilds or typing for both.",
            "This corresponds to the following events:",
            "on_typing() (only for DMs)",
            "This does not correspond to any attributes or classes in the library in terms of cache.",
            "bool",
            "Whether the bot will receive message content in guild messages.",
            "This corresponds to the following attributes:",
            "Message.content",
            "Message.embeds",
            "Message.attachments",
            "Message.components",
            "Message.poll",
            "These attributes will still be available for messages received from interactions,\nthe bot’s own messages, messages the bot was mentioned in, and DMs.",
            "New in version 2.0.",
            "Note",
            "As of September 2022 using this intent requires opting in explicitly via the Developer Portal to receive the actual content\nof the guild messages. This intent is privileged, meaning that bots in over 100 guilds that require this\nintent would need to request this intent on the Developer Portal.\nSee https://support-dev.discord.com/hc/en-us/articles/4404772028055 for more information.",
            "bool",
            "Whether “scheduled event” related events are enabled.",
            "This corresponds to the following events:",
            "on_scheduled_event_create()",
            "on_scheduled_event_update()",
            "on_scheduled_event_delete()",
            "on_scheduled_event_user_add()",
            "on_raw_scheduled_event_user_add()",
            "on_scheduled_event_user_remove()",
            "on_raw_scheduled_event_user_remove()",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "ScheduledEvent",
            "Guild.get_scheduled_event()",
            "bool",
            "Whether guild auto moderation configuration events are enabled.",
            "This corresponds to the following events:",
            "on_auto_moderation_rule_create()",
            "on_auto_moderation_rule_update()",
            "on_auto_moderation_rule_delete()",
            "bool",
            "Whether guild auto moderation execution events are enabled.",
            "This corresponds to the following events:",
            "on_auto_moderation_action_execution()",
            "bool",
            "Whether poll-related events in guilds are enabled.",
            "See also dm_polls for DMs or polls for both.",
            "This corresponds to the following events:",
            "on_poll_vote_add() (only for guilds)",
            "on_poll_vote_remove() (only for guilds)",
            "on_raw_poll_vote_add() (only for guilds)",
            "on_raw_poll_vote_remove() (only for guilds)",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "PollAnswer.count (only for guild polls)",
            "PollResults.answer_counts (only for guild polls)",
            "bool",
            "Whether poll-related events in direct messages are enabled.",
            "See also guild_polls for guilds or polls for both.",
            "This corresponds to the following events:",
            "on_poll_vote_add() (only for DMs)",
            "on_poll_vote_remove() (only for DMs)",
            "on_raw_poll_vote_add() (only for DMs)",
            "on_raw_poll_vote_remove() (only for DMs)",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "PollAnswer.count (only for DM polls)",
            "PollResults.answer_counts (only for DM polls)",
            "bool",
            "Whether poll-related events in guilds and direct messages are enabled.",
            "This is a shortcut to set or get both guild_polls and dm_polls.",
            "This corresponds to the following events:",
            "on_poll_vote_add() (both guilds and DMs)",
            "on_poll_vote_remove() (both guilds and DMs)",
            "on_raw_poll_vote_add() (both guilds and DMs)",
            "on_raw_poll_vote_remove() (both guilds and DMs)",
            "This also corresponds to the following attributes and classes in terms of cache:",
            "PollAnswer.count (both guild and DM polls)",
            "PollResults.answer_counts (both guild and DM polls)",
            "bool",
            "A class that gives information and control over a specific shard.",
            "You can retrieve this object via AutoShardedClient.get_shard()\nor AutoShardedClient.shards.",
            "New in version 1.4.",
            "The shard ID for this shard.",
            "int",
            "The shard count for this cluster. If this is None then the bot has not started yet.",
            "Optional[int]",
            "parent (Shard) –",
            "shard_count (int | None) –",
            "Whether the shard connection is currently closed.",
            "bool",
            "This function is a coroutine.",
            "Disconnects a shard. When this is called, the shard connection will no\nlonger be open.",
            "If the shard is already disconnected this does nothing.",
            "None",
            "This function is a coroutine.",
            "Disconnects and then connects the shard again.",
            "None",
            "This function is a coroutine.",
            "Connects a shard. If the shard is already connected this does nothing.",
            "None",
            "Measures latency between a HEARTBEAT and a HEARTBEAT_ACK in seconds for this shard.",
            "Whether the websocket is currently rate limited.",
            "This can be useful to know when deciding whether you should query members\nusing HTTP or via the gateway.\n:rtype: bool",
            "New in version 1.6."
        ],
        "code": [
            "Object",
            "int",
            "Union",
            "SupportsInt",
            "str",
            "bytes",
            "bytearray",
            "discord.SelectMenu",
            "str",
            "str",
            "str",
            "bool",
            "Permissions",
            "intents",
            "Client",
            "x | y",
            "x + y",
            "(name, value)",
            "int",
            "bool",
            "Intents",
            "Intents",
            "Intents",
            "presences",
            "members",
            "message_content",
            "on_guild_join()",
            "on_guild_remove()",
            "on_guild_available()",
            "on_guild_unavailable()",
            "on_guild_channel_update()",
            "on_guild_channel_create()",
            "on_guild_channel_delete()",
            "on_guild_channel_pins_update()",
            "Client.guilds",
            "Guild",
            "Client.get_channel()",
            "Client.get_all_channels()",
            "bool",
            "on_member_join()",
            "on_member_remove()",
            "on_raw_member_remove()",
            "on_member_update()",
            "on_user_update()",
            "Client.get_all_members()",
            "Client.get_user()",
            "Guild.chunk()",
            "Guild.fetch_members()",
            "Guild.get_member()",
            "Guild.members",
            "Member.roles",
            "Member.nick",
            "Member.premium_since",
            "User.name",
            "User.avatar",
            "User.discriminator",
            "bool",
            "moderation",
            "bool",
            "on_audit_log_entry()",
            "on_member_ban()",
            "on_member_unban()",
            "bool",
            "emojis_and_stickers",
            "bool",
            "on_guild_emojis_update()",
            "on_guild_stickers_update()",
            "Emoji",
            "GuildSticker",
            "Client.get_emoji()",
            "Client.get_sticker()",
            "Client.emojis()",
            "Client.stickers()",
            "Guild.emojis",
            "Guild.stickers",
            "bool",
            "on_guild_integrations_update()",
            "on_integration_create()",
            "on_integration_update()",
            "on_raw_integration_delete()",
            "bool",
            "on_webhooks_update()",
            "bool",
            "on_invite_create()",
            "on_invite_delete()",
            "bool",
            "on_voice_state_update()",
            "VoiceChannel.members",
            "VoiceChannel.voice_states",
            "StageChannel.members",
            "StageChannel.speakers",
            "StageChannel.listeners",
            "StageChannel.moderators",
            "StageChannel.voice_states",
            "Member.voice",
            "bool",
            "on_presence_update()",
            "Member.activities",
            "Member.status",
            "Member.raw_status",
            "bool",
            "guild_messages",
            "dm_messages",
            "on_message()",
            "on_message_edit()",
            "on_message_delete()",
            "on_raw_message_delete()",
            "on_raw_message_edit()",
            "Message",
            "Client.cached_messages",
            "Client.get_message()",
            "Client.polls",
            "Client.get_poll()",
            "on_reaction_add()",
            "on_reaction_remove()",
            "on_reaction_clear()",
            "message_content",
            "bool",
            "dm_messages",
            "messages",
            "on_message()",
            "on_message_edit()",
            "on_message_delete()",
            "on_raw_message_delete()",
            "on_raw_message_edit()",
            "Message",
            "Client.cached_messages",
            "Client.get_message()",
            "Client.polls",
            "Client.get_poll()",
            "on_reaction_add()",
            "on_reaction_remove()",
            "on_reaction_clear()",
            "message_content",
            "Message.content",
            "Message.embeds",
            "Message.attachments",
            "Message.components",
            "Message.poll",
            "bool",
            "guild_messages",
            "messages",
            "on_message()",
            "on_message_edit()",
            "on_message_delete()",
            "on_raw_message_delete()",
            "on_raw_message_edit()",
            "Message",
            "Client.cached_messages",
            "Client.get_message()",
            "Client.polls",
            "Client.get_poll()",
            "on_reaction_add()",
            "on_reaction_remove()",
            "on_reaction_clear()",
            "bool",
            "guild_reactions",
            "dm_reactions",
            "on_reaction_add()",
            "on_reaction_remove()",
            "on_reaction_clear()",
            "on_raw_reaction_add()",
            "on_raw_reaction_remove()",
            "on_raw_reaction_clear()",
            "Message.reactions",
            "bool",
            "dm_reactions",
            "reactions",
            "on_reaction_add()",
            "on_reaction_remove()",
            "on_reaction_clear()",
            "on_raw_reaction_add()",
            "on_raw_reaction_remove()",
            "on_raw_reaction_clear()",
            "Message.reactions",
            "bool",
            "guild_reactions",
            "reactions",
            "on_reaction_add()",
            "on_reaction_remove()",
            "on_reaction_clear()",
            "on_raw_reaction_add()",
            "on_raw_reaction_remove()",
            "on_raw_reaction_clear()",
            "Message.reactions",
            "bool",
            "guild_typing",
            "dm_typing",
            "on_typing()",
            "bool",
            "dm_typing",
            "typing",
            "on_typing()",
            "bool",
            "guild_typing",
            "typing",
            "on_typing()",
            "bool",
            "Message.content",
            "Message.embeds",
            "Message.attachments",
            "Message.components",
            "Message.poll",
            "bool",
            "on_scheduled_event_create()",
            "on_scheduled_event_update()",
            "on_scheduled_event_delete()",
            "on_scheduled_event_user_add()",
            "on_raw_scheduled_event_user_add()",
            "on_scheduled_event_user_remove()",
            "on_raw_scheduled_event_user_remove()",
            "ScheduledEvent",
            "Guild.get_scheduled_event()",
            "bool",
            "on_auto_moderation_rule_create()",
            "on_auto_moderation_rule_update()",
            "on_auto_moderation_rule_delete()",
            "bool",
            "on_auto_moderation_action_execution()",
            "bool",
            "dm_polls",
            "polls",
            "on_poll_vote_add()",
            "on_poll_vote_remove()",
            "on_raw_poll_vote_add()",
            "on_raw_poll_vote_remove()",
            "PollAnswer.count",
            "PollResults.answer_counts",
            "bool",
            "guild_polls",
            "polls",
            "on_poll_vote_add()",
            "on_poll_vote_remove()",
            "on_raw_poll_vote_add()",
            "on_raw_poll_vote_remove()",
            "PollAnswer.count",
            "PollResults.answer_counts",
            "bool",
            "guild_polls",
            "dm_polls",
            "on_poll_vote_add()",
            "on_poll_vote_remove()",
            "on_raw_poll_vote_add()",
            "on_raw_poll_vote_remove()",
            "PollAnswer.count",
            "PollResults.answer_counts",
            "bool",
            "AutoShardedClient.get_shard()",
            "AutoShardedClient.shards",
            "int",
            "None",
            "int",
            "bool",
            "None",
            "None",
            "None",
            "bool"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/data_classes.html"
    },
    {
        "title": "Message#",
        "content": [
            "A class that represents what mentions are allowed in a message.",
            "This class can be set during Client initialisation to apply\nto every message sent. It can also be applied on a per-message basis\nvia abc.Messageable.send() for more fine-grained control.",
            "Whether to allow everyone and here mentions. Defaults to True.",
            "bool",
            "Controls the users being mentioned. If True (the default) then\nusers are mentioned based on the message content. If False then\nusers are not mentioned at all. If a list of abc.Snowflake\nis given then only the users provided will be mentioned, provided those\nusers are in the message content.",
            "Union[bool, List[abc.Snowflake]]",
            "Controls the roles being mentioned. If True (the default) then\nroles are mentioned based on the message content. If False then\nroles are not mentioned at all. If a list of abc.Snowflake\nis given then only the roles provided will be mentioned, provided those\nroles are in the message content.",
            "Union[bool, List[abc.Snowflake]]",
            "Whether to mention the author of the message being replied to. Defaults\nto True.",
            "New in version 1.6.",
            "bool",
            "A factory method that returns a AllowedMentions with all fields explicitly set to True",
            "New in version 1.5.",
            "A factory method that returns a AllowedMentions with all fields set to False",
            "New in version 1.5.",
            "Represents a reference to a Message.",
            "New in version 1.5.",
            "Changed in version 1.6: This class can now be constructed by users.",
            "The id of the message referenced.",
            "Optional[int]",
            "The channel id of the message referenced.",
            "int",
            "The guild id of the message referenced.",
            "Optional[int]",
            "Whether replying to the referenced message should raise HTTPException\nif the message no longer exists or Discord could not fetch the message.",
            "New in version 1.7.",
            "bool",
            "The message that this reference resolved to. If this is None\nthen the original message was not fetched either due to the Discord API\nnot attempting to resolve it or it not being available at the time of creation.\nIf the message was resolved at a prior point but has since been deleted then\nthis will be of type DeletedReferencedMessage.",
            "Currently, this is mainly the replied to message when a user replies to a message.",
            "New in version 1.6.",
            "Optional[Union[Message, DeletedReferencedMessage]]",
            "message_id (int) –",
            "channel_id (int) –",
            "guild_id (int | None) –",
            "fail_if_not_exists (bool) –",
            "Creates a MessageReference from an existing Message.",
            "New in version 1.6.",
            "message (Message) – The message to be converted into a reference.",
            "fail_if_not_exists (bool) – Whether replying to the referenced message should raise HTTPException\nif the message no longer exists or Discord could not fetch the message.\n\nNew in version 1.7.",
            "Whether replying to the referenced message should raise HTTPException\nif the message no longer exists or Discord could not fetch the message.",
            "New in version 1.7.",
            "A reference to the message.",
            "MessageReference",
            "The cached message, if found in the internal message cache.",
            "Returns a URL that allows the client to jump to the referenced message.",
            "New in version 1.7.",
            "Represents information about a call in a private channel.",
            "New in version 2.6.",
            "state (ConnectionState) –",
            "data (MessageCall) –",
            "A list of User that participated in this call.",
            "If a user is not found in the client’s cache,\nthen it will be returned as an Object.",
            "An aware timestamp of when the call ended.",
            "Represents a partial message to aid with working messages when only\na message and channel ID are present.",
            "There are two ways to construct this class. The first one is through\nthe constructor itself, and the second is via the following:",
            "TextChannel.get_partial_message()",
            "Thread.get_partial_message()",
            "DMChannel.get_partial_message()",
            "VoiceChannel.get_partial_message()",
            "StageChannel.get_partial_message()",
            "PartialMessageable.get_partial_message()",
            "Note that this class is trimmed down and has no rich attributes.",
            "New in version 1.6.",
            "Checks if two partial messages are equal.",
            "Checks if two partial messages are not equal.",
            "Returns the partial message’s hash.",
            "The channel associated with this partial message.",
            "Union[TextChannel, Thread, DMChannel, VoiceChannel, StageChannel, PartialMessageable]",
            "The message ID.",
            "int",
            "channel (Union[TextChannel, VoiceChannel, StageChannel, Thread, DMChannel, PartialMessageable]) –",
            "id (int) –",
            "Returns a URL that allows the client to jump to this message.",
            "This function is a coroutine.",
            "Deletes the message.",
            "Your own messages could be deleted without any proper permissions. However, to\ndelete other people’s messages, you need the manage_messages\npermission.",
            "Changed in version 1.1: Added the new delay keyword-only parameter.",
            "delay (Optional[float]) – If provided, the number of seconds to wait in the background\nbefore deleting the message. If the deletion fails then it is silently ignored.",
            "reason (Optional[str]) – The reason for deleting the message. Shows up on the audit log.",
            "Forbidden – You do not have proper permissions to delete the message.",
            "NotFound – The message was deleted already",
            "HTTPException – Deleting the message failed.",
            "None",
            "This function is a coroutine.",
            "Publishes this message to your announcement channel.",
            "You must have the send_messages permission to do this.",
            "If the message is not your own then the manage_messages\npermission is also needed.",
            "Forbidden – You do not have the proper permissions to publish this message.",
            "HTTPException – Publishing the message failed.",
            "None",
            "This function is a coroutine.",
            "Pins the message.",
            "You must have the manage_messages permission to do\nthis in a non-private channel context.",
            "reason (Optional[str]) – The reason for pinning the message. Shows up on the audit log.\n\nNew in version 1.4.",
            "The reason for pinning the message. Shows up on the audit log.",
            "New in version 1.4.",
            "Forbidden – You do not have permissions to pin the message.",
            "NotFound – The message or channel was not found or deleted.",
            "HTTPException – Pinning the message failed, probably due to the channel\n    having more than 50 pinned messages.",
            "None",
            "This function is a coroutine.",
            "Unpins the message.",
            "You must have the manage_messages permission to do\nthis in a non-private channel context.",
            "reason (Optional[str]) – The reason for unpinning the message. Shows up on the audit log.\n\nNew in version 1.4.",
            "The reason for unpinning the message. Shows up on the audit log.",
            "New in version 1.4.",
            "Forbidden – You do not have permissions to unpin the message.",
            "NotFound – The message or channel was not found or deleted.",
            "HTTPException – Unpinning the message failed.",
            "None",
            "This function is a coroutine.",
            "Add a reaction to the message.",
            "The emoji may be a unicode emoji or a custom guild Emoji.",
            "You must have the read_message_history permission\nto use this. If nobody else has reacted to the message using this\nemoji, the add_reactions permission is required.",
            "emoji (Union[Emoji, Reaction, PartialEmoji, str]) – The emoji to react with.",
            "HTTPException – Adding the reaction failed.",
            "Forbidden – You do not have the proper permissions to react to the message.",
            "NotFound – The emoji you specified was not found.",
            "InvalidArgument – The emoji parameter is invalid.",
            "None",
            "This function is a coroutine.",
            "Remove a reaction by the member from the message.",
            "The emoji may be a unicode emoji or a custom guild Emoji.",
            "If the reaction is not your own (i.e. member parameter is not you) then\nthe manage_messages permission is needed.",
            "The member parameter must represent a member and meet\nthe abc.Snowflake abc.",
            "emoji (Union[Emoji, Reaction, PartialEmoji, str]) – The emoji to remove.",
            "member (abc.Snowflake) – The member for which to remove the reaction.",
            "HTTPException – Removing the reaction failed.",
            "Forbidden – You do not have the proper permissions to remove the reaction.",
            "NotFound – The member or emoji you specified was not found.",
            "InvalidArgument – The emoji parameter is invalid.",
            "None",
            "This function is a coroutine.",
            "Clears a specific reaction from the message.",
            "The emoji may be a unicode emoji or a custom guild Emoji.",
            "You need the manage_messages permission to use this.",
            "New in version 1.3.",
            "emoji (Union[Emoji, Reaction, PartialEmoji, str]) – The emoji to clear.",
            "HTTPException – Clearing the reaction failed.",
            "Forbidden – You do not have the proper permissions to clear the reaction.",
            "NotFound – The emoji you specified was not found.",
            "InvalidArgument – The emoji parameter is invalid.",
            "None",
            "This function is a coroutine.",
            "Removes all the reactions from the message.",
            "You need the manage_messages permission to use this.",
            "HTTPException – Removing the reactions failed.",
            "Forbidden – You do not have the proper permissions to remove all the reactions.",
            "None",
            "This function is a coroutine.",
            "A shortcut method to abc.Messageable.send() to reply to the\nMessage.",
            "New in version 1.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size, or\n    you specified both file and files.",
            "content (str | None) –",
            "Creates a MessageReference from the current message.",
            "New in version 1.6.",
            "fail_if_not_exists (bool) – Whether replying using the message reference should raise HTTPException\nif the message no longer exists or Discord could not fetch the message.\n\nNew in version 1.7.",
            "Whether replying using the message reference should raise HTTPException\nif the message no longer exists or Discord could not fetch the message.",
            "New in version 1.7.",
            "The reference to this message.",
            "MessageReference",
            "The partial message’s creation time in UTC.",
            "The guild that the partial message belongs to, if applicable.",
            "This function is a coroutine.",
            "Fetches the partial message to a full Message.",
            "The full message.",
            "Message",
            "NotFound – The message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "This function is a coroutine.",
            "Edits the message.",
            "Changed in version 1.7: discord.Message is returned instead of None if an edit took place.",
            "content (Optional[str]) – The new content to replace the message with.\nCould be None to remove the content.",
            "embed (Optional[Embed]) – The new embed to replace the original with.\nCould be None to remove the embed.",
            "embeds (Optional[List[Embed]]) – A list of embeds to upload. Must be a maximum of 10.\n\nNew in version 2.0.",
            "A list of embeds to upload. Must be a maximum of 10.",
            "New in version 2.0.",
            "suppress (bool) – Whether to suppress embeds for the message. This removes\nall the embeds if set to True. If set to False\nthis brings the embeds back if they were suppressed.\nUsing this parameter requires manage_messages.",
            "delete_after (Optional[float]) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just edited. If the deletion fails,\nthen it is silently ignored.",
            "allowed_mentions (Optional[AllowedMentions]) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "view (Optional[View]) – The updated view to update this message with. If None is passed then\nthe view is removed.\n\nNew in version 2.0.",
            "The updated view to update this message with. If None is passed then\nthe view is removed.",
            "New in version 2.0.",
            "fields (Any) –",
            "The message that was edited.",
            "Optional[Message]",
            "NotFound – The message was not found.",
            "HTTPException – Editing the message failed.",
            "Forbidden – Tried to suppress a message without permissions or\n    edited a message’s content or embed that isn’t yours.",
            "This function is a coroutine.",
            "Immediately ends the poll associated with this message. Only doable by the poll’s owner.",
            "New in version 2.6.",
            "The updated message.",
            "Message",
            "Forbidden – You do not have permissions to end this poll.",
            "HTTPException – Ending this poll failed.",
            "A parameter object used for abc.Messageable.send()\nfor sending file objects.",
            "Note",
            "File objects are single use and are not meant to be reused in\nmultiple abc.Messageable.send()s.",
            "A file-like object opened in binary mode and read mode\nor a filename representing a file in the hard drive to\nopen.",
            "Note",
            "If the file-like object passed is opened via open then the\nmodes ‘rb’ should be used.",
            "To pass binary data, consider usage of io.BytesIO.",
            "Union[os.PathLike, io.BufferedIOBase]",
            "The filename to display when uploading to Discord.\nIf this is not given then it defaults to fp.name or if fp is\na string then the filename will default to the string given.",
            "Optional[str]",
            "The description of a file, used by Discord to display alternative text on images.",
            "Optional[str]",
            "Whether the attachment is a spoiler.",
            "bool",
            "fp (str | bytes | os.PathLike | io.BufferedIOBase) –",
            "filename (str | None) –",
            "description (str | None) –",
            "spoiler (bool) –"
        ],
        "code": [
            "Client",
            "abc.Messageable.send()",
            "True",
            "bool",
            "True",
            "False",
            "abc.Snowflake",
            "bool",
            "abc.Snowflake",
            "True",
            "False",
            "abc.Snowflake",
            "bool",
            "abc.Snowflake",
            "True",
            "bool",
            "AllowedMentions",
            "True",
            "AllowedMentions",
            "False",
            "Message",
            "int",
            "int",
            "int",
            "HTTPException",
            "bool",
            "None",
            "DeletedReferencedMessage",
            "Message",
            "DeletedReferencedMessage",
            "MessageReference",
            "Message",
            "Message",
            "bool",
            "HTTPException",
            "MessageReference",
            "ConnectionState",
            "MessageCall",
            "User",
            "Object",
            "TextChannel.get_partial_message()",
            "Thread.get_partial_message()",
            "DMChannel.get_partial_message()",
            "VoiceChannel.get_partial_message()",
            "StageChannel.get_partial_message()",
            "PartialMessageable.get_partial_message()",
            "TextChannel",
            "Thread",
            "DMChannel",
            "VoiceChannel",
            "StageChannel",
            "PartialMessageable",
            "int",
            "Union",
            "TextChannel",
            "VoiceChannel",
            "StageChannel",
            "Thread",
            "DMChannel",
            "PartialMessageable",
            "int",
            "manage_messages",
            "delay",
            "float",
            "str",
            "send_messages",
            "manage_messages",
            "None",
            "manage_messages",
            "str",
            "manage_messages",
            "str",
            "Emoji",
            "read_message_history",
            "add_reactions",
            "Emoji",
            "Reaction",
            "PartialEmoji",
            "str",
            "None",
            "Emoji",
            "member",
            "manage_messages",
            "member",
            "abc.Snowflake",
            "Emoji",
            "Reaction",
            "PartialEmoji",
            "str",
            "abc.Snowflake",
            "Emoji",
            "manage_messages",
            "Emoji",
            "Reaction",
            "PartialEmoji",
            "str",
            "manage_messages",
            "None",
            "abc.Messageable.send()",
            "Message",
            "Message",
            "files",
            "file",
            "files",
            "MessageReference",
            "bool",
            "HTTPException",
            "MessageReference",
            "Message",
            "Message",
            "discord.Message",
            "None",
            "str",
            "None",
            "Embed",
            "None",
            "Embed",
            "bool",
            "True",
            "False",
            "manage_messages",
            "float",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "View",
            "None",
            "Message",
            "Message",
            "abc.Messageable.send()",
            "abc.Messageable.send()",
            "open",
            "io.BytesIO",
            "os.PathLike",
            "io.BufferedIOBase",
            "fp.name",
            "fp",
            "filename",
            "str",
            "str",
            "bool"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/data_classes.html"
    },
    {
        "title": "Embed#",
        "content": [
            "Represents a Discord embed.",
            "Returns the total size of the embed.\nUseful for checking if it’s within the 6000 character limit.",
            "Returns whether the embed has any data set.",
            "New in version 2.0.",
            "For ease of use, all parameters that expect a str are implicitly\ncast to str for you.",
            "The title of the embed.\nThis can be set during initialisation.\nMust be 256 characters or fewer.",
            "str",
            "The type of embed. Usually “rich”.\nThis can be set during initialisation.\nPossible strings for embed types can be found on discord’s\napi docs",
            "str",
            "The description of the embed.\nThis can be set during initialisation.\nMust be 4096 characters or fewer.",
            "str",
            "The URL of the embed.\nThis can be set during initialisation.",
            "str",
            "The timestamp of the embed content. This is an aware datetime.\nIf a naive datetime is passed, it is converted to an aware\ndatetime with the local timezone.",
            "datetime.datetime",
            "The colour code of the embed. Aliased to color as well.\nThis can be set during initialisation.",
            "Union[Colour, int]",
            "colour (int | Colour | None) –",
            "color (int | Colour | None) –",
            "title (Any | None) –",
            "type (EmbedType) –",
            "url (Any | None) –",
            "description (Any | None) –",
            "timestamp (datetime.datetime | None) –",
            "fields (list[EmbedField] | None) –",
            "author (EmbedAuthor | None) –",
            "footer (EmbedFooter | None) –",
            "image (str | EmbedMedia | None) –",
            "thumbnail (str | EmbedMedia | None) –",
            "Converts a dict to a Embed provided it is in the\nformat that Discord expects it to be in.",
            "You can find out about this format in the official Discord documentation.",
            "data (dict) – The dictionary to convert into an embed.",
            "The converted embed object.",
            "Embed",
            "Creates a shallow copy of the Embed object.",
            "The copied embed object.",
            "Embed",
            "self (TypeVar(E, bound= Embed)) –",
            "Returns an EmbedFooter denoting the footer contents.",
            "See set_footer() for possible values you can access.",
            "If the footer is not set then None is returned.",
            "Sets the footer for the embed content.",
            "This function returns the class instance to allow for fluent-style\nchaining.",
            "text (str) – The footer text.\nMust be 2048 characters or fewer.",
            "icon_url (str) – The URL of the footer icon. Only HTTP(S) is supported.",
            "self (E) –",
            "E",
            "Clears embed’s footer information.",
            "This function returns the class instance to allow for fluent-style\nchaining.",
            "New in version 2.0.",
            "self (TypeVar(E, bound= Embed)) –",
            "TypeVar(E, bound= Embed)",
            "Returns an EmbedMedia denoting the image contents.",
            "Attributes you can access are:",
            "url",
            "proxy_url",
            "width",
            "height",
            "If the image is not set then None is returned.",
            "Sets the image for the embed content.",
            "This function returns the class instance to allow for fluent-style\nchaining.",
            "Changed in version 1.4: Passing None removes the image.",
            "url (str) – The source URL for the image. Only HTTP(S) is supported.",
            "self (E) –",
            "E",
            "Removes the embed’s image.",
            "This function returns the class instance to allow for fluent-style\nchaining.",
            "New in version 2.0.",
            "self (TypeVar(E, bound= Embed)) –",
            "TypeVar(E, bound= Embed)",
            "Returns an EmbedMedia denoting the thumbnail contents.",
            "Attributes you can access are:",
            "url",
            "proxy_url",
            "width",
            "height",
            "If the thumbnail is not set then None is returned.",
            "Sets the thumbnail for the embed content.",
            "This function returns the class instance to allow for fluent-style\nchaining.",
            "Changed in version 1.4: Passing None removes the thumbnail.",
            "url (str) – The source URL for the thumbnail. Only HTTP(S) is supported.",
            "self (E) –",
            "E",
            "Removes the embed’s thumbnail.",
            "This function returns the class instance to allow for fluent-style\nchaining.",
            "New in version 2.0.",
            "self (TypeVar(E, bound= Embed)) –",
            "TypeVar(E, bound= Embed)",
            "Returns an EmbedMedia denoting the video contents.",
            "Attributes include:",
            "url for the video URL.",
            "height for the video height.",
            "width for the video width.",
            "If the video is not set then None is returned.",
            "Returns an EmbedProvider denoting the provider contents.",
            "The only attributes that might be accessed are name and url.",
            "If the provider is not set then None is returned.",
            "Returns an EmbedAuthor denoting the author contents.",
            "See set_author() for possible values you can access.",
            "If the author is not set then None is returned.",
            "Sets the author for the embed content.",
            "This function returns the class instance to allow for fluent-style\nchaining.",
            "name (str) – The name of the author.\nMust be 256 characters or fewer.",
            "url (str) – The URL for the author.",
            "icon_url (str) – The URL of the author icon. Only HTTP(S) is supported.",
            "self (E) –",
            "E",
            "Clears embed’s author information.",
            "This function returns the class instance to allow for fluent-style\nchaining.",
            "New in version 1.4.",
            "self (TypeVar(E, bound= Embed)) –",
            "TypeVar(E, bound= Embed)",
            "Returns a list of EmbedField objects denoting the field contents.",
            "See add_field() for possible values you can access.",
            "If the attribute has no value then None is returned.",
            "Appends an EmbedField object to the embed.",
            "New in version 2.0.",
            "field (EmbedField) – The field to add.",
            "None",
            "Adds a field to the embed object.",
            "This function returns the class instance to allow for fluent-style\nchaining. There must be 25 fields or fewer.",
            "name (str) – The name of the field.\nMust be 256 characters or fewer.",
            "value (str) – The value of the field.\nMust be 1024 characters or fewer.",
            "inline (bool) – Whether the field should be displayed inline.",
            "self (TypeVar(E, bound= Embed)) –",
            "TypeVar(E, bound= Embed)",
            "Inserts a field before a specified index to the embed.",
            "This function returns the class instance to allow for fluent-style\nchaining. There must be 25 fields or fewer.",
            "New in version 1.2.",
            "index (int) – The index of where to insert the field.",
            "name (str) – The name of the field.\nMust be 256 characters or fewer.",
            "value (str) – The value of the field.\nMust be 1024 characters or fewer.",
            "inline (bool) – Whether the field should be displayed inline.",
            "self (TypeVar(E, bound= Embed)) –",
            "TypeVar(E, bound= Embed)",
            "Removes all fields from this embed.",
            "None",
            "Removes a field at a specified index.",
            "If the index is invalid or out of bounds then the error is\nsilently swallowed.",
            "Note",
            "When deleting a field by index, the index of the other fields\nshift to fill the gap just like a regular list.",
            "index (int) – The index of the field to remove.",
            "None",
            "Modifies a field to the embed object.",
            "The index must point to a valid pre-existing field. There must be 25 fields or fewer.",
            "This function returns the class instance to allow for fluent-style\nchaining.",
            "index (int) – The index of the field to modify.",
            "name (str) – The name of the field.\nMust be 256 characters or fewer.",
            "value (str) – The value of the field.\nMust be 1024 characters or fewer.",
            "inline (bool) – Whether the field should be displayed inline.",
            "self (TypeVar(E, bound= Embed)) –",
            "IndexError – An invalid index was provided.",
            "TypeVar(E, bound= Embed)",
            "Converts this embed object into a dict.",
            "A dictionary of str embed keys bound to the respective value.",
            "Dict[str, Union[str, int, bool]]",
            "Represents a field on the Embed object.",
            "New in version 2.0.",
            "The name of the field.",
            "str",
            "The value of the field.",
            "str",
            "Whether the field should be displayed inline.",
            "bool",
            "name (str) –",
            "value (str) –",
            "inline (bool | None) –",
            "Converts a dict to a EmbedField provided it is in the\nformat that Discord expects it to be in.",
            "You can find out about this format in the official Discord documentation.",
            "data (dict) – The dictionary to convert into an EmbedField object.",
            "EmbedField",
            "Converts this EmbedField object into a dict.",
            "A dictionary of str embed field keys bound to the respective value.",
            "Dict[str, Union[str, bool]]",
            "Represents the author on the Embed object.",
            "New in version 2.5.",
            "The name of the author.",
            "str",
            "The URL of the hyperlink created in the author’s name.",
            "str",
            "The URL of the author icon image.",
            "str",
            "The proxied URL of the author icon image. This can’t be set directly, it is set by Discord.",
            "str",
            "name (str) –",
            "url (str | None) –",
            "icon_url (str | None) –",
            "Represents the footer on the Embed object.",
            "New in version 2.5.",
            "The text inside the footer.",
            "str",
            "The URL of the footer icon image.",
            "str",
            "The proxied URL of the footer icon image. This can’t be set directly, it is set by Discord.",
            "str",
            "text (str) –",
            "icon_url (str | None) –",
            "Represents a media on the Embed object.\nThis includes thumbnails, images, and videos.",
            "New in version 2.5.",
            "The source URL of the media.",
            "str",
            "The proxied URL of the media.",
            "str",
            "The height of the media.",
            "int",
            "The width of the media.",
            "int",
            "url (str) –",
            "Represents a provider on the Embed object.",
            "New in version 2.5.",
            "The name of the provider.",
            "str",
            "The URL of the provider.",
            "str"
        ],
        "code": [
            "str",
            "str",
            "str",
            "str",
            "str",
            "str",
            "datetime.datetime",
            "color",
            "Colour",
            "int",
            "dict",
            "Embed",
            "dict",
            "Embed",
            "Embed",
            "Embed",
            "TypeVar",
            "E",
            "EmbedFooter",
            "set_footer()",
            "str",
            "str",
            "TypeVar",
            "E",
            "TypeVar",
            "E",
            "EmbedMedia",
            "url",
            "proxy_url",
            "width",
            "height",
            "str",
            "TypeVar",
            "E",
            "TypeVar",
            "E",
            "EmbedMedia",
            "url",
            "proxy_url",
            "width",
            "height",
            "str",
            "TypeVar",
            "E",
            "TypeVar",
            "E",
            "EmbedMedia",
            "url",
            "height",
            "width",
            "EmbedProvider",
            "name",
            "url",
            "EmbedAuthor",
            "set_author()",
            "str",
            "str",
            "str",
            "TypeVar",
            "E",
            "TypeVar",
            "E",
            "list",
            "EmbedField",
            "add_field()",
            "None",
            "EmbedField",
            "EmbedField",
            "None",
            "str",
            "str",
            "bool",
            "TypeVar",
            "E",
            "TypeVar",
            "E",
            "int",
            "str",
            "str",
            "bool",
            "TypeVar",
            "E",
            "TypeVar",
            "E",
            "None",
            "int",
            "None",
            "int",
            "str",
            "str",
            "bool",
            "TypeVar",
            "E",
            "TypeVar",
            "E",
            "str",
            "str",
            "str",
            "int",
            "bool",
            "Embed",
            "str",
            "str",
            "bool",
            "dict",
            "EmbedField",
            "dict",
            "str",
            "str",
            "str",
            "bool",
            "Embed",
            "str",
            "str",
            "str",
            "str",
            "Embed",
            "str",
            "str",
            "str",
            "Embed",
            "str",
            "str",
            "int",
            "int",
            "str",
            "Embed",
            "str",
            "str"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/data_classes.html"
    },
    {
        "title": "Poll#",
        "content": [
            "Represents a Poll. Polls are sent in regular messages, and you must have send_polls to send them.",
            "New in version 2.6.",
            "The poll’s question media, or a str representing the question text. Question text can be up to 300 characters.",
            "Union[PollMedia, str]",
            "A list of the poll’s answers. A maximum of 10 answers can be set.",
            "Optional[List[PollAnswer]]",
            "The number of hours until this poll expires. Users must specify this when creating a poll, but existing polls return expiry instead. Defaults to 24.",
            "int",
            "Whether multiple answers can be selected. Defaults to False.",
            "bool",
            "The poll’s layout type. Only one exists at the moment.",
            "PollLayoutType",
            "The results of this poll recieved from Discord. If None, this should be considered “unknown” rather than “no” results.",
            "Optional[PollResults]",
            "question (PollMedia | str) –",
            "answers (list[PollAnswer] | None) –",
            "duration (int | None) –",
            "allow_multiselect (bool | None) –",
            "layout_type (PollLayoutType | None) –",
            "An aware datetime object that specifies the date and time in UTC when the poll will end.",
            "Checks if this poll has completely ended. Shortcut for PollResults.is_finalized, if available.",
            "Returns a boolean if results is available, otherwise None.",
            "Optional[bool]",
            "Shortcut for PollResults.total_votes() This may not be precise if is_finalized is False.",
            "The total number of votes on this poll if results is available, otherwise None.",
            "Optional[int]",
            "Get a poll answer by ID.",
            "id (int) – The ID to search for.",
            "The returned answer or None if not found.",
            "Optional[PollAnswer]",
            "Add an answer to this poll.",
            "This function returns the class instance to allow for fluent-style\nchaining.",
            "text (str) – The answer text. Maximum 55 characters.",
            "emoji (Optional[Union[Emoji, PartialEmoji, str]]) – The answer’s emoji.",
            "ValueError – The poll already has 10 answers or text exceeds the character length.",
            "RuntimeError – You cannot add an answer to an existing poll.",
            "Poll",
            "Examples",
            "Regular usage",
            "Chaining style",
            "Immediately ends this poll, if attached to a message. Only doable by the poll’s owner.\nShortcut to Message.end_poll()",
            "The updated message.",
            "Message",
            "Forbidden – You do not have permissions to end this poll.",
            "HTTPException – Ending this poll failed.",
            "RuntimeError – This poll wasn’t recieved from a message.",
            "Represents a poll media object that supports both questions and answers.",
            "New in version 2.6.",
            "The question/answer text. May have up to 300 characters for questions and 55 characters for answers.",
            "str",
            "The answer’s emoji.",
            "Optional[Union[Emoji, PartialEmoji, str]]",
            "text (str) –",
            "emoji (Emoji | PartialEmoji | str | None) –",
            "Represents a poll answer object.",
            "New in version 2.6.",
            "The answer’s ID. It currently starts at 1 for the first answer, then goes up sequentially.\nIt may not be reliable to depend on this.",
            "int",
            "The relevant media for this answer.",
            "PollMedia",
            "text (str) –",
            "emoji (Emoji | PartialEmoji | str | None) –",
            "The answer’s text. Shortcut for PollMedia.text.",
            "The answer’s emoji. Shortcut for PollMedia.emoji.",
            "This answer’s vote count, if recieved from Discord.",
            "Returns an AsyncIterator representing the users that have voted with this answer.\nOnly works if this poll was recieved from Discord.",
            "The after parameter must represent a member\nand meet the abc.Snowflake abc.",
            "limit (Optional[int]) – The maximum number of results to return.\nIf not provided, returns all the users who\nvoted with this answer.",
            "after (Optional[abc.Snowflake]) – For pagination, answers are sorted by member.",
            "Union[User, Member] – The member (if retrievable) or the user that has voted\nwith this answer. The case where it can be a Member is\nin a guild message context. Sometimes it can be a User\nif the member has left the guild.",
            "HTTPException – Getting the voters for the answer failed.",
            "RuntimeError – This poll wasn’t recieved from a message.",
            "VoteIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "Represents a poll answer count object.",
            "New in version 2.6.",
            "The answer’s ID. It currently starts at 1 for the first answer, then goes up sequentially.\nIt may not be reliable to depend on this.",
            "int",
            "The number of votes for this answer.",
            "int",
            "If the current user voted this answer. This is always False for bots.",
            "bool",
            "data (PollAnswerCount) –",
            "Represents a poll results object.",
            "New in version 2.6.",
            "Whether the poll has ended and all answer counts have been precisely tallied.",
            "bool",
            "A list of counts for each answer. If an answer isn’t included, it has no votes.",
            "List[PollAnswerCount]",
            "data (PollResults) –",
            "Get the total number of votes across all answers. This may not be accurate if is_finalized is False.",
            "The total number of votes on this poll.",
            "int"
        ],
        "code": [
            "send_polls",
            "str",
            "PollMedia",
            "str",
            "PollAnswer",
            "expiry",
            "int",
            "False",
            "bool",
            "PollLayoutType",
            "None",
            "PollResults",
            "PollResults.is_finalized",
            "results",
            "None",
            "bool",
            "PollResults.total_votes()",
            "is_finalized",
            "False",
            "results",
            "None",
            "int",
            "int",
            "None",
            "PollAnswer",
            "str",
            "Emoji",
            "PartialEmoji",
            "str",
            "text",
            "poll = Poll(\n    question=PollMedia(\"What's your favorite color?\"),\n\n    answers=[PollAnswer(\"Red\", \"❤\")]\n    duration=24,\n    allow_multiselect=False\n)\npoll.add_answer(text=\"Green\", emoji=\"💚\")\npoll.add_answer(text=\"Blue\", emoji=\"💙\")",
            "poll = Poll(\"What's your favorite color?\").add_answer(\"Red\", emoji=\"❤\").add_answer(\"Green\").add_answer(\"Blue\")",
            "Message.end_poll()",
            "Message",
            "str",
            "Emoji",
            "PartialEmoji",
            "str",
            "1",
            "int",
            "PollMedia",
            "PollMedia.text",
            "PollMedia.emoji",
            "AsyncIterator",
            "after",
            "abc.Snowflake",
            "int",
            "abc.Snowflake",
            "User",
            "Member",
            "Member",
            "User",
            "async for user in answer.users():\n    print(f'{user} voted **{answer.text}**!')",
            "users = await answer.users().flatten()\n# users is now a list of User...\nwinner = random.choice(users)\nawait channel.send(f'{winner} has won the raffle.')",
            "1",
            "int",
            "int",
            "False",
            "bool",
            "PollAnswerCount",
            "bool",
            "PollAnswerCount",
            "PollResults",
            "is_finalized",
            "False",
            "int"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/data_classes.html"
    },
    {
        "title": "Flags#",
        "content": [
            "Controls the library’s cache policy when it comes to members.",
            "This allows for finer grained control over what members are cached.\nNote that the bot’s own member is always cached. This class is passed\nto the member_cache_flags parameter in Client.",
            "Due to a quirk in how Discord works, in order to ensure proper cleanup\nof cache resources it is recommended to have Intents.members\nenabled. Otherwise, the library cannot know when a member leaves a guild and\nis thus unable to clean up after itself.",
            "To construct an object you can pass keyword arguments denoting the flags\nto enable or disable.",
            "The default value is all flags enabled.",
            "New in version 1.5.",
            "Checks if two flags are equal.",
            "Checks if two flags are not equal.",
            "Adds two flags together. Equivalent to x | y.",
            "Subtracts two flags from each other.",
            "Returns the union of two flags. Equivalent to x + y.",
            "Returns the intersection of two flags.",
            "Returns the inverse of a flag.",
            "Return the flag’s hash.",
            "Returns an iterator of (name, value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.",
            "The raw value. You should query flags via the properties\nrather than using this raw value.",
            "int",
            "kwargs (bool) –",
            "A factory method that creates a MemberCacheFlags with everything enabled.",
            "A factory method that creates a MemberCacheFlags with everything disabled.",
            "Whether to cache members that are in voice.",
            "This requires Intents.voice_states.",
            "Members that leave voice are no longer cached.",
            "bool",
            "Whether to cache members that joined the guild\nor are chunked as part of the initial log in flow.",
            "This requires Intents.members.",
            "Members that leave the guild are no longer cached.",
            "bool",
            "Whether to cache members obtained through interactions.",
            "This includes members received through\ndiscord.Interaction and discord.Option.",
            "bool",
            "A factory method that creates a MemberCacheFlags based on\nthe currently selected Intents.",
            "intents (Intents) – The intents to select from.",
            "The resulting member cache flags.",
            "MemberCacheFlags",
            "Wraps up the Discord Application flags.",
            "Checks if two ApplicationFlags are equal.",
            "Checks if two ApplicationFlags are not equal.",
            "Adds two flags together. Equivalent to x | y.",
            "Subtracts two flags from each other.",
            "Returns the union of two flags. Equivalent to x + y.",
            "Returns the intersection of two flags.",
            "Returns the inverse of a flag.",
            "Return the flag’s hash.",
            "Returns an iterator of (name, value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.\nNote that aliases are not shown.",
            "New in version 2.0.",
            "The raw value. You should query flags via the properties\nrather than using this raw value.",
            "int",
            "kwargs (bool) –",
            "Returns True if the application is a managed emoji.",
            "bool",
            "Returns True if the application can create group DMs.",
            "bool",
            "Returns True if the application uses the Auto Moderation API.",
            "New in version 2.5.",
            "bool",
            "Returns True if the application has connected to RPC.",
            "bool",
            "Returns True if the application is verified and is allowed to\nreceive presence information over the gateway.",
            "bool",
            "Returns True if the application is allowed to receive limited\npresence information over the gateway.",
            "bool",
            "Returns True if the application is verified and is allowed to\nreceive guild members information over the gateway.",
            "bool",
            "Returns True if the application is allowed to receive limited\nguild members information over the gateway.",
            "bool",
            "Returns True if the application is currently pending verification\nand has hit the guild limit.",
            "bool",
            "Returns True if the application is embedded within the Discord client.",
            "bool",
            "Returns True if the application is allowed to read message contents in guilds.",
            "bool",
            "Returns True if the application is currently pending verification\nand has hit the guild limit.",
            "bool",
            "Returns True if the application has registered at least one global application\ncommand, and by extension has the badge.",
            "New in version 2.1.",
            "bool",
            "Returns True if the  app is considered active.\nApplications are considered active if they have had any command executions in the past 30 days.",
            "New in version 2.3.",
            "bool",
            "Wraps up a Discord system channel flag value.",
            "Similar to Permissions, the properties provided are two way.\nYou can set and retrieve individual bits using the properties as if they\nwere regular bools. This allows you to edit the system flags easily.",
            "To construct an object you can pass keyword arguments denoting the flags\nto enable or disable.",
            "Checks if two flags are equal.",
            "Checks if two flags are not equal.",
            "Adds two flags together. Equivalent to x | y.",
            "Subtracts two flags from each other.",
            "Returns the union of two flags. Equivalent to x + y.",
            "Returns the intersection of two flags.",
            "Returns the inverse of a flag.",
            "Return the flag’s hash.",
            "Returns an iterator of (name, value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.",
            "The raw value. This value is a bit array field of a 53-bit integer\nrepresenting the currently available flags. You should query\nflags via the properties rather than using this raw value.",
            "int",
            "kwargs (bool) –",
            "Returns True if the system channel is used for member join notifications.",
            "bool",
            "Returns True if the system channel is used for “Nitro boosting” notifications.",
            "bool",
            "Returns True if the system channel is used for server setup helpful tips notifications.",
            "New in version 2.0.",
            "bool",
            "Returns True if the system channel is allowing member join sticker replies.",
            "New in version 2.0.",
            "bool",
            "Wraps up a Discord Message flag value.",
            "See SystemChannelFlags.",
            "Checks if two flags are equal.",
            "Checks if two flags are not equal.",
            "Adds two flags together. Equivalent to x | y.",
            "Subtracts two flags from each other.",
            "Returns the union of two flags. Equivalent to x + y.",
            "Returns the intersection of two flags.",
            "Returns the inverse of a flag.",
            "Return the flag’s hash.",
            "Returns an iterator of (name, value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.",
            "New in version 1.3.",
            "The raw value. This value is a bit array field of a 53-bit integer\nrepresenting the currently available flags. You should query\nflags via the properties rather than using this raw value.",
            "int",
            "kwargs (bool) –",
            "Returns True if the message is the original crossposted message.",
            "bool",
            "Returns True if the message was crossposted from another channel.",
            "bool",
            "Returns True if the message’s embeds have been suppressed.",
            "bool",
            "Returns True if the source message for this crosspost has been deleted.",
            "bool",
            "Returns True if the source message is an urgent message.",
            "An urgent message is one sent by Discord Trust and Safety.",
            "bool",
            "Returns True if the source message is associated with a thread.",
            "New in version 2.0.",
            "bool",
            "Returns True if the source message is ephemeral.",
            "New in version 2.0.",
            "bool",
            "Returns True if the source message is deferred.",
            "The user sees a ‘thinking’ state.",
            "New in version 2.0.",
            "bool",
            "Returns True if some roles are failed to mention in a thread.",
            "New in version 2.0.",
            "bool",
            "Returns True if the source message does not trigger push and desktop notifications.",
            "Users will still receive mentions.",
            "New in version 2.4.",
            "bool",
            "Returns True if this message is a voice message.",
            "New in version 2.5.",
            "bool",
            "Wraps up the Discord Attachment flags.",
            "Checks if two flags are equal.",
            "Checks if two flags are not equal.",
            "Adds two flags together. Equivalent to x | y.",
            "Subtracts two flags from each other.",
            "Returns the union of two flags. Equivalent to x + y.",
            "Returns the intersection of two flags.",
            "Returns the inverse of a flag.",
            "Return the flag’s hash.",
            "Returns an iterator of (name, value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.\nNote that aliases are not shown.",
            "New in version 2.5.",
            "The raw value. You should query flags via the properties\nrather than using this raw value.",
            "int",
            "kwargs (bool) –",
            "Returns True if the attachment is a clip.",
            "bool",
            "Returns True if the attachment is a thumbnail.",
            "bool",
            "Returns True if the attachment has been remixed.",
            "bool",
            "Wraps up the Discord User Public flags.",
            "Checks if two PublicUserFlags are equal.",
            "Checks if two PublicUserFlags are not equal.",
            "Adds two flags together. Equivalent to x | y.",
            "Subtracts two flags from each other.",
            "Returns the union of two flags. Equivalent to x + y.",
            "Returns the intersection of two flags.",
            "Returns the inverse of a flag.",
            "Return the flag’s hash.",
            "Returns an iterator of (name, value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.\nNote that aliases are not shown.",
            "New in version 1.4.",
            "The raw value. This value is a bit array field of a 53-bit integer\nrepresenting the currently available flags. You should query\nflags via the properties rather than using this raw value.",
            "int",
            "kwargs (bool) –",
            "Returns True if the user is a Discord Employee.",
            "bool",
            "Returns True if the user is a Discord Partner.",
            "bool",
            "Returns True if the user is a HypeSquad Events member.",
            "bool",
            "Returns True if the user is a Bug Hunter",
            "bool",
            "Returns True if the user is marked as dismissed Nitro promotion",
            "bool",
            "Returns True if the user is a HypeSquad Bravery member.",
            "bool",
            "Returns True if the user is a HypeSquad Brilliance member.",
            "bool",
            "Returns True if the user is a HypeSquad Balance member.",
            "bool",
            "Returns True if the user is an Early Supporter.",
            "bool",
            "Returns True if the user is a Team User.",
            "bool",
            "Returns True if the user is a system user (i.e. represents Discord officially).",
            "bool",
            "Returns True if the user is a Bug Hunter Level 2",
            "bool",
            "Returns True if the user is a Verified Bot.",
            "bool",
            "Returns True if the user is an Early Verified Bot Developer.",
            "bool",
            "An alias for verified_bot_developer.",
            "New in version 1.5.",
            "bool",
            "Returns True if the user is a Discord Certified Moderator.",
            "New in version 2.0.",
            "bool",
            "Returns True if the bot has set an interactions endpoint url.",
            "New in version 2.0.",
            "bool",
            "Returns True if the user is an Active Developer.",
            "New in version 2.3.",
            "bool",
            "List[UserFlags]: Returns all public flags the user has.",
            "Wraps up the Discord Channel flags.",
            "Checks if two ChannelFlags are equal.",
            "Checks if two ChannelFlags are not equal.",
            "Adds two flags together. Equivalent to x | y.",
            "Subtracts two flags from each other.",
            "Returns the union of two flags. Equivalent to x + y.",
            "Returns the intersection of two flags.",
            "Returns the inverse of a flag.",
            "Return the flag’s hash.",
            "Returns an iterator of (name, value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.\nNote that aliases are not shown.",
            "New in version 2.0.",
            "The raw value. You should query flags via the properties\nrather than using this raw value.",
            "int",
            "kwargs (bool) –",
            "Returns True if the thread is pinned to the top of its parent forum channel.",
            "bool",
            "Returns True if a tag is required to be specified when creating a thread in a\nForumChannel.",
            "New in version 2.2.",
            "bool",
            "Wraps up the Discord SKU flags.",
            "Checks if two SKUFlags are equal.",
            "Checks if two SKUFlags are not equal.",
            "Adds two flags together. Equivalent to x | y.",
            "Subtracts two flags from each other.",
            "Returns the union of two flags. Equivalent to x + y.",
            "Returns the intersection of two flags.",
            "Returns the inverse of a flag.",
            "Return the flag’s hash.",
            "Returns an iterator of (name, value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.\nNote that aliases are not shown.",
            "New in version 2.5.",
            "The raw value. You should query flags via the properties\nrather than using this raw value.",
            "int",
            "kwargs (bool) –",
            "Returns True if the SKU is available for purchase.",
            "bool",
            "Returns True if the SKU is a guild subscription.",
            "bool",
            "Returns True if the SKU is a user subscription.",
            "bool",
            "Wraps up the Discord Member flags.",
            "Checks if two MemberFlags are equal.",
            "Checks if two MemberFlags are not equal.",
            "Adds two flags together. Equivalent to x | y.",
            "Subtracts two flags from each other.",
            "Returns the union of two flags. Equivalent to x + y.",
            "Returns the intersection of two flags.",
            "Returns the inverse of a flag.",
            "Return the flag’s hash.",
            "Returns an iterator of (name, value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.\nNote that aliases are not shown.",
            "New in version 2.6.",
            "The raw value. You should query flags via the properties\nrather than using this raw value.",
            "int",
            "kwargs (bool) –",
            "Returns True if the member left and rejoined the guild.",
            "bool",
            "Returns True if the member has completed onboarding.",
            "bool",
            "Returns True if the member is exempt from verification requirements.",
            "Note",
            "This can be edited through edit().",
            "bool",
            "Returns True if the member has started onboarding.",
            "bool",
            "Wraps up the Discord Role flags.",
            "Checks if two RoleFlags are equal.",
            "Checks if two RoleFlags are not equal.",
            "Adds two flags together. Equivalent to x | y.",
            "Subtracts two flags from each other.",
            "Returns the union of two flags. Equivalent to x + y.",
            "Returns the intersection of two flags.",
            "Returns the inverse of a flag.",
            "Return the flag’s hash.",
            "Returns an iterator of (name, value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.\nNote that aliases are not shown.",
            "New in version 2.6.",
            "The raw value. This value is a bit array field of a 53-bit integer\nrepresenting the currently available flags. You should query\nflags via the properties rather than using this raw value.",
            "int",
            "kwargs (bool) –",
            "Returns True if the role is selectable in one of the guild’s OnboardingPrompt.",
            "bool"
        ],
        "code": [
            "member_cache_flags",
            "Client",
            "Intents.members",
            "x | y",
            "x + y",
            "(name, value)",
            "int",
            "bool",
            "MemberCacheFlags",
            "MemberCacheFlags",
            "Intents.voice_states",
            "bool",
            "Intents.members",
            "bool",
            "discord.Interaction",
            "discord.Option",
            "bool",
            "MemberCacheFlags",
            "Intents",
            "Intents",
            "MemberCacheFlags",
            "x | y",
            "x + y",
            "(name, value)",
            "int",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "Permissions",
            "x | y",
            "x + y",
            "(name, value)",
            "int",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "SystemChannelFlags",
            "x | y",
            "x + y",
            "(name, value)",
            "int",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "x | y",
            "x + y",
            "(name, value)",
            "int",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "x | y",
            "x + y",
            "(name, value)",
            "int",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "verified_bot_developer",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "UserFlags",
            "x | y",
            "x + y",
            "(name, value)",
            "int",
            "bool",
            "True",
            "bool",
            "True",
            "ForumChannel",
            "bool",
            "x | y",
            "x + y",
            "(name, value)",
            "int",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "x | y",
            "x + y",
            "(name, value)",
            "int",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "edit()",
            "bool",
            "True",
            "bool",
            "x | y",
            "x + y",
            "(name, value)",
            "int",
            "bool",
            "True",
            "OnboardingPrompt",
            "bool"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/data_classes.html"
    },
    {
        "title": "Colour#",
        "content": [
            "Represents a Discord role colour. This class is similar\nto a (red, green, blue) tuple.",
            "There is an alias for this called Color.",
            "Checks if two colours are equal.",
            "Checks if two colours are not equal.",
            "Return the colour’s hash.",
            "Returns the hex format for the colour.",
            "Returns the raw colour value.",
            "The raw integer colour value.",
            "int",
            "value (int) –",
            "Returns the red component of the colour.",
            "Returns the green component of the colour.",
            "Returns the blue component of the colour.",
            "Returns an (r, g, b) tuple representing the colour.",
            "Constructs a Colour from an RGB tuple.",
            "Constructs a Colour from an HSV tuple.",
            "A factory method that returns a Colour with a value of 0.",
            "A factory method that returns a Colour with a random hue.",
            "Note",
            "The random algorithm works by choosing a colour with a random hue but\nwith maxed out saturation and value.",
            "New in version 1.6.",
            "seed (Optional[Union[int, str, float, bytes, bytearray]]) – The seed to initialize the RNG with. If None is passed the default RNG is used.\n\nNew in version 1.7.",
            "The seed to initialize the RNG with. If None is passed the default RNG is used.",
            "New in version 1.7.",
            "A factory method that returns a Colour with a value of 0x1abc9c.",
            "A factory method that returns a Colour with a value of 0x11806a.",
            "A factory method that returns a Colour with a value of 0x57F287.",
            "New in version 2.0.",
            "A factory method that returns a Colour with a value of 0x2ecc71.",
            "A factory method that returns a Colour with a value of 0x1f8b4c.",
            "A factory method that returns a Colour with a value of 0x3498db.",
            "A factory method that returns a Colour with a value of 0x206694.",
            "A factory method that returns a Colour with a value of 0x9b59b6.",
            "A factory method that returns a Colour with a value of 0x71368a.",
            "A factory method that returns a Colour with a value of 0xe91e63.",
            "A factory method that returns a Colour with a value of 0xad1457.",
            "A factory method that returns a Colour with a value of 0xf1c40f.",
            "A factory method that returns a Colour with a value of 0xc27c0e.",
            "A factory method that returns a Colour with a value of 0xe67e22.",
            "A factory method that returns a Colour with a value of 0xa84300.",
            "A factory method that returns a Colour with a value of 0xED4245.",
            "New in version 2.0.",
            "A factory method that returns a Colour with a value of 0xe74c3c.",
            "A factory method that returns a Colour with a value of 0x992d22.",
            "A factory method that returns a Colour with a value of 0x95a5a6.",
            "A factory method that returns a Colour with a value of 0x95a5a6.",
            "A factory method that returns a Colour with a value of 0x607d8b.",
            "A factory method that returns a Colour with a value of 0x607d8b.",
            "A factory method that returns a Colour with a value of 0x979c9f.",
            "A factory method that returns a Colour with a value of 0x979c9f.",
            "A factory method that returns a Colour with a value of 0x546e7a.",
            "A factory method that returns a Colour with a value of 0x546e7a.",
            "A factory method that returns a Colour with a value of 0x7289da.",
            "A factory method that returns a Colour with a value of 0x5865F2.",
            "A factory method that returns a Colour with a value of 0x99aab5.",
            "A factory method that returns a Colour with a value of 0x36393F.\nThis will appear transparent on Discord’s dark theme.",
            "New in version 1.5.",
            "A factory method that returns a Colour with a value of 0xEB459E.",
            "New in version 2.0.",
            "A factory method that returns a Colour with a value of 0xFEE75C.",
            "New in version 2.0.",
            "A factory method that returns a Colour with a value of 0xf47fff.",
            "New in version 2.0.",
            "A factory method that returns a Colour corresponding to the\nembed colours on discord clients, with a value of:",
            "0x2B2D31 (dark)",
            "0xEEEFF1 (light)",
            "0x000000 (amoled).",
            "New in version 2.0.",
            "theme (str) – The theme colour to apply, must be one of “dark”, “light”, or “amoled”."
        ],
        "code": [
            "tuple",
            "int",
            "int",
            "Colour",
            "Colour",
            "Colour",
            "0",
            "Colour",
            "int",
            "str",
            "float",
            "bytes",
            "bytearray",
            "None",
            "Colour",
            "0x1abc9c",
            "Colour",
            "0x11806a",
            "Colour",
            "0x57F287",
            "Colour",
            "0x2ecc71",
            "Colour",
            "0x1f8b4c",
            "Colour",
            "0x3498db",
            "Colour",
            "0x206694",
            "Colour",
            "0x9b59b6",
            "Colour",
            "0x71368a",
            "Colour",
            "0xe91e63",
            "Colour",
            "0xad1457",
            "Colour",
            "0xf1c40f",
            "Colour",
            "0xc27c0e",
            "Colour",
            "0xe67e22",
            "Colour",
            "0xa84300",
            "Colour",
            "0xED4245",
            "Colour",
            "0xe74c3c",
            "Colour",
            "0x992d22",
            "Colour",
            "0x95a5a6",
            "Colour",
            "0x95a5a6",
            "Colour",
            "0x607d8b",
            "Colour",
            "0x607d8b",
            "Colour",
            "0x979c9f",
            "Colour",
            "0x979c9f",
            "Colour",
            "0x546e7a",
            "Colour",
            "0x546e7a",
            "Colour",
            "0x7289da",
            "Colour",
            "0x5865F2",
            "Colour",
            "0x99aab5",
            "Colour",
            "0x36393F",
            "Colour",
            "0xEB459E",
            "Colour",
            "0xFEE75C",
            "Colour",
            "0xf47fff",
            "Colour",
            "0x2B2D31",
            "0xEEEFF1",
            "0x000000",
            "str"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/data_classes.html"
    },
    {
        "title": "Activity#",
        "content": [
            "Represents an activity in Discord.",
            "This could be an activity such as streaming, playing, listening\nor watching.",
            "For memory optimisation purposes, some activities are offered in slimmed\ndown versions:",
            "Game",
            "Streaming",
            "The application ID of the game.",
            "Optional[int]",
            "The name of the activity.",
            "Optional[str]",
            "A stream URL that the activity could be doing.",
            "Optional[str]",
            "The type of activity currently being done.",
            "ActivityType",
            "The user’s current party status or text used for a custom status.",
            "Optional[str]",
            "The detail of the user’s current activity.",
            "Optional[str]",
            "A dictionary of timestamps. It contains the following optional keys:",
            "start: Corresponds to when the user started doing the\nactivity in milliseconds since Unix epoch.",
            "end: Corresponds to when the user will finish doing the\nactivity in milliseconds since Unix epoch.",
            "Dict[str, int]",
            "A dictionary representing the images and their hover text of an activity.\nIt contains the following optional keys:",
            "large_image: A string representing the ID for the large image asset.",
            "large_text: A string representing the text when hovering over the large image asset.",
            "small_image: A string representing the ID for the small image asset.",
            "small_text: A string representing the text when hovering over the small image asset.",
            "Dict[str, str]",
            "A dictionary representing the activity party. It contains the following optional keys:",
            "id: A string representing the party ID.",
            "size: A list of up to two integer elements denoting (current_size, maximum_size).",
            "Dict[str, Union[str, List[int]]]",
            "A list of dictionaries representing custom buttons shown in a rich presence.\nEach dictionary contains the following keys:",
            "label: A string representing the text shown on the button.",
            "url: A string representing the URL opened upon clicking the button.",
            "Note",
            "Bots cannot access a user’s activity button URLs. Therefore, the type of this attribute\nwill be List[str] when received through the gateway.",
            "New in version 2.0.",
            "Union[List[Dict[str, str]], List[str]]",
            "The emoji that belongs to this activity.",
            "Optional[PartialEmoji]",
            "When the user started doing this activity in UTC, if applicable.",
            "When the user will stop doing this activity in UTC, if applicable.",
            "Returns a URL pointing to the large image asset of this activity if applicable.",
            "Returns a URL pointing to the small image asset of this activity if applicable.",
            "Returns the large image asset hover text of this activity if applicable.",
            "Returns the small image asset hover text of this activity if applicable.",
            "The base activity that all user-settable activities inherit from.\nA user-settable activity is one that can be used in Client.change_presence().",
            "The following types currently count as user-settable:",
            "Activity",
            "Game",
            "Streaming",
            "CustomActivity",
            "Note that although these types are considered user-settable by the library,\nDiscord typically ignores certain combinations of activity depending on\nwhat is currently set. This behaviour may change in the future so there are\nno guarantees on whether Discord will actually let you set these types.",
            "New in version 1.3.",
            "When the user started doing this activity in UTC.",
            "New in version 1.3.",
            "A slimmed down version of Activity that represents a Discord game.",
            "This is typically displayed via Playing on the official Discord client.",
            "Checks if two games are equal.",
            "Checks if two games are not equal.",
            "Returns the game’s hash.",
            "Returns the game’s name.",
            "name (str) – The game’s name.",
            "The game’s name.",
            "str",
            "Returns the game’s type. This is for compatibility with Activity.",
            "It always returns ActivityType.playing.",
            "When the user started playing this game in UTC, if applicable.",
            "When the user will stop playing this game in UTC, if applicable.",
            "A slimmed down version of Activity that represents a Discord streaming status.",
            "This is typically displayed via Streaming on the official Discord client.",
            "Checks if two streams are equal.",
            "Checks if two streams are not equal.",
            "Returns the stream’s hash.",
            "Returns the stream’s name.",
            "Where the user is streaming from (ie. YouTube, Twitch).",
            "New in version 1.3.",
            "Optional[str]",
            "The stream’s name.",
            "Optional[str]",
            "An alias for name",
            "Optional[str]",
            "The game being streamed.",
            "New in version 1.3.",
            "Optional[str]",
            "The stream’s URL.",
            "str",
            "A dictionary comprised of similar keys than those in Activity.assets.",
            "Dict[str, str]",
            "name (str | None) –",
            "url (str) –",
            "extra (Any) –",
            "Returns the game’s type. This is for compatibility with Activity.",
            "It always returns ActivityType.streaming.",
            "If provided, the twitch name of the user streaming.",
            "This corresponds to the large_image key of the Streaming.assets\ndictionary if it starts with twitch:. Typically this is set by the Discord client.",
            "Represents a Custom activity from Discord.",
            "Checks if two activities are equal.",
            "Checks if two activities are not equal.",
            "Returns the activity’s hash.",
            "Returns the custom status text.",
            "New in version 1.3.",
            "The custom activity’s name.",
            "Optional[str]",
            "The emoji to pass to the activity, if any.",
            "Optional[PartialEmoji]",
            "The text used for the custom activity.",
            "Optional[str]",
            "name (str | None) –",
            "emoji (PartialEmoji | None) –",
            "extra (Any) –",
            "Returns the activity’s type. This is for compatibility with Activity.",
            "It always returns ActivityType.custom."
        ],
        "code": [
            "Game",
            "Streaming",
            "int",
            "str",
            "str",
            "ActivityType",
            "str",
            "str",
            "start",
            "end",
            "str",
            "int",
            "large_image",
            "large_text",
            "small_image",
            "small_text",
            "str",
            "str",
            "id",
            "size",
            "str",
            "str",
            "int",
            "label",
            "url",
            "str",
            "str",
            "str",
            "str",
            "PartialEmoji",
            "Client.change_presence()",
            "Activity",
            "Game",
            "Streaming",
            "CustomActivity",
            "Activity",
            "str",
            "str",
            "Activity",
            "ActivityType.playing",
            "Activity",
            "str",
            "str",
            "name",
            "str",
            "str",
            "str",
            "Activity.assets",
            "str",
            "str",
            "Activity",
            "ActivityType.streaming",
            "large_image",
            "Streaming.assets",
            "twitch:",
            "str",
            "PartialEmoji",
            "str",
            "Activity",
            "ActivityType.custom"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/data_classes.html"
    },
    {
        "title": "Permissions#",
        "content": [
            "Wraps up the Discord permission value.",
            "The properties provided are two way. You can set and retrieve individual\nbits using the properties as if they were regular bools. This allows\nyou to edit permissions.",
            "Changed in version 1.3: You can now use keyword arguments to initialize Permissions\nsimilar to update().",
            "Checks if two permissions are equal.",
            "Checks if two permissions are not equal.",
            "Checks if a permission is a subset of another permission.",
            "Checks if a permission is a superset of another permission.",
            "Checks if a permission is a strict subset of another permission.",
            "Adds two permissions together. Equivalent to x | y.",
            "Subtracts two permissions from each other.",
            "Returns the union of two permissions. Equivalent to x + y.",
            "Returns the intersection of two permissions.",
            "Returns the inverse of a permission.",
            "Checks if a permission is a strict superset of another permission.",
            "Return the permission’s hash.",
            "Returns an iterator of (perm, value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.\nNote that aliases are not shown.",
            "The raw value. This value is a bit array field of a 53-bit integer\nrepresenting the currently available permissions. You should query\npermissions via the properties rather than using this raw value.",
            "int",
            "permissions (int) –",
            "kwargs (bool) –",
            "Returns True if self has the same or fewer permissions as other.",
            "other (Permissions) –",
            "bool",
            "Returns True if self has the same or more permissions as other.",
            "other (Permissions) –",
            "bool",
            "Returns True if the permissions on other are a strict subset of those on self.",
            "other (Permissions) –",
            "bool",
            "Returns True if the permissions on other are a strict superset of those on self.",
            "other (Permissions) –",
            "bool",
            "A factory method that creates a Permissions with all\npermissions set to False.",
            "A factory method that creates a Permissions with all\npermissions set to True.",
            "A Permissions with all channel-specific permissions set to\nTrue and the guild-specific ones set to False. The guild-specific\npermissions are currently:",
            "manage_emojis",
            "view_audit_log",
            "view_guild_insights",
            "manage_guild",
            "change_nickname",
            "manage_nicknames",
            "kick_members",
            "ban_members",
            "administrator",
            "Changed in version 1.7: Added stream, priority_speaker and use_slash_commands permissions.",
            "Changed in version 2.0: Added create_public_threads, create_private_threads, manage_threads,\nuse_external_stickers, send_messages_in_threads and\nrequest_to_speak permissions.",
            "A factory method that creates a Permissions with all\n“General” permissions from the official Discord UI set to True.",
            "Changed in version 1.7: Permission read_messages is now included in the general permissions, but\npermissions administrator, create_instant_invite, kick_members,\nban_members, change_nickname and manage_nicknames are\nno longer part of the general permissions.",
            "A factory method that creates a Permissions with all\n“Membership” permissions from the official Discord UI set to True.",
            "New in version 1.7.",
            "A factory method that creates a Permissions with all\n“Text” permissions from the official Discord UI set to True.",
            "Changed in version 1.7: Permission read_messages is no longer part of the text permissions.\nAdded use_slash_commands permission.",
            "Changed in version 2.0: Added create_public_threads, create_private_threads, manage_threads,\nsend_messages_in_threads and use_external_stickers permissions.",
            "A factory method that creates a Permissions with all\n“Voice” permissions from the official Discord UI set to True.",
            "A factory method that creates a Permissions with all\n“Stage Channel” permissions from the official Discord UI set to True.",
            "New in version 1.7.",
            "A factory method that creates a Permissions with all\n“Stage Moderator” permissions from the official Discord UI set to True.",
            "New in version 1.7.",
            "A factory method that creates a Permissions with all\n“Advanced” permissions from the official Discord UI set to True.",
            "New in version 1.7.",
            "Bulk updates this permission object.",
            "Allows you to set multiple attributes by using keyword\narguments. The names must be equivalent to the properties\nlisted. Extraneous key/value pairs will be silently ignored.",
            "**kwargs (bool) – A list of key/value pairs to bulk update permissions with.",
            "None",
            "Returns True if the user can create instant invites.",
            "bool",
            "Returns True if the user can kick users from the guild.",
            "bool",
            "Returns True if a user can ban users from the guild.",
            "bool",
            "Returns True if a user is an administrator. This role overrides all other permissions.",
            "This also bypasses all channel-specific overrides.",
            "bool",
            "Returns True if a user can edit, delete, or create channels in the guild.",
            "This also corresponds to the “Manage Channel” channel-specific override.",
            "bool",
            "Returns True if a user can edit guild properties.",
            "bool",
            "Returns True if a user can add reactions to messages.",
            "bool",
            "Returns True if a user can view the guild’s audit log.",
            "bool",
            "Returns True if a user can be more easily heard while talking.",
            "bool",
            "Returns True if a user can stream in a voice channel.",
            "bool",
            "Returns True if a user can view all or specific channels.",
            "bool",
            "An alias for view_channel.",
            "New in version 1.3.",
            "bool",
            "Returns True if a user can send messages from all or specific text channels.",
            "bool",
            "Returns True if a user can send TTS messages from all or specific text channels.",
            "bool",
            "Returns True if a user can delete or pin messages in a text channel.",
            "Note",
            "Note that there are currently no ways to edit other people’s messages.",
            "bool",
            "Returns True if a user’s messages will automatically be embedded by Discord.",
            "bool",
            "Returns True if a user can send files in their messages.",
            "bool",
            "Returns True if a user can read a text channel’s previous messages.",
            "bool",
            "Returns True if a user’s @everyone or @here will mention everyone in the text channel.",
            "bool",
            "Returns True if a user can use emojis from other guilds.",
            "bool",
            "An alias for external_emojis.",
            "New in version 1.3.",
            "bool",
            "Returns True if a user can view the guild’s insights.",
            "New in version 1.3.",
            "bool",
            "Returns True if a user can connect to a voice channel.",
            "bool",
            "Returns True if a user can speak in a voice channel.",
            "bool",
            "Returns True if a user can mute other users.",
            "bool",
            "Returns True if a user can deafen other users.",
            "bool",
            "Returns True if a user can move users between other voice channels.",
            "bool",
            "Returns True if a user can use voice activation in voice channels.",
            "bool",
            "Returns True if a user can change their nickname in the guild.",
            "bool",
            "Returns True if a user can change other user’s nickname in the guild.",
            "bool",
            "Returns True if a user can create or edit roles less than their role’s position.",
            "This also corresponds to the “Manage Permissions” channel-specific override.",
            "bool",
            "An alias for manage_roles.",
            "New in version 1.3.",
            "bool",
            "Returns True if a user can create, edit, or delete webhooks.",
            "bool",
            "Returns True if a user can create, edit, or delete emojis.",
            "bool",
            "An alias for manage_emojis.",
            "New in version 2.0.",
            "bool",
            "Returns True if a user can use slash commands.",
            "New in version 1.7.",
            "bool",
            "An alias for use_slash_commands.",
            "New in version 2.0.",
            "bool",
            "Returns True if a user can request to speak in a stage channel.",
            "New in version 1.7.",
            "bool",
            "Returns True if a user can manage guild events.",
            "New in version 2.0.",
            "bool",
            "Returns True if a user can manage threads.",
            "New in version 2.0.",
            "bool",
            "Returns True if a user can create public threads.",
            "New in version 2.0.",
            "bool",
            "Returns True if a user can create private threads.",
            "New in version 2.0.",
            "bool",
            "Returns True if a user can use stickers from other guilds.",
            "New in version 2.0.",
            "bool",
            "An alias for external_stickers.",
            "New in version 2.0.",
            "bool",
            "Returns True if a user can send messages in threads.",
            "New in version 2.0.",
            "bool",
            "Returns True if a user can launch an activity flagged ‘EMBEDDED’ in a voice channel.",
            "New in version 2.0.",
            "bool",
            "Returns True if a user can moderate members (timeout).",
            "New in version 2.0.",
            "bool",
            "Returns True if a member can send voice messages.",
            "New in version 2.5.",
            "bool",
            "Returns True if a member can set voice channel status.",
            "New in version 2.5.",
            "bool",
            "Returns True if a member can send polls.",
            "New in version 2.6.",
            "bool",
            "Returns True if a member’s user-installed apps can show public responses.\nUsers will still be able to use user-installed apps, but responses will be ephemeral.",
            "This only applies to apps that are also not installed to the guild.",
            "New in version 2.6.",
            "bool",
            "A type that is used to represent a channel specific permission.",
            "Unlike a regular Permissions, the default value of a\npermission is equivalent to None and not False. Setting\na value to False is explicitly denying that permission,\nwhile setting a value to True is explicitly allowing\nthat permission.",
            "The values supported by this are the same as Permissions\nwith the added possibility of it being set to None.",
            "Checks if two overwrites are equal.",
            "Checks if two overwrites are not equal.",
            "Returns an iterator of (perm, value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.\nNote that aliases are not shown.",
            "**kwargs (bool | None) – Set the value of permissions by their name.",
            "Returns the (allow, deny) pair from this overwrite.",
            "Creates an overwrite from an allow/deny pair of Permissions.",
            "Checks if the permission overwrite is currently empty.",
            "An empty permission overwrite is one that has no overwrites set\nto True or False.",
            "Indicates if the overwrite is empty.",
            "bool",
            "Bulk updates this permission overwrite object.",
            "Allows you to set multiple attributes by using keyword\narguments. The names must be equivalent to the properties\nlisted. Extraneous key/value pairs will be silently ignored.",
            "**kwargs (bool) – A list of key/value pairs to bulk update with.",
            "None"
        ],
        "code": [
            "Permissions",
            "update()",
            "x | y",
            "x + y",
            "(perm, value)",
            "int",
            "int",
            "bool",
            "True",
            "Permissions",
            "bool",
            "True",
            "Permissions",
            "bool",
            "True",
            "Permissions",
            "bool",
            "True",
            "Permissions",
            "bool",
            "Permissions",
            "False",
            "Permissions",
            "True",
            "Permissions",
            "True",
            "False",
            "manage_emojis",
            "view_audit_log",
            "view_guild_insights",
            "manage_guild",
            "change_nickname",
            "manage_nicknames",
            "kick_members",
            "ban_members",
            "administrator",
            "stream",
            "priority_speaker",
            "use_slash_commands",
            "create_public_threads",
            "create_private_threads",
            "manage_threads",
            "use_external_stickers",
            "send_messages_in_threads",
            "request_to_speak",
            "Permissions",
            "True",
            "read_messages",
            "administrator",
            "create_instant_invite",
            "kick_members",
            "ban_members",
            "change_nickname",
            "manage_nicknames",
            "Permissions",
            "True",
            "Permissions",
            "True",
            "read_messages",
            "use_slash_commands",
            "create_public_threads",
            "create_private_threads",
            "manage_threads",
            "send_messages_in_threads",
            "use_external_stickers",
            "Permissions",
            "True",
            "Permissions",
            "True",
            "Permissions",
            "True",
            "Permissions",
            "True",
            "bool",
            "None",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "view_channel",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "external_emojis",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "manage_roles",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "manage_emojis",
            "bool",
            "True",
            "bool",
            "use_slash_commands",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "external_stickers",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "True",
            "bool",
            "Permissions",
            "None",
            "False",
            "False",
            "True",
            "Permissions",
            "None",
            "(perm, value)",
            "Permissions",
            "True",
            "False",
            "bool",
            "bool",
            "None"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/data_classes.html"
    },
    {
        "title": "Application Role Connections#",
        "content": [
            "Represents role connection metadata for a Discord application.",
            "New in version 2.4.",
            "type (ApplicationRoleConnectionMetadataType) – The type of metadata value.",
            "key (str) – The key for this metadata field.\nMay only be the a-z, 0-9, or _ characters, with a maximum of 50 characters.",
            "name (str) – The name for this metadata field. Maximum 100 characters.",
            "description (str) – The description for this metadata field. Maximum 200 characters.",
            "name_localizations (Optional[Dict[str, str]]) – The name localizations for this metadata field. The values of this should be \"locale\": \"name\".\nSee here for a list of valid locales.",
            "description_localizations (Optional[Dict[str, str]]) – The description localizations for this metadata field. The values of this should be \"locale\": \"name\".\nSee here for a list of valid locales.",
            "The description localizations for this metadata field. The values of this should be \"locale\": \"name\".\nSee here for a list of valid locales."
        ],
        "code": [
            "ApplicationRoleConnectionMetadataType",
            "str",
            "a-z",
            "0-9",
            "_",
            "str",
            "str",
            "str",
            "str",
            "\"locale\": \"name\"",
            "str",
            "str",
            "\"locale\": \"name\"",
            "Object",
            "id",
            "created_at",
            "worker_id",
            "process_id",
            "increment_id",
            "SelectOption",
            "label",
            "value",
            "description",
            "default",
            "emoji",
            "Intents",
            "value",
            "all()",
            "none()",
            "default()",
            "guilds",
            "members",
            "bans",
            "moderation",
            "emojis",
            "emojis_and_stickers",
            "integrations",
            "webhooks",
            "invites",
            "voice_states",
            "presences",
            "messages",
            "guild_messages",
            "dm_messages",
            "reactions",
            "guild_reactions",
            "dm_reactions",
            "typing",
            "guild_typing",
            "dm_typing",
            "message_content",
            "scheduled_events",
            "auto_moderation_configuration",
            "auto_moderation_execution",
            "guild_polls",
            "dm_polls",
            "polls",
            "ShardInfo",
            "id",
            "shard_count",
            "is_closed()",
            "disconnect()",
            "reconnect()",
            "connect()",
            "latency",
            "is_ws_ratelimited()",
            "AllowedMentions",
            "everyone",
            "users",
            "roles",
            "replied_user",
            "all()",
            "none()",
            "MessageReference",
            "message_id",
            "channel_id",
            "guild_id",
            "fail_if_not_exists",
            "resolved",
            "from_message()",
            "cached_message",
            "jump_url",
            "MessageCall",
            "participants",
            "ended_at",
            "PartialMessage",
            "channel",
            "id",
            "jump_url",
            "delete()",
            "publish()",
            "pin()",
            "unpin()",
            "add_reaction()",
            "remove_reaction()",
            "clear_reaction()",
            "clear_reactions()",
            "reply()",
            "to_reference()",
            "created_at",
            "guild",
            "fetch()",
            "edit()",
            "end_poll()",
            "File",
            "fp",
            "filename",
            "description",
            "spoiler",
            "Embed",
            "title",
            "type",
            "description",
            "url",
            "timestamp",
            "colour",
            "from_dict()",
            "copy()",
            "footer",
            "set_footer()",
            "remove_footer()",
            "image",
            "set_image()",
            "remove_image()",
            "thumbnail",
            "set_thumbnail()",
            "remove_thumbnail()",
            "video",
            "provider",
            "author",
            "set_author()",
            "remove_author()",
            "fields",
            "append_field()",
            "add_field()",
            "insert_field_at()",
            "clear_fields()",
            "remove_field()",
            "set_field_at()",
            "to_dict()",
            "EmbedField",
            "name",
            "value",
            "inline",
            "from_dict()",
            "to_dict()",
            "EmbedAuthor",
            "name",
            "url",
            "icon_url",
            "proxy_icon_url",
            "EmbedFooter",
            "text",
            "icon_url",
            "proxy_icon_url",
            "EmbedMedia",
            "url",
            "proxy_url",
            "height",
            "width",
            "EmbedProvider",
            "name",
            "url",
            "Poll",
            "question",
            "answers",
            "duration",
            "allow_multiselect",
            "layout_type",
            "results",
            "expiry",
            "has_ended()",
            "total_votes()",
            "get_answer()",
            "add_answer()",
            "end()",
            "PollMedia",
            "text",
            "emoji",
            "PollAnswer",
            "id",
            "media",
            "text",
            "emoji",
            "count",
            "voters()",
            "PollAnswerCount",
            "id",
            "count",
            "me",
            "PollResults",
            "is_finalized",
            "answer_counts",
            "total_votes()",
            "MemberCacheFlags",
            "value",
            "all()",
            "none()",
            "voice",
            "joined",
            "interaction",
            "from_intents()",
            "ApplicationFlags",
            "value",
            "managed_emoji",
            "group_dm_create",
            "application_auto_moderation_rule_create_badge",
            "rpc_has_connected",
            "gateway_presence",
            "gateway_presence_limited",
            "gateway_guild_members",
            "gateway_guild_members_limited",
            "verification_pending_guild_limit",
            "embedded",
            "gateway_message_content",
            "gateway_message_content_limited",
            "app_commands_badge",
            "active",
            "SystemChannelFlags",
            "value",
            "join_notifications",
            "premium_subscriptions",
            "guild_reminder_notifications",
            "join_notification_replies",
            "MessageFlags",
            "value",
            "crossposted",
            "is_crossposted",
            "suppress_embeds",
            "source_message_deleted",
            "urgent",
            "has_thread",
            "ephemeral",
            "loading",
            "failed_to_mention_some_roles_in_thread",
            "suppress_notifications",
            "is_voice_message",
            "AttachmentFlags",
            "value",
            "is_clip",
            "is_thumbnail",
            "is_remix",
            "PublicUserFlags",
            "value",
            "staff",
            "partner",
            "hypesquad",
            "bug_hunter",
            "premium_promo_dismissed",
            "hypesquad_bravery",
            "hypesquad_brilliance",
            "hypesquad_balance",
            "early_supporter",
            "team_user",
            "system",
            "bug_hunter_level_2",
            "verified_bot",
            "verified_bot_developer",
            "early_verified_bot_developer",
            "discord_certified_moderator",
            "bot_http_interactions",
            "active_developer",
            "all()",
            "ChannelFlags",
            "value",
            "pinned",
            "require_tag",
            "SKUFlags",
            "value",
            "available",
            "guild_subscription",
            "user_subscription",
            "MemberFlags",
            "value",
            "did_rejoin",
            "completed_onboarding",
            "bypasses_verification",
            "started_onboarding",
            "RoleFlags",
            "value",
            "in_prompt",
            "Colour",
            "value",
            "r",
            "g",
            "b",
            "to_rgb()",
            "from_rgb()",
            "from_hsv()",
            "default()",
            "random()",
            "teal()",
            "dark_teal()",
            "brand_green()",
            "green()",
            "dark_green()",
            "blue()",
            "dark_blue()",
            "purple()",
            "dark_purple()",
            "magenta()",
            "dark_magenta()",
            "gold()",
            "dark_gold()",
            "orange()",
            "dark_orange()",
            "brand_red()",
            "red()",
            "dark_red()",
            "lighter_grey()",
            "lighter_gray()",
            "dark_grey()",
            "dark_gray()",
            "light_grey()",
            "light_gray()",
            "darker_grey()",
            "darker_gray()",
            "og_blurple()",
            "blurple()",
            "greyple()",
            "dark_theme()",
            "fuchsia()",
            "yellow()",
            "nitro_pink()",
            "embed_background()",
            "Activity",
            "application_id",
            "name",
            "url",
            "type",
            "state",
            "details",
            "timestamps",
            "assets",
            "party",
            "buttons",
            "emoji",
            "start",
            "end",
            "large_image_url",
            "small_image_url",
            "large_image_text",
            "small_image_text",
            "BaseActivity",
            "created_at",
            "Game",
            "name",
            "type",
            "start",
            "end",
            "Streaming",
            "platform",
            "name",
            "details",
            "game",
            "url",
            "assets",
            "type",
            "twitch_name",
            "CustomActivity",
            "name",
            "emoji",
            "state",
            "type",
            "Permissions",
            "value",
            "is_subset()",
            "is_superset()",
            "is_strict_subset()",
            "is_strict_superset()",
            "none()",
            "all()",
            "all_channel()",
            "general()",
            "membership()",
            "text()",
            "voice()",
            "stage()",
            "stage_moderator()",
            "advanced()",
            "update()",
            "create_instant_invite",
            "kick_members",
            "ban_members",
            "administrator",
            "manage_channels",
            "manage_guild",
            "add_reactions",
            "view_audit_log",
            "priority_speaker",
            "stream",
            "view_channel",
            "read_messages",
            "send_messages",
            "send_tts_messages",
            "manage_messages",
            "embed_links",
            "attach_files",
            "read_message_history",
            "mention_everyone",
            "external_emojis",
            "use_external_emojis",
            "view_guild_insights",
            "connect",
            "speak",
            "mute_members",
            "deafen_members",
            "move_members",
            "use_voice_activation",
            "change_nickname",
            "manage_nicknames",
            "manage_roles",
            "manage_permissions",
            "manage_webhooks",
            "manage_emojis",
            "manage_emojis_and_stickers",
            "use_slash_commands",
            "use_application_commands",
            "request_to_speak",
            "manage_events",
            "manage_threads",
            "create_public_threads",
            "create_private_threads",
            "external_stickers",
            "use_external_stickers",
            "send_messages_in_threads",
            "start_embedded_activities",
            "moderate_members",
            "send_voice_messages",
            "set_voice_channel_status",
            "send_polls",
            "use_external_apps",
            "PermissionOverwrite",
            "pair()",
            "from_pair()",
            "is_empty()",
            "update()",
            "ApplicationRoleConnectionMetadata"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/data_classes.html"
    },
    {
        "title": "Application Commands#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/api/application_commands.html"
    },
    {
        "title": "Command Permission Decorators#",
        "content": [
            "A decorator that limits the usage of an application command to members with certain\npermissions.",
            "The permissions passed in must be exactly like the properties shown under\ndiscord.Permissions.",
            "Note",
            "These permissions can be updated by server administrators per-guild. As such, these are only “defaults”, as the\nname suggests. If you want to make sure that a user always has the specified permissions regardless, you\nshould use an internal check such as has_permissions().",
            "**perms (Dict[str, bool]) – An argument list of permissions to check for.",
            "Callable",
            "Example",
            "A decorator that limits the usage of an application command to guild contexts.\nThe command won’t be able to be used in private message channels.",
            "Callable",
            "Example",
            "A decorator that limits the usage of an application command to 18+ channels and users.\nIn guilds, the command will only be able to be used in channels marked as NSFW.\nIn DMs, users must have opted into age-restricted commands via privacy settings.",
            "Note that apps intending to be listed in the App Directory cannot have NSFW commands.",
            "Callable",
            "Example"
        ],
        "code": [
            "discord.Permissions",
            "has_permissions()",
            "str",
            "bool",
            "Callable",
            "from discord import default_permissions\n\n@bot.slash_command()\n@default_permissions(manage_messages=True)\nasync def test(ctx):\n    await ctx.respond('You can manage messages.')",
            "Callable",
            "from discord import guild_only\n\n@bot.slash_command()\n@guild_only()\nasync def test(ctx):\n    await ctx.respond(\"You're in a guild.\")",
            "Callable",
            "from discord import is_nsfw\n\n@bot.slash_command()\n@is_nsfw()\nasync def test(ctx):\n    await ctx.respond(\"This command is age restricted.\")"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/application_commands.html"
    },
    {
        "title": "Commands#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/api/application_commands.html"
    },
    {
        "title": "Shortcut Decorators#",
        "content": [
            "A decorator that transforms a function into an ApplicationCommand. More specifically,\nusually one of SlashCommand, UserCommand, or MessageCommand. The exact class\ndepends on the cls parameter.\nBy default, the description attribute is received automatically from the\ndocstring of the function and is cleaned up with the use of\ninspect.cleandoc. If the docstring is bytes, then it is decoded\ninto str using utf-8 encoding.\nThe name attribute also defaults to the function name unchanged.",
            "New in version 2.0.",
            "cls (ApplicationCommand) – The class to construct with. By default, this is SlashCommand.\nYou usually do not change this.",
            "attrs – Keyword arguments to pass into the construction of the class denoted\nby cls.",
            "A decorator that converts the provided method into an ApplicationCommand, or subclass of it.",
            "Callable[…, ApplicationCommand]",
            "TypeError – If the function is not a coroutine or is already a command.",
            "An alias for application_command().",
            "Note",
            "This decorator is overridden by ext.commands.command().",
            "New in version 2.0.",
            "A decorator that converts the provided method into an ApplicationCommand.",
            "Callable[…, ApplicationCommand]",
            "Decorator for slash commands that invokes application_command().",
            "New in version 2.0.",
            "A decorator that converts the provided method into a SlashCommand.",
            "Callable[…, SlashCommand]",
            "Decorator for user commands that invokes application_command().",
            "New in version 2.0.",
            "A decorator that converts the provided method into a UserCommand.",
            "Callable[…, UserCommand]",
            "Decorator for message commands that invokes application_command().",
            "New in version 2.0.",
            "A decorator that converts the provided method into a MessageCommand.",
            "Callable[…, MessageCommand]"
        ],
        "code": [
            "ApplicationCommand",
            "SlashCommand",
            "UserCommand",
            "MessageCommand",
            "cls",
            "description",
            "inspect.cleandoc",
            "bytes",
            "str",
            "name",
            "ApplicationCommand",
            "SlashCommand",
            "cls",
            "ApplicationCommand",
            "ApplicationCommand",
            "application_command()",
            "ext.commands.command()",
            "ApplicationCommand",
            "ApplicationCommand",
            "application_command()",
            "SlashCommand",
            "SlashCommand",
            "application_command()",
            "UserCommand",
            "UserCommand",
            "application_command()",
            "MessageCommand",
            "MessageCommand"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/application_commands.html"
    },
    {
        "title": "Objects#",
        "content": [
            "func (Callable) –",
            "Checks whether the command is currently on cooldown.",
            "Note",
            "This uses the current time instead of the interaction time.",
            "ctx (ApplicationContext) – The invocation context to use when checking the command’s cooldown status.",
            "A boolean indicating if the command is on cooldown.",
            "bool",
            "Resets the cooldown on this command.",
            "ctx (ApplicationContext) – The invocation context to reset the cooldown under.",
            "None",
            "Retrieves the amount of seconds before this command can be tried again.",
            "Note",
            "This uses the current time instead of the interaction time.",
            "ctx (ApplicationContext) – The invocation context to retrieve the cooldown from.",
            "The amount of time left on this command’s cooldown in seconds.\nIf this is 0.0 then the command isn’t on cooldown.",
            "float",
            "A decorator that registers a coroutine as a local error handler.",
            "A local error handler is an on_command_error() event limited to\na single command. However, the on_command_error() is still\ninvoked afterwards as the catch-all.",
            "coro (coroutine) – The coroutine to register as the local error handler.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "Checks whether the command has an error handler registered.",
            "bool",
            "A decorator that registers a coroutine as a pre-invoke hook.\nA pre-invoke hook is called directly before the command is\ncalled. This makes it a useful function to set up database\nconnections or any type of set up required.",
            "This pre-invoke hook takes a sole parameter, an ApplicationContext.\nSee Bot.before_invoke() for more info.",
            "coro (coroutine) – The coroutine to register as the pre-invoke hook.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "A decorator that registers a coroutine as a post-invoke hook.\nA post-invoke hook is called directly after the command is\ncalled. This makes it a useful function to clean-up database\nconnections or any type of clean up required.",
            "This post-invoke hook takes a sole parameter, an ApplicationContext.\nSee Bot.after_invoke() for more info.",
            "coro (coroutine) – The coroutine to register as the post-invoke hook.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "Retrieves the fully qualified parent command name.",
            "This the base command name required to execute it. For example,\nin /one two three the parent name would be one two.",
            "Retrieves the fully qualified command name.",
            "This is the full parent name with the command name as well.\nFor example, in /one two three the qualified name would be\none two three.",
            "Retrieves the fully qualified command ID.",
            "This is the root parent ID. For example, in /one two three\nthe qualified ID would return one.id.",
            "A class that implements the protocol for a slash command.",
            "These are not created manually, instead they are created via the\ndecorator or functional interface.",
            "New in version 2.0.",
            "The name of the command.",
            "str",
            "The coroutine that is executed when the command is called.",
            "coroutine",
            "The description for the command.",
            "Optional[str]",
            "The ids of the guilds where this command will be registered.",
            "Optional[List[int]]",
            "The parameters for this command.",
            "List[Option]",
            "The parent group that this command belongs to. None if there\nisn’t one.",
            "Optional[SlashCommandGroup]",
            "Returns a string that allows you to mention the slash command.",
            "str",
            "Whether the command should only be usable inside a guild.",
            "Deprecated since version 2.6: Use the contexts parameter instead.",
            "bool",
            "Whether the command should be restricted to 18+ channels and users.\nApps intending to be listed in the App Directory cannot have NSFW commands.",
            "bool",
            "The default permissions a member needs to be able to run the command.",
            "Permissions",
            "The cog that this command belongs to. None if there isn’t one.",
            "Optional[Cog]",
            "A list of predicates that verifies if the command could be executed\nwith the given ApplicationContext as the sole parameter. If an exception\nis necessary to be thrown to signal failure, then one inherited from\nApplicationCommandError should be used. Note that if the checks fail then\nCheckFailure exception is raised to the on_application_command_error()\nevent.",
            "List[Callable[[ApplicationContext], bool]]",
            "The cooldown applied when the command is invoked. None if the command\ndoesn’t have a cooldown.",
            "Optional[Cooldown]",
            "The name localizations for this command. The values of this should be \"locale\": \"name\". See\nhere for a list of valid locales.",
            "Dict[str, str]",
            "The description localizations for this command. The values of this should be \"locale\": \"description\".\nSee here for a list of valid locales.",
            "Dict[str, str]",
            "The type of installation this command should be available to. For instance, if set to\nIntegrationType.user_install, the command will only be available to users with\nthe application installed on their account. Unapplicable for guild commands.",
            "Set[IntegrationType]",
            "The location where this command can be used. Cannot be set if this is a guild command.",
            "Set[InteractionContextType]",
            "func (Callable) –",
            "Creates a copy of this command.",
            "A new instance of this command.",
            "SlashCommand",
            "A class that implements the protocol for a slash command group.",
            "These can be created manually, but they should be created via the\ndecorator or functional interface.",
            "The name of the command.",
            "str",
            "The description for the command.",
            "Optional[str]",
            "The ids of the guilds where this command will be registered.",
            "Optional[List[int]]",
            "The parent group that this group belongs to. None if there\nisn’t one.",
            "Optional[SlashCommandGroup]",
            "Whether the command should only be usable inside a guild.",
            "Deprecated since version 2.6: Use the contexts parameter instead.",
            "bool",
            "Whether the command should be restricted to 18+ channels and users.\nApps intending to be listed in the App Directory cannot have NSFW commands.",
            "bool",
            "The default permissions a member needs to be able to run the command.",
            "Permissions",
            "A list of predicates that verifies if the command could be executed\nwith the given ApplicationContext as the sole parameter. If an exception\nis necessary to be thrown to signal failure, then one inherited from\nApplicationCommandError should be used. Note that if the checks fail then\nCheckFailure exception is raised to the on_application_command_error()\nevent.",
            "List[Callable[[ApplicationContext], bool]]",
            "The name localizations for this command. The values of this should be \"locale\": \"name\". See\nhere for a list of valid locales.",
            "Dict[str, str]",
            "The description localizations for this command. The values of this should be \"locale\": \"description\".\nSee here for a list of valid locales.",
            "Dict[str, str]",
            "The type of installation this command should be available to. For instance, if set to\nIntegrationType.user_install, the command will only be available to users with\nthe application installed on their account. Unapplicable for guild commands.",
            "Set[IntegrationType]",
            "The location where this command can be used. Unapplicable for guild commands.",
            "Set[InteractionContextType]",
            "name (str) –",
            "description (str | None) –",
            "guild_ids (list[int] | None) –",
            "parent (SlashCommandGroup | None) –",
            "cooldown (CooldownMapping | None) –",
            "max_concurrency (MaxConcurrency | None) –",
            "Creates a new subgroup for this SlashCommandGroup.",
            "name (str) – The name of the group to create.",
            "description (Optional[str]) – The description of the group to create.",
            "guild_ids (Optional[List[int]]) – A list of the IDs of each guild this group should be added to, making it a guild command.\nThis will be a global command if None is passed.",
            "guild_only (bool) – Whether the command should only be usable inside a guild.",
            "nsfw (bool) – Whether the command should be restricted to 18+ channels and users.\nApps intending to be listed in the App Directory cannot have NSFW commands.",
            "default_member_permissions (Permissions) – The default permissions a member needs to be able to run the command.",
            "checks (List[Callable[[ApplicationContext], bool]]) – A list of predicates that verifies if the command could be executed\nwith the given ApplicationContext as the sole parameter. If an exception\nis necessary to be thrown to signal failure, then one inherited from\nApplicationCommandError should be used. Note that if the checks fail then\nCheckFailure exception is raised to the on_application_command_error()\nevent.",
            "name_localizations (Dict[str, str]) – The name localizations for this command. The values of this should be \"locale\": \"name\". See\nhere for a list of valid locales.",
            "The name localizations for this command. The values of this should be \"locale\": \"name\". See\nhere for a list of valid locales.",
            "description_localizations (Dict[str, str]) – The description localizations for this command. The values of this should be \"locale\": \"description\".\nSee here for a list of valid locales.",
            "The description localizations for this command. The values of this should be \"locale\": \"description\".\nSee here for a list of valid locales.",
            "The slash command group that was created.",
            "SlashCommandGroup",
            "A shortcut decorator that initializes the provided subclass of SlashCommandGroup\nas a subgroup.",
            "New in version 2.0.",
            "name (Optional[str]) – The name of the group to create. This will resolve to the name of the decorated class if None is passed.",
            "description (Optional[str]) – The description of the group to create.",
            "guild_ids (Optional[List[int]]) – A list of the IDs of each guild this group should be added to, making it a guild command.\nThis will be a global command if None is passed.",
            "The slash command group that was created.",
            "Callable[[Type[SlashCommandGroup]], SlashCommandGroup]",
            "An iterator that recursively walks through all slash commands and groups in this group.",
            "SlashCommand | SlashCommandGroup – A nested slash command or slash command group from the group.",
            "Generator[SlashCommand | SlashCommandGroup, None, None]",
            "Creates a copy of this command group.",
            "A new instance of this command group.",
            "SlashCommandGroup",
            "A class that implements the protocol for user context menu commands.",
            "These are not created manually, instead they are created via the\ndecorator or functional interface.",
            "The name of the command.",
            "str",
            "The coroutine that is executed when the command is called.",
            "coroutine",
            "The ids of the guilds where this command will be registered.",
            "Optional[List[int]]",
            "Whether the command should only be usable inside a guild.",
            "Deprecated since version 2.6: Use the contexts parameter instead.",
            "bool",
            "Whether the command should be restricted to 18+ channels and users.\nApps intending to be listed in the App Directory cannot have NSFW commands.",
            "bool",
            "The default permissions a member needs to be able to run the command.",
            "Permissions",
            "The cog that this command belongs to. None if there isn’t one.",
            "Optional[Cog]",
            "A list of predicates that verifies if the command could be executed\nwith the given ApplicationContext as the sole parameter. If an exception\nis necessary to be thrown to signal failure, then one inherited from\nApplicationCommandError should be used. Note that if the checks fail then\nCheckFailure exception is raised to the on_application_command_error()\nevent.",
            "List[Callable[[ApplicationContext], bool]]",
            "The cooldown applied when the command is invoked. None if the command\ndoesn’t have a cooldown.",
            "Optional[Cooldown]",
            "The name localizations for this command. The values of this should be \"locale\": \"name\". See\nhere for a list of valid locales.",
            "Dict[str, str]",
            "The installation contexts where this command is available. Unapplicable for guild commands.",
            "Set[IntegrationType]",
            "The interaction contexts where this command is available. Unapplicable for guild commands.",
            "Set[InteractionContextType]",
            "func (Callable) –",
            "Creates a copy of this command.",
            "A new instance of this command.",
            "UserCommand",
            "A class that implements the protocol for message context menu commands.",
            "These are not created manually, instead they are created via the\ndecorator or functional interface.",
            "The name of the command.",
            "str",
            "The coroutine that is executed when the command is called.",
            "coroutine",
            "The ids of the guilds where this command will be registered.",
            "Optional[List[int]]",
            "Whether the command should only be usable inside a guild.",
            "Deprecated since version 2.6: Use the contexts parameter instead.",
            "bool",
            "Whether the command should be restricted to 18+ channels and users.\nApps intending to be listed in the App Directory cannot have NSFW commands.",
            "bool",
            "The default permissions a member needs to be able to run the command.",
            "Permissions",
            "The cog that this command belongs to. None if there isn’t one.",
            "Optional[Cog]",
            "A list of predicates that verifies if the command could be executed\nwith the given ApplicationContext as the sole parameter. If an exception\nis necessary to be thrown to signal failure, then one inherited from\nApplicationCommandError should be used. Note that if the checks fail then\nCheckFailure exception is raised to the on_application_command_error()\nevent.",
            "List[Callable[[ApplicationContext], bool]]",
            "The cooldown applied when the command is invoked. None if the command\ndoesn’t have a cooldown.",
            "Optional[Cooldown]",
            "The name localizations for this command. The values of this should be \"locale\": \"name\". See\nhere for a list of valid locales.",
            "Dict[str, str]",
            "The installation contexts where this command is available. Unapplicable for guild commands.",
            "Set[IntegrationType]",
            "The interaction contexts where this command is available. Unapplicable for guild commands.",
            "Set[InteractionContextType]",
            "func (Callable) –",
            "Creates a copy of this command.",
            "A new instance of this command.",
            "MessageCommand"
        ],
        "code": [
            "Callable",
            "ApplicationContext",
            "bool",
            "ApplicationContext",
            "None",
            "ApplicationContext",
            "0.0",
            "float",
            "on_command_error()",
            "on_command_error()",
            "bool",
            "ApplicationContext",
            "Bot.before_invoke()",
            "ApplicationContext",
            "Bot.after_invoke()",
            "/one two three",
            "one two",
            "/one two three",
            "one two three",
            "/one two three",
            "one.id",
            "str",
            "str",
            "int",
            "Option",
            "None",
            "SlashCommandGroup",
            "str",
            "contexts",
            "bool",
            "bool",
            "Permissions",
            "None",
            "Cog",
            "ApplicationContext",
            "ApplicationCommandError",
            "CheckFailure",
            "on_application_command_error()",
            "ApplicationContext",
            "bool",
            "None",
            "Cooldown",
            "\"locale\": \"name\"",
            "str",
            "str",
            "\"locale\": \"description\"",
            "str",
            "str",
            "IntegrationType.user_install",
            "IntegrationType",
            "InteractionContextType",
            "Callable",
            "SlashCommand",
            "str",
            "str",
            "int",
            "None",
            "SlashCommandGroup",
            "contexts",
            "bool",
            "bool",
            "Permissions",
            "ApplicationContext",
            "ApplicationCommandError",
            "CheckFailure",
            "on_application_command_error()",
            "ApplicationContext",
            "bool",
            "\"locale\": \"name\"",
            "str",
            "str",
            "\"locale\": \"description\"",
            "str",
            "str",
            "IntegrationType.user_install",
            "IntegrationType",
            "InteractionContextType",
            "str",
            "str",
            "int",
            "None",
            "bool",
            "bool",
            "Permissions",
            "ApplicationContext",
            "bool",
            "ApplicationContext",
            "ApplicationCommandError",
            "CheckFailure",
            "on_application_command_error()",
            "str",
            "str",
            "\"locale\": \"name\"",
            "str",
            "str",
            "\"locale\": \"description\"",
            "SlashCommandGroup",
            "str",
            "None",
            "str",
            "int",
            "None",
            "SlashCommand",
            "SlashCommandGroup",
            "SlashCommandGroup",
            "str",
            "int",
            "contexts",
            "bool",
            "bool",
            "Permissions",
            "None",
            "Cog",
            "ApplicationContext",
            "ApplicationCommandError",
            "CheckFailure",
            "on_application_command_error()",
            "ApplicationContext",
            "bool",
            "None",
            "Cooldown",
            "\"locale\": \"name\"",
            "str",
            "str",
            "IntegrationType",
            "InteractionContextType",
            "Callable",
            "UserCommand",
            "str",
            "int",
            "contexts",
            "bool",
            "bool",
            "Permissions",
            "None",
            "Cog",
            "ApplicationContext",
            "ApplicationCommandError",
            "CheckFailure",
            "on_application_command_error()",
            "ApplicationContext",
            "bool",
            "None",
            "Cooldown",
            "\"locale\": \"name\"",
            "str",
            "str",
            "IntegrationType",
            "InteractionContextType",
            "Callable",
            "MessageCommand"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/application_commands.html"
    },
    {
        "title": "Options#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/api/application_commands.html"
    },
    {
        "title": "Shortcut Decorators#",
        "content": [
            "A decorator that can be used instead of typehinting Option.",
            "New in version 2.0.",
            "The name of the target function parameter this option is mapped to.\nThis allows you to have a separate UI name and parameter name.",
            "str"
        ],
        "code": [
            "Option",
            "name",
            "str"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/application_commands.html"
    },
    {
        "title": "Objects#",
        "content": [
            "Represents a selectable option for a slash command.",
            "The type of input that is expected for this option. This can be a SlashCommandOptionType,\nan associated class, a channel type, a Converter, a converter class or an enum.Enum.\nIf a enum.Enum is used and it has up to 25 values, choices will be automatically filled. If the enum.Enum has more than 25 values, autocomplete will be implemented with discord.utils.basic_autocomplete() instead.",
            "Union[Type[str], Type[bool], Type[int], Type[float], Type[abc.GuildChannel], Type[Thread], Type[Member], Type[User], Type[Attachment], Type[Role], Type[abc.Mentionable], SlashCommandOptionType, Type[ext.commands.Converter], Type[enums.Enum], Type[Enum]]",
            "The name of this option visible in the UI.\nInherits from the variable name if not provided as a parameter.",
            "str",
            "The description of this option.\nMust be 100 characters or fewer. If input_type is a enum.Enum and description is not specified, input_type’s docstring will be used.",
            "Optional[str]",
            "The list of available choices for this option.\nCan be a list of values or OptionChoice objects (which represent a name:value pair).\nIf provided, the input from the user must match one of the choices in the list.",
            "Optional[List[Union[Any, OptionChoice]]]",
            "Whether this option is required.",
            "Optional[bool]",
            "The default value for this option. If provided, required will be considered False.",
            "Optional[Any]",
            "The minimum value that can be entered.\nOnly applies to Options with an input_type of int or float.",
            "Optional[int]",
            "The maximum value that can be entered.\nOnly applies to Options with an input_type of int or float.",
            "Optional[int]",
            "The minimum length of the string that can be entered. Must be between 0 and 6000 (inclusive).\nOnly applies to Options with an input_type of str.",
            "Optional[int]",
            "The maximum length of the string that can be entered. Must be between 1 and 6000 (inclusive).\nOnly applies to Options with an input_type of str.",
            "Optional[int]",
            "The autocomplete handler for the option. Accepts a callable (sync or async)\nthat takes a single argument of AutocompleteContext.\nThe callable must return an iterable of str or OptionChoice.\nAlternatively, discord.utils.basic_autocomplete() may be used in place of the callable.",
            "Note",
            "Does not validate the input value against the autocomplete results.",
            "Optional[Callable[[AutocompleteContext], Awaitable[Union[Iterable[OptionChoice], Iterable[str], Iterable[int], Iterable[float]]]]]",
            "A list of channel types that can be selected in this option.\nOnly applies to Options with an input_type of discord.SlashCommandOptionType.channel.\nIf this argument is used, input_type will be ignored.",
            "list[discord.ChannelType] | None",
            "The name localizations for this option. The values of this should be \"locale\": \"name\".\nSee here for a list of valid locales.",
            "Dict[str, str]",
            "The description localizations for this option. The values of this should be \"locale\": \"description\".\nSee here for a list of valid locales.",
            "Dict[str, str]",
            "Examples",
            "Basic usage:",
            "New in version 2.0.",
            "input_type (InputType) –",
            "description (str | None) –",
            "Represents a class that can be passed as the input_type for an Option class.",
            "New in version 2.0.",
            "thread_type (Literal[\"public\", \"private\", \"news\"]) – The thread type to expect for this options input.",
            "Represents a name:value pairing for a selected Option.",
            "New in version 2.0.",
            "The name of the choice. Shown in the UI when selecting an option.",
            "str",
            "The value of the choice. If not provided, will use the value of name.",
            "Optional[Union[str, int, float]]",
            "The name localizations for this choice. The values of this should be \"locale\": \"name\".\nSee here for a list of valid locales.",
            "Dict[str, str]",
            "name (str) –",
            "value (str | int | float | None) –",
            "name_localizations (dict[str, str]) –"
        ],
        "code": [
            "SlashCommandOptionType",
            "Converter",
            "enum.Enum",
            "enum.Enum",
            "choices",
            "enum.Enum",
            "autocomplete",
            "discord.utils.basic_autocomplete()",
            "str",
            "bool",
            "int",
            "float",
            "abc.GuildChannel",
            "Thread",
            "Member",
            "User",
            "Attachment",
            "Role",
            "abc.Mentionable",
            "SlashCommandOptionType",
            "ext.commands.Converter",
            "enums.Enum",
            "Enum",
            "str",
            "input_type",
            "enum.Enum",
            "description",
            "input_type",
            "str",
            "OptionChoice",
            "Any",
            "OptionChoice",
            "bool",
            "required",
            "False",
            "Any",
            "input_type",
            "int",
            "float",
            "int",
            "input_type",
            "int",
            "float",
            "int",
            "input_type",
            "str",
            "int",
            "input_type",
            "str",
            "int",
            "AutocompleteContext",
            "str",
            "OptionChoice",
            "discord.utils.basic_autocomplete()",
            "AutocompleteContext",
            "OptionChoice",
            "str",
            "int",
            "float",
            "input_type",
            "discord.SlashCommandOptionType.channel",
            "input_type",
            "discord.ChannelType",
            "\"locale\": \"name\"",
            "str",
            "str",
            "\"locale\": \"description\"",
            "str",
            "str",
            "@bot.slash_command(guild_ids=[...])\nasync def hello(\n    ctx: discord.ApplicationContext,\n    name: Option(str, \"Enter your name\"),\n    age: Option(int, \"Enter your age\", min_value=1, max_value=99, default=18)\n    # passing the default value makes an argument optional\n    # you also can create optional argument using:\n    # age: Option(int, \"Enter your age\") = 18\n):\n    await ctx.respond(f\"Hello! Your name is {name} and you are {age} years old.\")",
            "input_type",
            "Option",
            "Option",
            "str",
            "name",
            "str",
            "int",
            "float",
            "\"locale\": \"name\"",
            "str",
            "str"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/application_commands.html"
    },
    {
        "title": "Context Objects#",
        "content": [
            "Represents a Discord application command interaction context.",
            "This class is not created manually and is instead passed to application\ncommands as the first parameter.",
            "New in version 2.0.",
            "The bot that the command belongs to.",
            "Bot",
            "The interaction object that invoked the command.",
            "Interaction",
            "The command that this context belongs to.",
            "ApplicationCommand",
            "bot (Bot) –",
            "interaction (Interaction) –",
            "This function is a coroutine.",
            "Calls a command with the arguments given.\nThis is useful if you want to just call the callback that a\nApplicationCommand holds internally.",
            "Note",
            "This does not handle converters, checks, cooldowns, pre-invoke,\nor after-invoke hooks in any matter. It calls the internal callback\ndirectly as-if it was a regular function.\nYou must take care in passing the proper arguments when\nusing this function.",
            "command (ApplicationCommand) – The command that is going to be called.",
            "*args – The arguments to use.",
            "**kwargs – The keyword arguments to use.",
            "TypeError – The command argument to invoke is missing.",
            "Union[abc.GuildChannel, PartialMessageable, Thread]:\nReturns the channel associated with this context’s command. Shorthand for Interaction.channel.",
            "Returns the ID of the channel associated with this context’s command.\nShorthand for Interaction.channel_id.",
            "Returns the guild associated with this context’s command.\nShorthand for Interaction.guild.",
            "Returns the ID of the guild associated with this context’s command.\nShorthand for Interaction.guild_id.",
            "Returns the locale of the guild associated with this context’s command.\nShorthand for Interaction.locale.",
            "Returns the locale of the guild associated with this context’s command.\nShorthand for Interaction.guild_locale.",
            "Union[Member, ClientUser]:\nSimilar to Guild.me except it may return the ClientUser in private message\nmessage contexts, or when Intents.guilds() is absent.",
            "Returns the message sent with this context’s command.\nShorthand for Interaction.message, if applicable.",
            "Returns the user that sent this context’s command.\nShorthand for Interaction.user.",
            "Returns the user that sent this context’s command.\nShorthand for Interaction.user.",
            "Returns the voice client associated with this context’s command.\nShorthand for Interaction.guild.voice_client, if applicable.",
            "Returns the response object associated with this context’s command.\nShorthand for Interaction.response.",
            "The options and values that were selected by the user when sending the command.",
            "A dictionary containing the options and values that were selected by the user when the command\nwas processed, if applicable. Returns None if the command has not yet been invoked,\nor if there are no options defined for that command.",
            "Optional[List[Dict[str, Any]]]",
            "The options that were not provided by the user when sending the command.",
            "A list of Option objects (if any) that were not selected by the user when the command was processed.\nReturns None if there are no options defined for that command.",
            "Optional[List[Option]]",
            "This function is a coroutine.\nResponds to this interaction by sending a modal dialog.\nThis cannot be used to respond to another modal dialog submission.",
            "modal (discord.ui.Modal) – The modal dialog to display to the user.",
            "HTTPException – Sending the modal failed.",
            "InteractionResponded – This interaction has already been responded to before.",
            "This function is a coroutine.",
            "Sends either a response or a message using the followup webhook determined by whether the interaction\nhas been responded to or not.",
            "The response, its type depending on whether it’s an interaction response or a followup.",
            "Union[discord.Interaction, discord.WebhookMessage]",
            "This function is a coroutine.",
            "Responds to this interaction by sending a message.",
            "content (Optional[str]) – The content of the message to send.",
            "embeds (List[Embed]) – A list of embeds to send with the content. Maximum of 10. This cannot\nbe mixed with the embed parameter.",
            "embed (Embed) – The rich embed for the content to send. This cannot be mixed with\nembeds parameter.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "view (discord.ui.View) – The view to send with the message.",
            "ephemeral (bool) – Indicates if the message should only be visible to the user who started the interaction.\nIf a view is sent with an ephemeral message, and it has no timeout set then the timeout\nis set to 15 minutes.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message.\nSee abc.Messageable.send() for more information.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "The interaction object associated with the sent message.",
            "Interaction",
            "HTTPException – Sending the message failed.",
            "TypeError – You specified both embed and embeds.",
            "ValueError – The length of embeds was invalid.",
            "InteractionResponded – This interaction has already been responded to before.",
            "This function is a coroutine.",
            "Sends a message using the webhook.",
            "The content must be a type that can convert to a string through str(content).",
            "To upload a single file, the file parameter should be used with a\nsingle File object.",
            "If the embed parameter is provided, it must be of type Embed and\nit must be a rich embed type. You cannot mix the embed parameter with the\nembeds parameter, which must be a list of Embed objects to send.",
            "content (str) – The content of the message to send.",
            "wait (bool) – Whether the server should wait before sending a response. This essentially\nmeans that the return type of this function changes from None to\na WebhookMessage if set to True. If the type of webhook\nis WebhookType.application then this is always set to True.",
            "username (str) – The username to send with this message. If no username is provided\nthen the default username for the webhook is used.",
            "avatar_url (str) – The avatar URL to send with this message. If no avatar URL is provided\nthen the default avatar for the webhook is used. If this is not a\nstring then it is explicitly cast using str.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "ephemeral (bool) – Indicates if the message should only be visible to the user.\nThis is only available to WebhookType.application webhooks.\nIf a view is sent with an ephemeral message, and it has no timeout set\nthen the timeout is set to 15 minutes.\n\nNew in version 2.0.",
            "Indicates if the message should only be visible to the user.\nThis is only available to WebhookType.application webhooks.\nIf a view is sent with an ephemeral message, and it has no timeout set\nthen the timeout is set to 15 minutes.",
            "New in version 2.0.",
            "file (File) – The file to upload. This cannot be mixed with files parameter.",
            "files (List[File]) – A list of files to send with the content. This cannot be mixed with the\nfile parameter.",
            "embed (Embed) – The rich embed for the content to send. This cannot be mixed with\nembeds parameter.",
            "embeds (List[Embed]) – A list of embeds to send with the content. Maximum of 10. This cannot\nbe mixed with the embed parameter.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message.",
            "New in version 1.4.",
            "view (discord.ui.View) – The view to send with the message. You can only send a view\nif this webhook is not partial and has state attached. A\nwebhook has state attached if the webhook is managed by the\nlibrary.\n\nNew in version 2.0.",
            "The view to send with the message. You can only send a view\nif this webhook is not partial and has state attached. A\nwebhook has state attached if the webhook is managed by the\nlibrary.",
            "New in version 2.0.",
            "thread (Snowflake) – The thread to send this webhook to.\n\nNew in version 2.0.",
            "The thread to send this webhook to.",
            "New in version 2.0.",
            "thread_name (str) – The name of the thread to create. Only works for forum channels.\n\nNew in version 2.0.",
            "The name of the thread to create. Only works for forum channels.",
            "New in version 2.0.",
            "applied_tags (List[Snowflake]) – A list of tags to apply to the message. Only works for threads.\n\nNew in version 2.5.",
            "A list of tags to apply to the message. Only works for threads.",
            "New in version 2.5.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "If wait is True then the message that was sent, otherwise None.",
            "Optional[WebhookMessage]",
            "HTTPException – Sending the message failed.",
            "NotFound – This webhook was not found.",
            "Forbidden – The authorization token for the webhook is incorrect.",
            "TypeError – You specified both embed and embeds or file and files.",
            "ValueError – The length of embeds was invalid.",
            "InvalidArgument – Either there was no token associated with this webhook, ephemeral was passed\n    with the improper webhook type, there was no state attached with this webhook when\n    giving it a view, you specified both thread_name and thread, or applied_tags\n    was passed with neither thread_name nor thread specified.",
            "This function is a coroutine.",
            "Defers the interaction response.",
            "This is typically used when the interaction is acknowledged\nand a secondary action will be done later.",
            "This can only be used with the following interaction types:",
            "InteractionType.application_command",
            "InteractionType.component",
            "InteractionType.modal_submit",
            "Note",
            "The follow-up response will also be non-ephemeral if the ephemeral\nargument is False, and ephemeral if True.",
            "ephemeral (bool) – Indicates whether the deferred message will eventually be ephemeral.\nThis only applies to InteractionType.application_command interactions,\nor if invisible is False.",
            "invisible (bool) – Indicates whether the deferred type should be ‘invisible’\n(InteractionResponseType.deferred_message_update)\ninstead of ‘thinking’ (InteractionResponseType.deferred_channel_message).\nIn the Discord UI, this is represented as the bot thinking of a response. You must\neventually send a followup message via Interaction.followup to make this thinking state go away.\nThis parameter does not apply to interactions of type InteractionType.application_command.",
            "HTTPException – Deferring the interaction failed.",
            "InteractionResponded – This interaction has already been responded to before.",
            "Returns the followup webhook for followup interactions.",
            "This function is a coroutine.",
            "Deletes the original interaction response message.",
            "This is a higher level interface to Interaction.delete_original_response().",
            "delay (Optional[float]) – If provided, the number of seconds to wait before deleting the message.",
            "HTTPException – Deleting the message failed.",
            "Forbidden – You do not have proper permissions to delete the message.",
            "None",
            "This function is a coroutine.",
            "Edits the original interaction response message.",
            "This is a lower level interface to InteractionMessage.edit() in case\nyou do not want to fetch the message and save an HTTP request.",
            "This method is also the only way to edit the original message if\nthe message sent was ephemeral.",
            "content (Optional[str]) – The content to edit the message with or None to clear it.",
            "embeds (List[Embed]) – A list of embeds to edit the message with.",
            "embed (Optional[Embed]) – The embed to edit the message with. None suppresses the embeds.\nThis should not be mixed with the embeds parameter.",
            "file (File) – The file to upload. This cannot be mixed with files parameter.",
            "files (List[File]) – A list of files to send with the content. This cannot be mixed with the\nfile parameter.",
            "attachments (List[Attachment]) – A list of attachments to keep in the message. If [] is passed\nthen all attachments are removed.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message.\nSee abc.Messageable.send() for more information.",
            "view (Optional[View]) – The updated view to update this message with. If None is passed then\nthe view is removed.",
            "delete_after (Optional[float]) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just edited. If the deletion fails,\nthen it is silently ignored.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "The newly edited message.",
            "InteractionMessage",
            "HTTPException – Editing the message failed.",
            "Forbidden – Edited a message that is not yours.",
            "TypeError – You specified both embed and embeds or file and files",
            "ValueError – The length of embeds was invalid.",
            "Returns the cog associated with this context’s command.\nNone if it does not exist.",
            "Represents context for a slash command’s option autocomplete.",
            "This class is not created manually and is instead passed to an Option’s autocomplete callback.",
            "New in version 2.0.",
            "The bot that the command belongs to.",
            "Bot",
            "The interaction object that invoked the autocomplete.",
            "Interaction",
            "The command that this context belongs to.",
            "ApplicationCommand",
            "The option the user is currently typing.",
            "Option",
            "The content of the focused option.",
            "str",
            "A name to value mapping of the options that the user has selected before this option.",
            "Dict[str, Any]",
            "bot (Bot) –",
            "interaction (Interaction) –",
            "Returns the cog associated with this context’s command.\nNone if it does not exist."
        ],
        "code": [
            "Bot",
            "Interaction",
            "ApplicationCommand",
            "Bot",
            "Interaction",
            "ApplicationCommand",
            "ApplicationCommand",
            "abc.GuildChannel",
            "PartialMessageable",
            "Thread",
            "Interaction.channel",
            "Interaction.channel_id",
            "Interaction.guild",
            "Interaction.guild_id",
            "Interaction.locale",
            "Interaction.guild_locale",
            "Member",
            "ClientUser",
            "Guild.me",
            "ClientUser",
            "Intents.guilds()",
            "Interaction.message",
            "Interaction.user",
            "Interaction.user",
            "Interaction.guild.voice_client",
            "Interaction.response",
            "None",
            "str",
            "None",
            "Option",
            "discord.ui.Modal",
            "discord.Interaction",
            "discord.WebhookMessage",
            "str",
            "Embed",
            "embed",
            "Embed",
            "embeds",
            "bool",
            "discord.ui.View",
            "bool",
            "AllowedMentions",
            "abc.Messageable.send()",
            "float",
            "File",
            "File",
            "Poll",
            "Interaction",
            "embed",
            "embeds",
            "embeds",
            "str(content)",
            "file",
            "File",
            "embed",
            "Embed",
            "embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "None",
            "WebhookMessage",
            "True",
            "WebhookType.application",
            "True",
            "str",
            "str",
            "str",
            "bool",
            "bool",
            "WebhookType.application",
            "File",
            "files",
            "File",
            "file",
            "Embed",
            "embeds",
            "Embed",
            "embed",
            "AllowedMentions",
            "discord.ui.View",
            "Snowflake",
            "str",
            "Snowflake",
            "float",
            "Poll",
            "wait",
            "True",
            "None",
            "WebhookMessage",
            "embed",
            "embeds",
            "file",
            "files",
            "embeds",
            "ephemeral",
            "thread_name",
            "thread",
            "applied_tags",
            "thread_name",
            "thread",
            "InteractionType.application_command",
            "InteractionType.component",
            "InteractionType.modal_submit",
            "False",
            "True",
            "bool",
            "InteractionType.application_command",
            "invisible",
            "False",
            "bool",
            "InteractionResponseType.deferred_message_update",
            "InteractionResponseType.deferred_channel_message",
            "Interaction.followup",
            "InteractionType.application_command",
            "Interaction.delete_original_response()",
            "float",
            "InteractionMessage.edit()",
            "str",
            "None",
            "Embed",
            "Embed",
            "None",
            "embeds",
            "File",
            "files",
            "File",
            "file",
            "Attachment",
            "[]",
            "AllowedMentions",
            "abc.Messageable.send()",
            "View",
            "None",
            "float",
            "bool",
            "InteractionMessage",
            "embed",
            "embeds",
            "file",
            "files",
            "embeds",
            "None",
            "Option",
            "Bot",
            "Interaction",
            "ApplicationCommand",
            "Option",
            "str",
            "str",
            "Bot",
            "Interaction",
            "None",
            "default_permissions()",
            "guild_only()",
            "is_nsfw()",
            "application_command()",
            "command()",
            "slash_command()",
            "user_command()",
            "message_command()",
            "ApplicationCommand",
            "is_on_cooldown()",
            "reset_cooldown()",
            "get_cooldown_retry_after()",
            "error()",
            "has_error_handler()",
            "before_invoke()",
            "after_invoke()",
            "full_parent_name",
            "qualified_name",
            "qualified_id",
            "SlashCommand",
            "name",
            "callback",
            "description",
            "guild_ids",
            "options",
            "parent",
            "mention",
            "guild_only",
            "nsfw",
            "default_member_permissions",
            "cog",
            "checks",
            "cooldown",
            "name_localizations",
            "description_localizations",
            "integration_types",
            "contexts",
            "copy()",
            "SlashCommandGroup",
            "name",
            "description",
            "guild_ids",
            "parent",
            "guild_only",
            "nsfw",
            "default_member_permissions",
            "checks",
            "name_localizations",
            "description_localizations",
            "integration_types",
            "contexts",
            "create_subgroup()",
            "subgroup()",
            "walk_commands()",
            "copy()",
            "UserCommand",
            "name",
            "callback",
            "guild_ids",
            "guild_only",
            "nsfw",
            "default_member_permissions",
            "cog",
            "checks",
            "cooldown",
            "name_localizations",
            "integration_types",
            "contexts",
            "copy()",
            "MessageCommand",
            "name",
            "callback",
            "guild_ids",
            "guild_only",
            "nsfw",
            "default_member_permissions",
            "cog",
            "checks",
            "cooldown",
            "name_localizations",
            "integration_types",
            "contexts",
            "copy()",
            "option()",
            "parameter_name",
            "Option",
            "input_type",
            "name",
            "description",
            "choices",
            "required",
            "default",
            "min_value",
            "max_value",
            "min_length",
            "max_length",
            "autocomplete",
            "channel_types",
            "name_localizations",
            "description_localizations",
            "ThreadOption",
            "OptionChoice",
            "name",
            "value",
            "name_localizations",
            "ApplicationContext",
            "bot",
            "interaction",
            "command",
            "invoke()",
            "channel",
            "channel_id",
            "guild",
            "guild_id",
            "locale",
            "guild_locale",
            "me",
            "message",
            "user",
            "author",
            "voice_client",
            "response",
            "selected_options",
            "unselected_options",
            "send_modal",
            "respond",
            "send_response",
            "send_followup",
            "defer",
            "followup",
            "delete()",
            "edit",
            "cog",
            "AutocompleteContext",
            "bot",
            "interaction",
            "command",
            "focused",
            "value",
            "options",
            "cog"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/application_commands.html"
    },
    {
        "title": "Utility Functions#",
        "content": [
            "A helper to return the first element found in the sequence\nthat meets the predicate. For example:",
            "would find the first Member whose name is ‘Mighty’ and return it.\nIf an entry is not found, then None is returned.",
            "This is different from filter() due to the fact it stops the moment it finds\na valid entry.",
            "predicate (Callable[[T], Any]) – A function that returns a boolean-like result.",
            "seq (collections.abc.Iterable) – The iterable to search through.",
            "T | None",
            "A helper that returns the first element in the iterable that meets\nall the traits passed in attrs. This is an alternative for\nfind().",
            "When multiple attributes are specified, they are checked using\nlogical AND, not logical OR. Meaning they have to meet every\nattribute passed in and not one of them.",
            "To have a nested attribute search (i.e. search by x.y) then\npass in x__y as the keyword argument.",
            "If nothing is found that matches the attributes passed, then\nNone is returned.",
            "Examples",
            "Basic usage:",
            "Multiple attribute matching:",
            "Nested attribute matching:",
            "iterable (Iterable[T]) – An iterable to search through.",
            "**attrs (Any) – Keyword arguments that denote attributes to search with.",
            "T | None",
            "This function is a coroutine.",
            "Attempts to get an attribute from the object in cache. If it fails, it will attempt to fetch it.\nIf the fetch also fails, an error will be raised.",
            "obj (Any) – The object to use the get or fetch methods in",
            "attr (str) – The attribute to get or fetch. Note the object must have both a get_ and fetch_ method for this attribute.",
            "id (int) – The ID of the object",
            "default (Any) – The default value to return if the object is not found, instead of raising an error.",
            "The object found or the default value.",
            "Any",
            "AttributeError – The object is missing a get_ or fetch_ method",
            "NotFound – Invalid ID for the object",
            "HTTPException – An error occurred fetching the object",
            "Forbidden – You do not have permission to fetch the object",
            "Examples",
            "Getting a guild from a guild ID:",
            "Getting a channel from the guild. If the channel is not found, return None:",
            "A helper function that returns the OAuth2 URL for inviting the bot\ninto guilds.",
            "client_id (Union[int, str]) – The client ID for your bot.",
            "permissions (Permissions) – The permissions you’re requesting. If not given then you won’t be requesting any\npermissions.",
            "guild (Snowflake) – The guild to pre-select in the authorization screen, if available.",
            "redirect_uri (str) – An optional valid redirect URI.",
            "scopes (Iterable[str]) – An optional valid list of scopes. Defaults to ('bot',).\n\nNew in version 1.7.",
            "An optional valid list of scopes. Defaults to ('bot',).",
            "New in version 1.7.",
            "disable_guild_select (bool) – Whether to disallow the user from changing the guild dropdown.\n\nNew in version 2.0.",
            "Whether to disallow the user from changing the guild dropdown.",
            "New in version 2.0.",
            "The OAuth2 URL for inviting the bot into guilds.",
            "str",
            "A helper function that removes markdown characters.",
            "New in version 1.7.",
            "Note",
            "This function is not markdown aware and may remove meaning from the original text. For example,\nif the input contains 10 * 5 then it will be converted into 10  5.",
            "text (str) – The text to remove markdown from.",
            "ignore_links (bool) – Whether to leave links alone when removing markdown. For example,\nif a URL in the text contains characters such as _ then it will\nbe left alone. Defaults to True.",
            "The text with the markdown special characters removed.",
            "str",
            "A helper function that escapes Discord’s markdown.",
            "text (str) – The text to escape markdown from.",
            "as_needed (bool) – Whether to escape the markdown characters as needed. This\nmeans that it does not escape extraneous characters if it’s\nnot necessary, e.g. **hello** is escaped into \\*\\*hello**\ninstead of \\*\\*hello\\*\\*. Note however that this can open\nyou up to some clever syntax abuse. Defaults to False.",
            "ignore_links (bool) – Whether to leave links alone when escaping markdown. For example,\nif a URL in the text contains characters such as _ then it will\nbe left alone. This option is not supported with as_needed.\nDefaults to True.",
            "The text with the markdown special characters escaped with a slash.",
            "str",
            "A helper function that escapes everyone, here, role, and user mentions.",
            "Note",
            "This does not include channel mentions.",
            "Note",
            "For more granular control over what mentions should be escaped\nwithin messages, refer to the AllowedMentions\nclass.",
            "text (str) – The text to escape mentions from.",
            "The text with the mentions removed.",
            "str",
            "Returns a list of user IDs matching <@user_id> in the string.",
            "New in version 2.2.",
            "text (str) – The string to get user mentions from.",
            "A list of user IDs found in the string.",
            "List[int]",
            "Returns a list of channel IDs matching <@#channel_id> in the string.",
            "New in version 2.2.",
            "text (str) – The string to get channel mentions from.",
            "A list of channel IDs found in the string.",
            "List[int]",
            "Returns a list of role IDs matching <@&role_id> in the string.",
            "New in version 2.2.",
            "text (str) – The string to get role mentions from.",
            "A list of role IDs found in the string.",
            "List[int]",
            "Resolves an invite from a Invite, URL or code.",
            "invite (Union[Invite, str]) – The invite.",
            "The invite code.",
            "str",
            "Resolves a template code from a Template, URL or code.",
            "New in version 1.4.",
            "code (Union[Template, str]) – The code.",
            "The template code.",
            "str",
            "This function is a coroutine.",
            "Sleep until a specified time.",
            "If the time supplied is in the past this function will yield instantly.",
            "New in version 1.3.",
            "when (datetime.datetime) – The timestamp in which to sleep until. If the datetime is naive then\nit is assumed to be local time.",
            "result (Any) – If provided is returned to the caller when the coroutine completes.",
            "T | None",
            "A helper function to return an aware UTC datetime representing the current time.",
            "This should be preferred to datetime.datetime.utcnow() since it is an aware\ndatetime, compared to the naive datetime in the standard library.",
            "New in version 2.0.",
            "The current aware datetime in UTC.",
            "datetime.datetime",
            "Converts a Discord snowflake ID to a UTC-aware datetime object.",
            "id (int) – The snowflake ID.",
            "An aware datetime in UTC representing the creation time of the snowflake.",
            "datetime.datetime",
            "A helper function to convert an ISO 8601 timestamp to a datetime object.",
            "timestamp (Optional[str]) – The timestamp to convert.",
            "The converted datetime object.",
            "Optional[datetime.datetime]",
            "A helper function to format a datetime.datetime for presentation within Discord.",
            "This allows for a locale-independent way of presenting data using Discord specific Markdown.",
            "Style",
            "Example Output",
            "Description",
            "t",
            "22:57",
            "Short Time",
            "T",
            "22:57:58",
            "Long Time",
            "d",
            "17/05/2016",
            "Short Date",
            "D",
            "17 May 2016",
            "Long Date",
            "f (default)",
            "17 May 2016 22:57",
            "Short Date Time",
            "F",
            "Tuesday, 17 May 2016 22:57",
            "Long Date Time",
            "R",
            "5 years ago",
            "Relative Time",
            "Note that the exact output depends on the user’s locale setting in the client. The example output\npresented is using the en-GB locale.",
            "New in version 2.0.",
            "dt (datetime.datetime) – The datetime to format.",
            "style (str) – The style to format the datetime with.",
            "The formatted string.",
            "str",
            "Returns a numeric snowflake pretending to be created at the given date.",
            "When using as the lower end of a range, use time_snowflake(high=False) - 1\nto be inclusive, high=True to be exclusive.",
            "When using as the higher end of a range, use time_snowflake(high=True) + 1\nto be inclusive, high=False to be exclusive",
            "dt (datetime.datetime) – A datetime object to convert to a snowflake.\nIf naive, the timezone is assumed to be local time.",
            "high (bool) – Whether to set the lower 22 bit to high or low.",
            "The snowflake representing the time given.",
            "int",
            "Returns a numeric snowflake pretending to be created at the given date but more accurate and random\nthan time_snowflake(). If dt is not passed, it makes one from the current time using utcnow.",
            "dt (datetime.datetime) – A datetime object to convert to a snowflake.\nIf naive, the timezone is assumed to be local time.",
            "The snowflake representing the time given.",
            "int",
            "A helper function to make a basic autocomplete for slash commands. This is a pretty standard autocomplete and\nwill return any options that start with the value from the user, case-insensitive. If the values parameter is\ncallable, it will be called with the AutocompleteContext.",
            "This is meant to be passed into the discord.Option.autocomplete attribute.",
            "values (Union[Union[Iterable[OptionChoice], Iterable[str], Iterable[int], Iterable[float]], Callable[[AutocompleteContext], Union[Union[Iterable[str], Iterable[int], Iterable[float]], Awaitable[Union[Iterable[str], Iterable[int], Iterable[float]]]]], Awaitable[Union[Iterable[str], Iterable[int], Iterable[float]]]]) – Possible values for the option. Accepts an iterable of str, a callable (sync or async) that takes a\nsingle argument of AutocompleteContext, or a coroutine. Must resolve to an iterable of str.",
            "A wrapped callback for the autocomplete.",
            "Callable[[AutocompleteContext], Awaitable[Union[Iterable[OptionChoice], Iterable[str], Iterable[int], Iterable[float]]]]",
            "Note",
            "Autocomplete cannot be used for options that have specified choices.",
            "Example",
            "New in version 2.0.",
            "A helper function that collects an iterator into chunks of a given size.",
            "New in version 2.0.",
            "Warning",
            "The last chunk collected may not be as large as max_size.",
            "iterator (Union[collections.abc.Iterator, collections.abc.AsyncIterator]) – The iterator to chunk, can be sync or async.",
            "max_size (int) – The maximum chunk size.",
            "A new iterator which yields chunks of a given size.",
            "Union[collections.abc.Iterator, collections.abc.AsyncIterator]",
            "A helper function to filter out and replace certain keyword parameters",
            "params (Dict[str, Any]) – The initial parameters to filter.",
            "**kwargs (Dict[str, Optional[str]]) – Key to value pairs where the key’s contents would be moved to the\nvalue, or if the value is None, remove key’s contents (see code example).",
            "Example",
            "Warn about a deprecated function, with the ability to specify details about the deprecation. Emits a\nDeprecationWarning.",
            "name (str) – The name of the deprecated function.",
            "instead (Optional[str]) – A recommended alternative to the function.",
            "since (Optional[str]) – The version in which the function was deprecated. This should be in the format major.minor(.patch), where\nthe patch version is optional.",
            "removed (Optional[str]) – The version in which the function is planned to be removed. This should be in the format\nmajor.minor(.patch), where the patch version is optional.",
            "reference (Optional[str]) – A reference that explains the deprecation, typically a URL to a page such as a changelog entry or a GitHub\nissue/PR.",
            "stacklevel (int) – The stacklevel kwarg passed to warnings.warn(). Defaults to 3.",
            "None",
            "A decorator implementation of warn_deprecated(). This will automatically call warn_deprecated() when\nthe decorated function is called.",
            "instead (Optional[str]) – A recommended alternative to the function.",
            "since (Optional[str]) – The version in which the function was deprecated. This should be in the format major.minor(.patch), where\nthe patch version is optional.",
            "removed (Optional[str]) – The version in which the function is planned to be removed. This should be in the format\nmajor.minor(.patch), where the patch version is optional.",
            "reference (Optional[str]) – A reference that explains the deprecation, typically a URL to a page such as a changelog entry or a GitHub\nissue/PR.",
            "stacklevel (int) – The stacklevel kwarg passed to warnings.warn(). Defaults to 3.",
            "use_qualname (bool) – Whether to use the qualified name of the function in the deprecation warning. If False, the short name of\nthe function will be used instead. For example, __qualname__ will display as Client.login while __name__\nwill display as login. Defaults to True.",
            "Callable[[Callable[[P], T]], Callable[[P], T]]"
        ],
        "code": [
            "member = discord.utils.find(lambda m: m.name == 'Mighty', channel.guild.members)",
            "Member",
            "None",
            "filter()",
            "collections.abc.Iterable",
            "attrs",
            "find()",
            "x.y",
            "x__y",
            "None",
            "member = discord.utils.get(message.guild.members, name='Foo')",
            "channel = discord.utils.get(guild.voice_channels, name='Foo', bitrate=64000)",
            "channel = discord.utils.get(client.get_all_channels(), guild__name='Cool', name='general')",
            "str",
            "get_",
            "fetch_",
            "int",
            "get_",
            "fetch_",
            "guild = await utils.get_or_fetch(client, 'guild', guild_id)",
            "channel = await utils.get_or_fetch(guild, 'channel', channel_id, default=None)",
            "int",
            "str",
            "Permissions",
            "Snowflake",
            "str",
            "str",
            "('bot',)",
            "bool",
            "str",
            "10 * 5",
            "10  5",
            "str",
            "bool",
            "_",
            "True",
            "str",
            "str",
            "bool",
            "**hello**",
            "\\*\\*hello**",
            "\\*\\*hello\\*\\*",
            "False",
            "bool",
            "_",
            "as_needed",
            "True",
            "str",
            "AllowedMentions",
            "str",
            "str",
            "<@user_id>",
            "str",
            "int",
            "<@#channel_id>",
            "str",
            "int",
            "<@&role_id>",
            "str",
            "int",
            "Invite",
            "Invite",
            "str",
            "str",
            "Template",
            "Template",
            "str",
            "str",
            "datetime.datetime",
            "datetime.datetime.utcnow()",
            "datetime.datetime",
            "int",
            "datetime.datetime",
            "str",
            "datetime.datetime",
            "datetime.datetime",
            "en-GB",
            "datetime.datetime",
            "str",
            "str",
            "time_snowflake(high=False) - 1",
            "high=True",
            "time_snowflake(high=True) + 1",
            "high=False",
            "datetime.datetime",
            "bool",
            "int",
            "time_snowflake()",
            "datetime.datetime",
            "int",
            "values",
            "discord.Option.autocomplete",
            "OptionChoice",
            "str",
            "int",
            "float",
            "AutocompleteContext",
            "str",
            "int",
            "float",
            "str",
            "int",
            "float",
            "str",
            "int",
            "float",
            "str",
            "AutocompleteContext",
            "str",
            "AutocompleteContext",
            "OptionChoice",
            "str",
            "int",
            "float",
            "Option(str, \"color\", autocomplete=basic_autocomplete((\"red\", \"green\", \"blue\")))\n\n# or\n\nasync def autocomplete(ctx):\n    return \"foo\", \"bar\", \"baz\", ctx.interaction.user.name\n\nOption(str, \"name\", autocomplete=basic_autocomplete(autocomplete))",
            "max_size",
            "collections.abc.Iterator",
            "collections.abc.AsyncIterator",
            "int",
            "collections.abc.Iterator",
            "collections.abc.AsyncIterator",
            ">>> params = {\"param1\": 12, \"param2\": 13}\n>>> filter_params(params, param1=\"param3\", param2=None)\n{'param3': 12}\n# values of 'param1' is moved to 'param3'\n# and values of 'param2' are completely removed.",
            "str",
            "str",
            "major.minor(.patch)",
            "str",
            "major.minor(.patch)",
            "str",
            "int",
            "warnings.warn()",
            "warn_deprecated()",
            "warn_deprecated()",
            "str",
            "str",
            "major.minor(.patch)",
            "str",
            "major.minor(.patch)",
            "str",
            "int",
            "warnings.warn()",
            "bool",
            "False",
            "Client.login",
            "login",
            "True",
            "find()",
            "get()",
            "get_or_fetch()",
            "oauth_url()",
            "remove_markdown()",
            "escape_markdown()",
            "escape_mentions()",
            "raw_mentions()",
            "raw_channel_mentions()",
            "raw_role_mentions()",
            "resolve_invite()",
            "resolve_template()",
            "sleep_until()",
            "utcnow()",
            "snowflake_time()",
            "parse_time()",
            "format_dt()",
            "time_snowflake()",
            "generate_snowflake()",
            "basic_autocomplete()",
            "as_chunks()",
            "filter_params()",
            "warn_deprecated()",
            "deprecated()"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/utils.html"
    },
    {
        "title": "A Primer to Gateway Intents#",
        "content": [
            "In version 1.5 comes the introduction of Intents. This is a radical change in how bots are written. An intent basically allows a bot to subscribe to specific buckets of events. The events that correspond to each intent is documented in the individual attribute of the Intents documentation.",
            "These intents are passed to the constructor of Client or its subclasses (AutoShardedClient, AutoShardedBot, Bot) with the intents argument.",
            "If intents are not passed, then the library defaults to every intent being enabled except the privileged intents, currently Intents.members, Intents.presences, and Intents.message_content."
        ],
        "code": [
            "Intents",
            "Intents",
            "Client",
            "AutoShardedClient",
            "AutoShardedBot",
            "Bot",
            "intents",
            "Intents.members",
            "Intents.presences",
            "Intents.message_content"
        ],
        "url": "https://docs.pycord.dev/en/stable/intents.html"
    },
    {
        "title": "What intents are needed?#",
        "content": [
            "The intents that are necessary for your bot can only be dictated by yourself. Each attribute in the Intents class documents what events it corresponds to and what kind of cache it enables.",
            "For example, if you want a bot that functions without spammy events like presences or typing then we could do the following:",
            "Note that this doesn’t enable Intents.members or Intents.message_content since they are privileged intents.",
            "Another example showing a bot that only deals with messages and guild information:"
        ],
        "code": [
            "Intents",
            "import discord\n intents = discord.Intents.default()\n intents.typing = False\n intents.presences = False\n\n # Somewhere else:\n # client = discord.Client(intents=intents)\n # or\n # from discord.ext import commands\n # bot = commands.Bot(command_prefix='!', intents=intents)",
            "Intents.members",
            "Intents.message_content",
            "import discord\n intents = discord.Intents(messages=True, guilds=True)\n # If you also want reaction events enable the following:\n # intents.reactions = True\n\n # Somewhere else:\n # client = discord.Client(intents=intents)\n # or\n # from discord.ext import commands\n # bot = commands.Bot(command_prefix='!', intents=intents)"
        ],
        "url": "https://docs.pycord.dev/en/stable/intents.html"
    },
    {
        "title": "Privileged Intents#",
        "content": [
            "With the API change requiring bot owners to specify intents, some intents were restricted further and require more manual steps. These intents are called privileged intents.",
            "A privileged intent is one that requires you to go to the developer portal and manually enable it. To enable privileged intents do the following:",
            "Make sure you’re logged on to the Discord website.",
            "Navigate to the application page.",
            "Click on the bot you want to enable privileged intents for.",
            "Navigate to the bot tab on the left side of the screen.",
            "Scroll down to the “Privileged Gateway Intents” section and enable the ones you want.",
            "Warning",
            "Enabling privileged intents when your bot is in over 100 guilds requires going through bot verification.",
            "Note",
            "Even if you enable intents through the developer portal, you still have to enable the intents\nthrough code as well."
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/intents.html"
    },
    {
        "title": "Do I need privileged intents?#",
        "content": [
            "This is a quick checklist to see if you need specific privileged intents.",
            "Whether you use Member.status at all to track member statuses.",
            "Whether you use Member.activity or Member.activities to check member’s activities.",
            "Whether you track member joins or member leaves, corresponds to on_member_join() and on_member_remove() events.",
            "Whether you want to track member updates such as nickname or role changes.",
            "Whether you want to track user updates such as usernames, avatars, discriminators, etc.",
            "Whether you want to request the guild member list through Guild.chunk() or Guild.fetch_members().",
            "Whether you want high accuracy member cache under Guild.members.",
            "Whether you have a message based command system using ext.commands",
            "Whether you use the on_message() event for anything using message content, such as auto-moderation.",
            "Whether you use message content in on_message_edit(), on_message_delete(), on_raw_message_edit(), on_raw_message_delete().",
            "Note",
            "The bot can still receive message contents in DMs, when mentioned in guild messages, and for its own guild messages."
        ],
        "code": [
            "Member.status",
            "Member.activity",
            "Member.activities",
            "on_member_join()",
            "on_member_remove()",
            "Guild.chunk()",
            "Guild.fetch_members()",
            "Guild.members",
            "on_message()",
            "on_message_edit()",
            "on_message_delete()",
            "on_raw_message_edit()",
            "on_raw_message_delete()"
        ],
        "url": "https://docs.pycord.dev/en/stable/intents.html"
    },
    {
        "title": "Member Cache#",
        "content": [
            "Along with intents, Discord now further restricts the ability to cache members and expects bot authors to cache as little as is necessary. However, to properly maintain a cache the Intents.members intent is required in order to track the members who left and properly evict them.",
            "To aid with member cache where we don’t need members to be cached, the library now has a MemberCacheFlags flag to control the member cache. The documentation page for the class goes over the specific policies that are possible.",
            "It should be noted that certain things do not need a member cache since Discord will provide full member information if possible. For example:",
            "on_message() will have Message.author be a member even if cache is disabled.",
            "on_voice_state_update() will have the member parameter be a member even if cache is disabled.",
            "on_reaction_add() will have the user parameter be a member when in a guild even if cache is disabled.",
            "on_raw_reaction_add() will have RawReactionActionEvent.member be a member when in a guild even if cache is disabled.",
            "The reaction add events do not contain additional information when in direct messages. This is a Discord limitation.",
            "The reaction removal events do not have member information. This is a Discord limitation.",
            "Other events that take a Member will require the use of the member cache. If absolute accuracy over the member cache is desirable, then it is advisable to have the Intents.members intent enabled."
        ],
        "code": [
            "Intents.members",
            "MemberCacheFlags",
            "on_message()",
            "Message.author",
            "on_voice_state_update()",
            "member",
            "on_reaction_add()",
            "user",
            "on_raw_reaction_add()",
            "RawReactionActionEvent.member",
            "Member",
            "Intents.members"
        ],
        "url": "https://docs.pycord.dev/en/stable/intents.html"
    },
    {
        "title": "Retrieving Members#",
        "content": [
            "If the cache is disabled or you disable chunking guilds at startup, we might still need a way to load members. The library offers a few ways to do this:",
            "Used to query members by a prefix matching nickname or username.",
            "This can also be used to query members by their user ID.",
            "This uses the gateway and not the HTTP.",
            "This can be used to fetch the entire member list through the gateway.",
            "Used to fetch a member by ID through the HTTP API.",
            "used to fetch a large number of members through the HTTP API.",
            "It should be noted that the gateway has a strict rate limit of 120 requests per 60 seconds."
        ],
        "code": [
            "Guild.query_members()",
            "Guild.chunk()",
            "Guild.fetch_member()",
            "Guild.fetch_members()"
        ],
        "url": "https://docs.pycord.dev/en/stable/intents.html"
    },
    {
        "title": "Troubleshooting#",
        "content": [
            "Some common issues relating to the mandatory intent change."
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/intents.html"
    },
    {
        "title": "Where’d my members go?#",
        "content": [
            "Due to an API change Discord is now forcing developers who want member caching to explicitly opt-in to it. This is a Discord mandated change and there is no way to bypass it. In order to get members back you have to explicitly enable the members privileged intent and change the Intents.members attribute to true.",
            "For example:"
        ],
        "code": [
            "Intents.members",
            "import discord\n intents = discord.Intents.default()\n intents.members = True\n\n # Somewhere else:\n # client = discord.Client(intents=intents)\n # or\n # from discord.ext import commands\n # bot = commands.Bot(command_prefix='!', intents=intents)"
        ],
        "url": "https://docs.pycord.dev/en/stable/intents.html"
    },
    {
        "title": "Why does on_ready take so long to fire?#",
        "content": [
            "As part of the API change regarding intents, Discord also changed how members are loaded in the beginning. Originally the library could request 75 guilds at once and only request members from guilds that have the Guild.large attribute set to True. With the new intent changes, Discord mandates that we can only send 1 guild per request. This causes a 75x slowdown which is further compounded by the fact that all guilds, not just large guilds are being requested.",
            "There are a few solutions to fix this.",
            "The first solution is to request the privileged presences intent along with the privileged members intent and enable both of them. This allows the initial member list to contain online members just like the old gateway. Note that we’re still limited to 1 guild per request but the number of guilds we request is significantly reduced.",
            "The second solution is to disable member chunking by setting chunk_guilds_at_startup to False when constructing a client. Then, when chunking for a guild is necessary you can use the various techniques to retrieve members.",
            "To illustrate the slowdown caused by the API change, take a bot who is in 840 guilds and 95 of these guilds are “large” (over 250 members).",
            "Under the original system this would result in 2 requests to fetch the member list (75 guilds, 20 guilds) roughly taking 60 seconds. With Intents.members but not Intents.presences this requires 840 requests, with a rate limit of 120 requests per 60 seconds means that due to waiting for the rate limit it totals to around 7 minutes of waiting for the rate limit to fetch all the members. With both Intents.members and Intents.presences we mostly get the old behaviour so we’re only required to request for the 95 guilds that are large, this is slightly less than our rate limit so it’s close to the original timing to fetch the member list.",
            "Unfortunately due to this change being required from Discord there is nothing that the library can do to mitigate this.",
            "If you truly dislike the direction Discord is going with their API, you can contact them via support."
        ],
        "code": [
            "on_ready",
            "Guild.large",
            "True",
            "chunk_guilds_at_startup",
            "False",
            "Intents.members",
            "Intents.presences",
            "Intents.members",
            "Intents.presences",
            "on_ready"
        ],
        "url": "https://docs.pycord.dev/en/stable/intents.html"
    },
    {
        "title": "Exceptions#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/api/exceptions.html"
    },
    {
        "title": "Exception Hierarchy#",
        "content": [
            "InvalidData",
            "InvalidArgument",
            "LoginFailure",
            "ConnectionClosed",
            "PrivilegedIntentsRequired",
            "InteractionResponded",
            "NoMoreItems",
            "GatewayNotFound",
            "Forbidden",
            "NotFound",
            "DiscordServerError",
            "CheckFailure",
            "ApplicationCommandInvokeError",
            "ExtensionAlreadyLoaded",
            "ExtensionNotLoaded",
            "NoEntryPointError",
            "ExtensionFailed",
            "ExtensionNotFound",
            "sinks.RecordingException",
            "sinks.WaveSinkError",
            "sinks.MP3SinkError",
            "sinks.MP4SinkError",
            "sinks.M4ASinkError",
            "sinks.MKVSinkError",
            "sinks.MKASinkError",
            "sinks.OGGSinkError"
        ],
        "code": [
            "Exception",
            "DiscordException",
            "ClientException",
            "InvalidData",
            "InvalidArgument",
            "LoginFailure",
            "ConnectionClosed",
            "PrivilegedIntentsRequired",
            "InteractionResponded",
            "NoMoreItems",
            "GatewayNotFound",
            "HTTPException",
            "Forbidden",
            "NotFound",
            "DiscordServerError",
            "ApplicationCommandError",
            "CheckFailure",
            "ApplicationCommandInvokeError",
            "ExtensionError",
            "ExtensionAlreadyLoaded",
            "ExtensionNotLoaded",
            "NoEntryPointError",
            "ExtensionFailed",
            "ExtensionNotFound",
            "sinks.SinkException",
            "sinks.RecordingException",
            "sinks.WaveSinkError",
            "sinks.MP3SinkError",
            "sinks.MP4SinkError",
            "sinks.M4ASinkError",
            "sinks.MKVSinkError",
            "sinks.MKASinkError",
            "sinks.OGGSinkError"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/exceptions.html"
    },
    {
        "title": "Objects#",
        "content": [
            "The following exceptions are thrown by the library.",
            "Base exception class for pycord",
            "Ideally speaking, this could be caught to handle any exceptions raised from this library.",
            "Exception that’s raised when an operation in the Client fails.",
            "These are usually for exceptions that happened due to user input.",
            "Exception that’s raised when the Client.login() function\nfails to log you in from improper credentials or some other misc.\nfailure.",
            "Exception that is raised when an async iteration operation has no more items.",
            "Exception that’s raised when an HTTP request operation fails.",
            "The response of the failed HTTP request. This is an\ninstance of aiohttp.ClientResponse. In some cases\nthis could also be a requests.Response.",
            "aiohttp.ClientResponse",
            "The text of the error. Could be an empty string.",
            "str",
            "The status code of the HTTP request.",
            "int",
            "The Discord specific error code for the failure.",
            "int",
            "Exception that’s raised for when status code 403 occurs.",
            "Subclass of HTTPException",
            "Exception that’s raised for when status code 404 occurs.",
            "Subclass of HTTPException",
            "Exception that’s raised for when a 500 range status code occurs.",
            "Subclass of HTTPException.",
            "New in version 1.5.",
            "Exception that’s raised when the library encounters unknown\nor invalid data from Discord.",
            "Exception that’s raised when an argument to a function\nis invalid some way (e.g. wrong value or wrong type).",
            "This could be considered the parallel of ValueError and\nTypeError except inherited from ClientException and thus\nDiscordException.",
            "An exception that is raised when the gateway for Discord could not be found",
            "Exception that’s raised when the gateway connection is\nclosed for reasons that could not be handled internally.",
            "The close code of the websocket.",
            "int",
            "The reason provided for the closure.",
            "str",
            "The shard ID that got closed if applicable.",
            "Optional[int]",
            "socket (ClientWebSocketResponse) –",
            "shard_id (int | None) –",
            "code (int | None) –",
            "Exception that’s raised when the gateway is requesting privileged intents, but\nthey’re not ticked in the developer page yet.",
            "Go to https://discord.com/developers/applications/ and enable the intents\nthat are required. Currently, these are as follows:",
            "Intents.members",
            "Intents.presences",
            "Intents.message_content",
            "The shard ID that got closed if applicable.",
            "Optional[int]",
            "shard_id (int | None) –",
            "Exception that’s raised when sending another interaction response using\nInteractionResponse when one has already been done before.",
            "An interaction can only respond once.",
            "New in version 2.0.",
            "The interaction that’s already been responded to.",
            "Interaction",
            "interaction (Interaction) –",
            "An exception that is thrown for libopus related errors.",
            "The error code returned.",
            "int",
            "code (int) –",
            "An exception that is thrown for when libopus is not loaded.",
            "The base exception type for all application command related errors.",
            "This inherits from DiscordException.",
            "This exception and exceptions inherited from it are handled\nin a special way as they are caught and passed into a special event\nfrom Bot, on_command_error().",
            "Exception raised when the predicates in Command.checks have failed.",
            "This inherits from ApplicationCommandError",
            "Exception raised when the command being invoked raised an exception.",
            "This inherits from ApplicationCommandError",
            "The original exception that was raised. You can also get this via\nthe __cause__ attribute.",
            "Exception",
            "e (Exception) –",
            "Base exception for extension related errors.",
            "This inherits from DiscordException.",
            "The extension that had an error.",
            "str",
            "message (str | None) –",
            "args (Any) –",
            "name (str) –",
            "An exception raised when an extension has already been loaded.",
            "This inherits from ExtensionError",
            "name (str) –",
            "An exception raised when an extension was not loaded.",
            "This inherits from ExtensionError",
            "name (str) –",
            "An exception raised when an extension does not have a setup entry point function.",
            "This inherits from ExtensionError",
            "name (str) –",
            "An exception raised when an extension failed to load during execution of the module or setup entry point.",
            "This inherits from ExtensionError",
            "The extension that had the error.",
            "str",
            "The original exception that was raised. You can also get this via\nthe __cause__ attribute.",
            "Exception",
            "name (str) –",
            "original (Exception) –",
            "An exception raised when an extension is not found.",
            "This inherits from ExtensionError",
            "Changed in version 1.3: Made the original attribute always None.",
            "The extension that had the error.",
            "str",
            "name (str) –",
            "Raised when a Sink error occurs.",
            "New in version 2.0.",
            "Exception that’s thrown when there is an error while trying to record\naudio from a voice channel.",
            "New in version 2.0.",
            "Exception thrown when an exception occurs with WaveSink",
            "New in version 2.0.",
            "Exception thrown when an exception occurs with MP3Sink",
            "New in version 2.0.",
            "Exception thrown when an exception occurs with MP4Sink",
            "New in version 2.0.",
            "Exception thrown when an exception occurs with M4ASink",
            "New in version 2.0.",
            "Exception thrown when an exception occurs with MKVSink",
            "New in version 2.0.",
            "Exception thrown when an exception occurs with MKASink",
            "New in version 2.0.",
            "Exception thrown when an exception occurs with OGGSink",
            "New in version 2.0."
        ],
        "code": [
            "Client",
            "Client.login()",
            "aiohttp.ClientResponse",
            "requests.Response",
            "aiohttp.ClientResponse",
            "str",
            "int",
            "int",
            "HTTPException",
            "HTTPException",
            "HTTPException",
            "ValueError",
            "TypeError",
            "ClientException",
            "DiscordException",
            "int",
            "str",
            "int",
            "Intents.members",
            "Intents.presences",
            "Intents.message_content",
            "int",
            "InteractionResponse",
            "Interaction",
            "Interaction",
            "int",
            "int",
            "DiscordException",
            "Bot",
            "on_command_error()",
            "Command.checks",
            "ApplicationCommandError",
            "ApplicationCommandError",
            "__cause__",
            "Exception",
            "Exception",
            "DiscordException",
            "str",
            "ExtensionError",
            "str",
            "ExtensionError",
            "str",
            "setup",
            "ExtensionError",
            "str",
            "setup",
            "ExtensionError",
            "str",
            "__cause__",
            "Exception",
            "str",
            "Exception",
            "ExtensionError",
            "original",
            "str",
            "str",
            "WaveSink",
            "MP3Sink",
            "MP4Sink",
            "M4ASink",
            "MKVSink",
            "MKASink",
            "OGGSink",
            "DiscordException",
            "ClientException",
            "LoginFailure",
            "NoMoreItems",
            "HTTPException",
            "response",
            "text",
            "status",
            "code",
            "Forbidden",
            "NotFound",
            "DiscordServerError",
            "InvalidData",
            "InvalidArgument",
            "GatewayNotFound",
            "ConnectionClosed",
            "code",
            "reason",
            "shard_id",
            "PrivilegedIntentsRequired",
            "shard_id",
            "InteractionResponded",
            "interaction",
            "OpusError",
            "code",
            "OpusNotLoaded",
            "ApplicationCommandError",
            "CheckFailure",
            "ApplicationCommandInvokeError",
            "original",
            "ExtensionError",
            "name",
            "ExtensionAlreadyLoaded",
            "ExtensionNotLoaded",
            "NoEntryPointError",
            "ExtensionFailed",
            "name",
            "original",
            "ExtensionNotFound",
            "name",
            "SinkException",
            "RecordingException",
            "WaveSinkError",
            "MP3SinkError",
            "MP4SinkError",
            "M4ASinkError",
            "MKVSinkError",
            "MKASinkError",
            "OGGSinkError"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/exceptions.html"
    },
    {
        "title": "Commands#",
        "content": [
            "One of the most appealing aspects of the command extension is how easy it is to define commands and\nhow you can arbitrarily nest groups and commands to have a rich sub-command system.",
            "Note",
            "Using prefixed commands in guilds requires Intents.message_content to be enabled.",
            "Commands are defined by attaching it to a regular Python function. The command is then invoked by the user using a similar\nsignature to the Python function.",
            "For example, in the given command definition:",
            "With the following prefix ($), it would be invoked by the user via:",
            "A command must always have at least one parameter, ctx, which is the Context as the first one.",
            "There are two ways of registering a command. The first one is by using Bot.command() decorator,\nas seen in the example above. The second is using the command() decorator followed by\nBot.add_command() on the instance.",
            "Essentially, these two are equivalent:",
            "Since the Bot.command() decorator is shorter and easier to comprehend, it will be the one used throughout the\ndocumentation here.",
            "Any parameter that is accepted by the Command constructor can be passed into the decorator. For example, to change\nthe name to something other than the function would be as simple as doing this:"
        ],
        "code": [
            "Intents.message_content",
            "@bot.command()\nasync def foo(ctx, arg):\n    await ctx.send(arg)",
            "$",
            "$foo abc",
            "ctx",
            "Context",
            "Bot.command()",
            "command()",
            "Bot.add_command()",
            "from discord.ext import commands\n\nbot = commands.Bot(command_prefix='$')\n\n@bot.command()\nasync def test(ctx):\n    pass\n\n# or:\n\n@commands.command()\nasync def test(ctx):\n    pass\n\nbot.add_command(test)",
            "Bot.command()",
            "Command",
            "@bot.command(name='list')\nasync def _list(ctx, arg):\n    pass"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Parameters#",
        "content": [
            "Since we define commands by making Python functions, we also define the argument passing behaviour by the function\nparameters.",
            "Certain parameter types do different things in the user side and most forms of parameter types are supported."
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Positional#",
        "content": [
            "The most basic form of parameter passing is the positional parameter. This is where we pass a parameter as-is:",
            "On the bot using side, you can provide positional arguments by just passing a regular string:",
            "To make use of a word with spaces in between, you should quote it:",
            "As a note of warning, if you omit the quotes, you will only get the first word:",
            "Since positional arguments are just regular Python arguments, you can have as many as you want:"
        ],
        "code": [
            "@bot.command()\nasync def test(ctx, arg):\n    await ctx.send(arg)",
            "@bot.command()\nasync def test(ctx, arg1, arg2):\n    await ctx.send(f'You passed {arg1} and {arg2}')"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Variable#",
        "content": [
            "Sometimes you want users to pass in an undetermined number of parameters. The library supports this\nsimilar to how variable list parameters are done in Python:",
            "This allows our user to accept either one or many arguments as they please. This works similar to positional arguments,\nso multi-word parameters should be quoted.",
            "For example, on the bot side:",
            "If the user wants to input a multi-word argument, they have to quote it like earlier:",
            "Do note that similar to the Python function behaviour, a user can technically pass no arguments\nat all:",
            "Since the args variable is a tuple,\nyou can do anything you would usually do with one."
        ],
        "code": [
            "@bot.command()\nasync def test(ctx, *args):\n    arguments = ', '.join(args)\n    await ctx.send(f'{len(args)} arguments: {arguments}')",
            "args",
            "tuple"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Keyword-Only Arguments#",
        "content": [
            "When you want to handle parsing of the argument yourself or do not feel like you want to wrap multi-word user input into\nquotes, you can ask the library to give you the rest as a single argument. We do this by using a keyword-only argument,\nseen below:",
            "Warning",
            "You can only have one keyword-only argument due to parsing ambiguities.",
            "On the bot side, we do not need to quote input with spaces:",
            "Do keep in mind that wrapping it in quotes leaves it as-is:",
            "By default, the keyword-only arguments are stripped of white space to make it easier to work with. This behaviour can be\ntoggled by the Command.rest_is_raw argument in the decorator."
        ],
        "code": [
            "@bot.command()\nasync def test(ctx, *, arg):\n    await ctx.send(arg)",
            "Command.rest_is_raw"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Invocation Context#",
        "content": [
            "As seen earlier, every command must take at least a single parameter, called the Context.",
            "This parameter gives you access to something called the “invocation context”. Essentially all the information you need to\nknow how the command was executed. It contains a lot of useful information:",
            "Context.guild to fetch the Guild of the command, if any.",
            "Context.message to fetch the Message of the command.",
            "Context.author to fetch the Member or User that called the command.",
            "Context.send() to send a message to the channel the command was used in.",
            "The context implements the abc.Messageable interface, so anything you can do on a abc.Messageable you\ncan do on the Context."
        ],
        "code": [
            "Context",
            "Context.guild",
            "Guild",
            "Context.message",
            "Message",
            "Context.author",
            "Member",
            "User",
            "Context.send()",
            "abc.Messageable",
            "abc.Messageable",
            "Context"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Converters#",
        "content": [
            "Adding bot arguments with function parameters is only the first step in defining your bot’s command interface. To actually\nmake use of the arguments, we usually want to convert the data into a target type. We call these\nConverters.",
            "Converters come in a few flavours:",
            "A regular callable object that takes an argument as a sole parameter and returns a different type.",
            "These range from your own function, to something like bool or int.",
            "A custom class that inherits from Converter."
        ],
        "code": [
            "bool",
            "int",
            "Converter"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Basic Converters#",
        "content": [
            "At its core, a basic converter is a callable that takes in an argument and turns it into something else.",
            "For example, if we wanted to add two numbers together, we could request that they are turned into integers\nfor us by specifying the converter:",
            "We specify converters by using something called a function annotation. This is a Python 3 exclusive feature that was\nintroduced in PEP 3107.",
            "This works with any callable, such as a function that would convert a string to all upper-case:",
            "Unlike the other basic converters, the bool converter is treated slightly different. Instead of casting directly to the bool type, which would result in any non-empty argument returning True, it instead evaluates the argument as True or False based on its given content:"
        ],
        "code": [
            "@bot.command()\nasync def add(ctx, a: int, b: int):\n    await ctx.send(a + b)",
            "def to_upper(argument):\n    return argument.upper()\n\n@bot.command()\nasync def up(ctx, *, content: to_upper):\n    await ctx.send(content)",
            "bool",
            "bool",
            "True",
            "True",
            "False",
            "if lowered in ('yes', 'y', 'true', 't', '1', 'enable', 'on'):\n    return True\nelif lowered in ('no', 'n', 'false', 'f', '0', 'disable', 'off'):\n    return False"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Advanced Converters#",
        "content": [
            "Sometimes a basic converter doesn’t have enough information that we need. For example, sometimes we want to get some\ninformation from the Message that called the command or we want to do some asynchronous processing.",
            "For this, the library provides the Converter interface. This allows you to have access to the\nContext and have the callable be asynchronous. Defining a custom converter using this interface requires\noverriding a single method, Converter.convert().",
            "An example converter:",
            "The converter provided can either be constructed or not. Essentially these two are equivalent:",
            "Having the possibility of the converter be constructed allows you to set up some state in the converter’s __init__ for\nfine tuning the converter. An example of this is actually in the library, clean_content.",
            "If a converter fails to convert an argument to its designated target type, the BadArgument exception must be\nraised."
        ],
        "code": [
            "Message",
            "Converter",
            "Context",
            "Converter.convert()",
            "import random\n\nclass Slapper(commands.Converter):\n    async def convert(self, ctx, argument):\n        to_slap = random.choice(ctx.guild.members)\n        return f'{ctx.author} slapped {to_slap} because *{argument}*'\n\n@bot.command()\nasync def slap(ctx, *, reason: Slapper):\n    await ctx.send(reason)",
            "@bot.command()\nasync def slap(ctx, *, reason: Slapper):\n    await ctx.send(reason)\n\n# is the same as...\n\n@bot.command()\nasync def slap(ctx, *, reason: Slapper()):\n    await ctx.send(reason)",
            "__init__",
            "clean_content",
            "@bot.command()\nasync def clean(ctx, *, content: commands.clean_content):\n    await ctx.send(content)\n\n# or for fine-tuning\n\n@bot.command()\nasync def clean(ctx, *, content: commands.clean_content(use_nicknames=False)):\n    await ctx.send(content)",
            "BadArgument"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Inline Advanced Converters#",
        "content": [
            "If we don’t want to inherit from Converter, we can still provide a converter that has the\nadvanced functionalities of an advanced converter and save us from specifying two types.",
            "For example, a common idiom would be to have a class and a converter for that class:",
            "This can get tedious, so an inline advanced converter is possible through a classmethod() inside the type:"
        ],
        "code": [
            "Converter",
            "class JoinDistance:\n    def __init__(self, joined, created):\n        self.joined = joined\n        self.created = created\n\n    @property\n    def delta(self):\n        return self.joined - self.created\n\nclass JoinDistanceConverter(commands.MemberConverter):\n    async def convert(self, ctx, argument):\n        member = await super().convert(ctx, argument)\n        return JoinDistance(member.joined_at, member.created_at)\n\n@bot.command()\nasync def delta(ctx, *, member: JoinDistanceConverter):\n    is_new = member.delta.days < 100\n    if is_new:\n        await ctx.send(\"Hey you're pretty new!\")\n    else:\n        await ctx.send(\"Hm you're not so new.\")",
            "classmethod()",
            "class JoinDistance:\n    def __init__(self, joined, created):\n        self.joined = joined\n        self.created = created\n\n    @classmethod\n    async def convert(cls, ctx, argument):\n        member = await commands.MemberConverter().convert(ctx, argument)\n        return cls(member.joined_at, member.created_at)\n\n    @property\n    def delta(self):\n        return self.joined - self.created\n\n@bot.command()\nasync def delta(ctx, *, member: JoinDistance):\n    is_new = member.delta.days < 100\n    if is_new:\n        await ctx.send(\"Hey you're pretty new!\")\n    else:\n        await ctx.send(\"Hm you're not so new.\")"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Discord Converters#",
        "content": [
            "Working with Discord Models is a fairly common thing when defining commands, as a result the library makes\nworking with them easy.",
            "For example, to receive a Member you can just pass it as a converter:",
            "When this command is executed, it attempts to convert the string given into a Member and then passes it as a\nparameter for the function. This works by checking if the string is a mention, an ID, a nickname, a username + discriminator,\nor just a regular username. The default set of converters have been written to be as easy to use as possible.",
            "A lot of discord models work out of the gate as a parameter:",
            "Object (since v2.0)",
            "Member",
            "User",
            "Message (since v1.1)",
            "PartialMessage (since v1.7)",
            "abc.GuildChannel (since 2.0)",
            "TextChannel",
            "VoiceChannel",
            "StageChannel (since v1.7)",
            "CategoryChannel",
            "Invite",
            "Guild (since v1.7)",
            "Role",
            "Game",
            "Colour",
            "Emoji",
            "PartialEmoji",
            "Thread (since v2.0)",
            "Having any of these set as the converter will intelligently convert the argument to the appropriate target type you\nspecify.",
            "Under the hood, these are implemented by the Advanced Converters interface. A table of the equivalent\nconverter is given below:",
            "Discord Class",
            "Converter",
            "Object",
            "ObjectConverter",
            "Member",
            "MemberConverter",
            "User",
            "UserConverter",
            "Message",
            "MessageConverter",
            "PartialMessage",
            "PartialMessageConverter",
            "GuildChannel",
            "GuildChannelConverter",
            "TextChannel",
            "TextChannelConverter",
            "VoiceChannel",
            "VoiceChannelConverter",
            "StageChannel",
            "StageChannelConverter",
            "CategoryChannel",
            "CategoryChannelConverter",
            "Invite",
            "InviteConverter",
            "Guild",
            "GuildConverter",
            "Role",
            "RoleConverter",
            "Game",
            "GameConverter",
            "Colour",
            "ColourConverter",
            "Emoji",
            "EmojiConverter",
            "PartialEmoji",
            "PartialEmojiConverter",
            "Thread",
            "ThreadConverter",
            "By providing the converter it allows us to use them as building blocks for another converter:"
        ],
        "code": [
            "Member",
            "@bot.command()\nasync def joined(ctx, *, member: discord.Member):\n    await ctx.send(f'{member} joined on {member.joined_at}')",
            "Member",
            "Object",
            "Member",
            "User",
            "Message",
            "PartialMessage",
            "abc.GuildChannel",
            "TextChannel",
            "VoiceChannel",
            "StageChannel",
            "CategoryChannel",
            "Invite",
            "Guild",
            "Role",
            "Game",
            "Colour",
            "Emoji",
            "PartialEmoji",
            "Thread",
            "Object",
            "ObjectConverter",
            "Member",
            "MemberConverter",
            "User",
            "UserConverter",
            "Message",
            "MessageConverter",
            "PartialMessage",
            "PartialMessageConverter",
            "GuildChannel",
            "GuildChannelConverter",
            "TextChannel",
            "TextChannelConverter",
            "VoiceChannel",
            "VoiceChannelConverter",
            "StageChannel",
            "StageChannelConverter",
            "CategoryChannel",
            "CategoryChannelConverter",
            "Invite",
            "InviteConverter",
            "Guild",
            "GuildConverter",
            "Role",
            "RoleConverter",
            "Game",
            "GameConverter",
            "Colour",
            "ColourConverter",
            "Emoji",
            "EmojiConverter",
            "PartialEmoji",
            "PartialEmojiConverter",
            "Thread",
            "ThreadConverter",
            "class MemberRoles(commands.MemberConverter):\n    async def convert(self, ctx, argument):\n        member = await super().convert(ctx, argument)\n        return [role.name for role in member.roles[1:]] # Remove everyone role!\n\n@bot.command()\nasync def roles(ctx, *, member: MemberRoles):\n    \"\"\"Tells you a member's roles.\"\"\"\n    await ctx.send('I see the following roles: ' + ', '.join(member))"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Special Converters#",
        "content": [
            "The command extension also has support for certain converters to allow for more advanced and intricate use cases that go\nbeyond the generic linear parsing. These converters allow you to introduce some more relaxed and dynamic grammar to your\ncommands in an easy to use manner.",
            "A typing.Union is a special type hint that allows for the command to take in any of the specific types instead of\na singular type. For example, given the following:",
            "The what parameter would either take a discord.TextChannel converter or a discord.Member converter.\nThe way this works is through a left-to-right order. It first attempts to convert the input to a\ndiscord.TextChannel, and if it fails it tries to convert it to a discord.Member. If all converters fail,\nthen a special error is raised, BadUnionArgument.",
            "Note that any valid converter discussed above can be passed in to the argument list of a typing.Union.",
            "A typing.Optional is a special type hint that allows for “back-referencing” behaviour. If the converter fails to\nparse into the specified type, the parser will skip the parameter and then either None or the specified default will be\npassed into the parameter instead. The parser will then continue on to the next parameters and converters, if any.",
            "Consider the following example:",
            "In this example, since the argument could not be converted into an int, the default of 99 is passed and the parser\nresumes handling, which in this case would be to pass it into the liquid parameter.",
            "Note",
            "This converter only works in regular positional parameters, not variable parameters or keyword-only parameters.",
            "A typing.Literal is a special type hint that requires the passed parameter to be equal to one of the listed values\nafter being converted to the same type. For example, given the following:",
            "The buy_sell parameter must be either the literal string \"buy\" or \"sell\" and amount must convert to the\nint 1 or 2. If buy_sell or amount don’t match any value, then a special error is raised,\nBadLiteralArgument. Any literal values can be mixed and matched within the same typing.Literal converter.",
            "Note that typing.Literal[True] and typing.Literal[False] still follow the bool converter rules.",
            "The Greedy converter is a generalisation of the typing.Optional converter, except applied\nto a list of arguments. In simple terms, this means that it tries to convert as much as it can until it can’t convert\nany further.",
            "Consider the following example:",
            "When invoked, it allows for any number of members to be passed in:",
            "The type passed when using this converter depends on the parameter type that it is being attached to:",
            "Positional parameter types will receive either the default parameter or a list of the converted values.",
            "Variable parameter types will be a tuple as usual.",
            "Keyword-only parameter types will be the same as if Greedy was not passed at all.",
            "Greedy parameters can also be made optional by specifying an optional value.",
            "When mixed with the typing.Optional converter you can provide simple and expressive command invocation syntaxes:",
            "This command can be invoked any of the following ways:",
            "Warning",
            "The usage of Greedy and typing.Optional are powerful and useful, however as a\nprice, they open you up to some parsing ambiguities that might surprise some people.",
            "For example, a signature expecting a typing.Optional of a discord.Member followed by a\nint could catch a member named after a number due to the different ways a\nMemberConverter decides to fetch members. You should take care to not introduce\nunintended parsing ambiguities in your code. One technique would be to clamp down the expected syntaxes\nallowed through custom converters or reordering the parameters to minimise clashes.",
            "To help aid with some parsing ambiguities, str, None, typing.Optional and\nGreedy are forbidden as parameters for the Greedy converter."
        ],
        "code": [
            "typing.Union",
            "import typing\n\n@bot.command()\nasync def union(ctx, what: typing.Union[discord.TextChannel, discord.Member]):\n    await ctx.send(what)",
            "what",
            "discord.TextChannel",
            "discord.Member",
            "discord.TextChannel",
            "discord.Member",
            "BadUnionArgument",
            "typing.Union",
            "typing.Optional",
            "None",
            "import typing\n\n@bot.command()\nasync def bottles(ctx, amount: typing.Optional[int] = 99, *, liquid=\"beer\"):\n    await ctx.send(f'{amount} bottles of {liquid} on the wall!')",
            "int",
            "99",
            "liquid",
            "typing.Literal",
            "from typing import Literal\n\n@bot.command()\nasync def shop(ctx, buy_sell: Literal['buy', 'sell'], amount: Literal[1, 2], *, item: str):\n    await ctx.send(f'{buy_sell.capitalize()}ing {amount} {item}(s)!')",
            "buy_sell",
            "\"buy\"",
            "\"sell\"",
            "amount",
            "int",
            "1",
            "2",
            "buy_sell",
            "amount",
            "BadLiteralArgument",
            "typing.Literal",
            "typing.Literal[True]",
            "typing.Literal[False]",
            "bool",
            "Greedy",
            "typing.Optional",
            "@bot.command()\nasync def slap(ctx, members: commands.Greedy[discord.Member], *, reason='no reason'):\n    slapped = \", \".join(x.name for x in members)\n    await ctx.send(f'{slapped} just got slapped for {reason}')",
            "list",
            "tuple",
            "Greedy",
            "Greedy",
            "typing.Optional",
            "import typing\n\n@bot.command()\nasync def ban(ctx, members: commands.Greedy[discord.Member],\n                   delete_seconds: typing.Optional[int] = 0, *,\n                   reason: str):\n    \"\"\"Bulk bans members with an optional delete_seconds parameter\"\"\"\n    await ctx.guild.bulk_ban(*members, delete_message_seconds=delete_seconds, reason=reason)",
            "$ban @Member @Member2 spam bot\n$ban @Member @Member2 7 spam bot\n$ban @Member spam",
            "Greedy",
            "typing.Optional",
            "typing.Optional",
            "discord.Member",
            "int",
            "MemberConverter",
            "str",
            "None",
            "typing.Optional",
            "Greedy",
            "Greedy"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "FlagConverter#",
        "content": [
            "New in version 2.0.",
            "A FlagConverter allows the user to specify user-friendly “flags” using PEP 526 type annotations\nor a syntax more reminiscent of the dataclasses module.",
            "For example, the following code:",
            "Allows the user to invoke the command using a simple flag-like syntax:",
            "Flags use a syntax that allows the user to not require quotes when passing in values to the flag. The goal of the\nflag syntax is to be as user-friendly as possible. This makes flags a good choice for complicated commands that can have\nmultiple knobs to turn or simulating keyword-only parameters in your external command interface. It is recommended to use\nkeyword-only parameters with the flag converter. This ensures proper parsing and behaviour with quoting.",
            "Internally, the FlagConverter class examines the class to find flags. A flag can either be a\nclass variable with a type annotation or a class variable that’s been assigned the result of the flag()\nfunction. These flags are then used to define the interface that your users will use. The annotations correspond to\nthe converters that the flag arguments must adhere to.",
            "For most use cases, no extra work is required to define flags. However, if customisation is needed to control the flag name\nor the default value then the flag() function can come in handy:",
            "This tells the parser that the members attribute is mapped to a flag named member and that\nthe default value is an empty list. For greater customisability, the default can either be a value or a callable\nthat takes the Context as a sole parameter. This callable can either be a function or a coroutine.",
            "In order to customise the flag syntax we also have a few options that can be passed to the class parameter list:",
            "Note",
            "Despite the similarities in these examples to command like arguments, the syntax and parser is not\na command line parser. The syntax is mainly inspired by Discord’s search bar input and as a result\nall flags need a corresponding value.",
            "The flag converter is similar to regular commands and allows you to use most types of converters\n(with the exception of Greedy) as the type annotation. Some extra support is added for specific\nannotations as described below.",
            "If a list is given as a flag annotation it tells the parser that the argument can be passed multiple times.",
            "For example, augmenting the example above:",
            "This is called by repeatedly specifying the flag:",
            "Since the above syntax can be a bit repetitive when specifying a flag many times, the tuple type annotation\nallows for “greedy-like” semantics using a variadic tuple:",
            "This allows the previous ban command to be called like this:",
            "The tuple annotation also allows for parsing of pairs. For example, given the following code:",
            "Warning",
            "Due to potential parsing ambiguities, the parser expects tuple arguments to be quoted\nif they require spaces. So if one of the inner types is str and the argument requires spaces\nthen quotes should be used to disambiguate it from the other element of the tuple.",
            "A dict annotation is functionally equivalent to List[Tuple[K, V]] except with the return type\ngiven as a dict rather than a list."
        ],
        "code": [
            "FlagConverter",
            "dataclasses",
            "from discord.ext import commands\nimport discord\n\nclass BanFlags(commands.FlagConverter):\n    member: discord.Member\n    reason: str\n    days: int = 1\n\n@commands.command()\nasync def ban(ctx, *, flags: BanFlags):\n    plural = f'{flags.days} days' if flags.days != 1 else f'{flags.days} day'\n    await ctx.send(f'Banned {flags.member} for {flags.reason!r} (deleted {plural} worth of messages)')",
            "FlagConverter",
            "flag()",
            "flag()",
            "from typing import List\n\nclass BanFlags(commands.FlagConverter):\n    members: List[discord.Member] = commands.flag(name='member', default=lambda ctx: [])",
            "members",
            "member",
            "Context",
            "# --hello world syntax\nclass PosixLikeFlags(commands.FlagConverter, delimiter=' ', prefix='--'):\n    hello: str\n\n\n# /make food\nclass WindowsLikeFlags(commands.FlagConverter, prefix='/', delimiter=''):\n    make: str\n\n# TOPIC: not allowed nsfw: yes Slowmode: 100\nclass Settings(commands.FlagConverter, case_insensitive=True):\n    topic: Optional[str]\n    nsfw: Optional[bool]\n    slowmode: Optional[int]",
            "Greedy",
            "from discord.ext import commands\nfrom typing import List\nimport discord\n\nclass BanFlags(commands.FlagConverter):\n    members: List[discord.Member] = commands.flag(name='member')\n    reason: str\n    days: int = 1\n\n@commands.command()\nasync def ban(ctx, *, flags: BanFlags):\n    for member in flags.members:\n        await member.ban(reason=flags.reason, delete_message_seconds=flags.days * 60 * 24)\n\n    members = ', '.join(str(member) for member in flags.members)\n    plural = f'{flags.days} days' if flags.days != 1 else f'{flags.days} day'\n    await ctx.send(f'Banned {members} for {flags.reason!r} (deleted {plural} worth of messages)')",
            "tuple",
            "from discord.ext import commands\nfrom typing import Tuple\nimport discord\n\nclass BanFlags(commands.FlagConverter):\n    members: Tuple[discord.Member, ...]\n    reason: str\n    days: int = 1",
            "ban",
            "tuple",
            "# point: 10 11 point: 12 13\nclass Coordinates(commands.FlagConverter):\n    point: Tuple[int, int]",
            "str",
            "dict",
            "List[Tuple[K, V]]",
            "dict",
            "list"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Error Handling#",
        "content": [
            "When our commands fail to parse we will, by default, receive a noisy error in stderr of our console that tells us\nthat an error has happened and has been silently ignored.",
            "In order to handle our errors, we must use something called an error handler. There is a global error handler, called\non_command_error() which works like any other event in the Event Reference. This global error handler is\ncalled for every error reached.",
            "Most of the time however, we want to handle an error local to the command itself. Luckily, commands come with local error\nhandlers that allow us to do just that. First we decorate an error handler function with Command.error():",
            "The first parameter of the error handler is the Context while the second one is an exception that is derived from\nCommandError. A list of errors is found in the Exceptions page of the documentation."
        ],
        "code": [
            "stderr",
            "on_command_error()",
            "Command.error()",
            "@bot.command()\nasync def info(ctx, *, member: discord.Member):\n    \"\"\"Tells you some info about the member.\"\"\"\n    msg = f'{member} joined on {member.joined_at} and has {len(member.roles)} roles.'\n    await ctx.send(msg)\n\n@info.error\nasync def info_error(ctx, error):\n    if isinstance(error, commands.BadArgument):\n        await ctx.send('I could not find that member...')",
            "Context",
            "CommandError"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Checks#",
        "content": [
            "There are cases when we don’t want a user to use our commands. They don’t have permissions to do so or maybe we blocked\nthem from using our bot earlier. The commands extension comes with full support for these things in a concept called a\nChecks.",
            "A check is a basic predicate that can take in a Context as its sole parameter. Within it, you have the following\noptions:",
            "Return True to signal that the person can run the command.",
            "Return False to signal that the person cannot run the command.",
            "Raise a CommandError derived exception to signal the person cannot run the command.",
            "This allows you to have custom error messages for you to handle in the\nerror handlers.",
            "To register a check for a command, we would have two ways of doing so. The first is using the check()\ndecorator. For example:",
            "This would only evaluate the command if the function is_owner returns True. Sometimes we re-use a check often and\nwant to split it into its own decorator. To do that we can just add another level of depth:",
            "Since an owner check is so common, the library provides it for you (is_owner()):",
            "When multiple checks are specified, all of them must be True:",
            "If any of those checks fail in the example above, then the command will not be run.",
            "When an error happens, the error is propagated to the error handlers. If you do not\nraise a custom CommandError derived exception, then it will get wrapped up into a\nCheckFailure exception as so:",
            "If you want a more robust error system, you can derive from the exception and raise it instead of returning False:",
            "Note",
            "Since having a guild_only decorator is pretty common, it comes built-in via guild_only()."
        ],
        "code": [
            "Context",
            "True",
            "False",
            "CommandError",
            "check()",
            "async def is_owner(ctx):\n    return ctx.author.id == 316026178463072268\n\n@bot.command(name='eval')\n@commands.check(is_owner)\nasync def _eval(ctx, *, code):\n    \"\"\"A bad example of an eval command\"\"\"\n    await ctx.send(eval(code))",
            "is_owner",
            "True",
            "def is_owner():\n    async def predicate(ctx):\n        return ctx.author.id == 316026178463072268\n    return commands.check(predicate)\n\n@bot.command(name='eval')\n@is_owner()\nasync def _eval(ctx, *, code):\n    \"\"\"A bad example of an eval command\"\"\"\n    await ctx.send(eval(code))",
            "is_owner()",
            "@bot.command(name='eval')\n@commands.is_owner()\nasync def _eval(ctx, *, code):\n    \"\"\"A bad example of an eval command\"\"\"\n    await ctx.send(eval(code))",
            "True",
            "def is_in_guild(guild_id):\n    async def predicate(ctx):\n        return ctx.guild and ctx.guild.id == guild_id\n    return commands.check(predicate)\n\n@bot.command()\n@commands.is_owner()\n@is_in_guild(41771983423143937)\nasync def secretguilddata(ctx):\n    \"\"\"super secret stuff\"\"\"\n    await ctx.send('secret stuff')",
            "CommandError",
            "CheckFailure",
            "@bot.command()\n@commands.is_owner()\n@is_in_guild(41771983423143937)\nasync def secretguilddata(ctx):\n    \"\"\"super secret stuff\"\"\"\n    await ctx.send('secret stuff')\n\n@secretguilddata.error\nasync def secretguilddata_error(ctx, error):\n    if isinstance(error, commands.CheckFailure):\n        await ctx.send('nothing to see here comrade.')",
            "False",
            "class NoPrivateMessages(commands.CheckFailure):\n    pass\n\ndef guild_only():\n    async def predicate(ctx):\n        if ctx.guild is None:\n            raise NoPrivateMessages('Hey no DMs!')\n        return True\n    return commands.check(predicate)\n\n@bot.command()\n@guild_only()\nasync def test(ctx):\n    await ctx.send('Hey this is not a DM! Nice.')\n\n@test.error\nasync def test_error(ctx, error):\n    if isinstance(error, NoPrivateMessages):\n        await ctx.send(error)",
            "guild_only",
            "guild_only()"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Global Checks#",
        "content": [
            "Sometimes we want to apply a check to every command, not just certain commands. The library supports this as well\nusing the global check concept.",
            "Global checks work similarly to regular checks except they are registered with the Bot.check() decorator.",
            "For example, to block all DMs we could do the following:",
            "Warning",
            "Be careful on how you write your global checks, as it could also lock you out of your own bot."
        ],
        "code": [
            "Bot.check()",
            "@bot.check\nasync def globally_block_dms(ctx):\n    return ctx.guild is not None"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/commands.html"
    },
    {
        "title": "Webhook Support#",
        "content": [
            "Pycord offers support for creating, editing, and executing webhooks through the Webhook class.",
            "Represents an asynchronous Discord webhook.",
            "Webhooks are a form to send messages to channels in Discord without a\nbot user or authentication.",
            "There are two main ways to use Webhooks. The first is through the ones\nreceived by the library such as Guild.webhooks() and\nTextChannel.webhooks(). The ones received by the library will\nautomatically be bound using the library’s internal HTTP session.",
            "The second form involves creating a webhook object manually using the\nfrom_url() or partial() classmethods.",
            "For example, creating a webhook from a URL and using aiohttp:",
            "For a synchronous counterpart, see SyncWebhook.",
            "Checks if two webhooks are equal.",
            "Checks if two webhooks are not equal.",
            "Returns the webhook’s hash.",
            "Changed in version 1.4: Webhooks are now comparable and hashable.",
            "The webhook’s ID",
            "int",
            "The type of the webhook.",
            "New in version 1.3.",
            "WebhookType",
            "The authentication token of the webhook. If this is None\nthen the webhook cannot be used to make requests.",
            "Optional[str]",
            "The guild ID this webhook is for.",
            "Optional[int]",
            "The channel ID this webhook is for.",
            "Optional[int]",
            "The user this webhook was created by. If the webhook was\nreceived without authentication then this will be None.",
            "Optional[abc.User]",
            "The default name of the webhook.",
            "Optional[str]",
            "The guild of the channel that this webhook is following.\nOnly given if type is WebhookType.channel_follower.",
            "New in version 2.0.",
            "Optional[PartialWebhookGuild]",
            "The channel that this webhook is following.\nOnly given if type is WebhookType.channel_follower.",
            "New in version 2.0.",
            "Optional[PartialWebhookChannel]",
            "data (WebhookPayload | FollowerWebhookPayload) –",
            "session (aiohttp.ClientSession) –",
            "proxy (str | None) –",
            "proxy_auth (aiohttp.BasicAuth | None) –",
            "token (str | None) –",
            "Returns the webhook’s url.",
            "Creates a partial Webhook.",
            "id (int) – The ID of the webhook.",
            "token (str) – The authentication token of the webhook.",
            "session (aiohttp.ClientSession) – The session to use to send requests with. Note\nthat the library does not manage the session and\nwill not close it.\n\nNew in version 2.0.",
            "The session to use to send requests with. Note\nthat the library does not manage the session and\nwill not close it.",
            "New in version 2.0.",
            "bot_token (Optional[str]) – The bot authentication token for authenticated requests\ninvolving the webhook.\n\nNew in version 2.0.",
            "The bot authentication token for authenticated requests\ninvolving the webhook.",
            "New in version 2.0.",
            "proxy (str | None) –",
            "proxy_auth (aiohttp.BasicAuth | None) –",
            "A partial Webhook.\nA partial webhook is just a webhook object with an ID and a token.",
            "Webhook",
            "Creates a partial Webhook from a webhook URL.",
            "url (str) – The URL of the webhook.",
            "session (aiohttp.ClientSession) – The session to use to send requests with. Note\nthat the library does not manage the session and\nwill not close it.\n\nNew in version 2.0.",
            "The session to use to send requests with. Note\nthat the library does not manage the session and\nwill not close it.",
            "New in version 2.0.",
            "bot_token (Optional[str]) – The bot authentication token for authenticated requests\ninvolving the webhook.\n\nNew in version 2.0.",
            "The bot authentication token for authenticated requests\ninvolving the webhook.",
            "New in version 2.0.",
            "proxy (str | None) –",
            "proxy_auth (aiohttp.BasicAuth | None) –",
            "A partial Webhook.\nA partial webhook is just a webhook object with an ID and a token.",
            "Webhook",
            "InvalidArgument – The URL is invalid.",
            "This function is a coroutine.",
            "Fetches the current webhook.",
            "This could be used to get a full webhook from a partial webhook.",
            "New in version 2.0.",
            "Note",
            "When fetching with an unauthenticated webhook, i.e.\nis_authenticated() returns False, then the\nreturned webhook does not contain any user information.",
            "prefer_auth (bool) – Whether to use the bot token over the webhook token\nif available. Defaults to True.",
            "The fetched webhook.",
            "Webhook",
            "HTTPException – Could not fetch the webhook",
            "NotFound – Could not find the webhook by this ID",
            "InvalidArgument – This webhook does not have a token associated with it.",
            "This function is a coroutine.",
            "Deletes this Webhook.",
            "reason (Optional[str]) – The reason for deleting this webhook. Shows up on the audit log.\n\nNew in version 1.4.",
            "The reason for deleting this webhook. Shows up on the audit log.",
            "New in version 1.4.",
            "prefer_auth (bool) – Whether to use the bot token over the webhook token\nif available. Defaults to True.\n\nNew in version 2.0.",
            "Whether to use the bot token over the webhook token\nif available. Defaults to True.",
            "New in version 2.0.",
            "HTTPException – Deleting the webhook failed.",
            "NotFound – This webhook does not exist.",
            "Forbidden – You do not have permissions to delete this webhook.",
            "InvalidArgument – This webhook does not have a token associated with it.",
            "This function is a coroutine.",
            "Edits this Webhook.",
            "name (Optional[str]) – The webhook’s new default name.",
            "avatar (Optional[bytes]) – A bytes-like object representing the webhook’s new default avatar.",
            "channel (Optional[abc.Snowflake]) – The webhook’s new channel. This requires an authenticated webhook.\n\nNew in version 2.0.",
            "The webhook’s new channel. This requires an authenticated webhook.",
            "New in version 2.0.",
            "reason (Optional[str]) – The reason for editing this webhook. Shows up on the audit log.\n\nNew in version 1.4.",
            "The reason for editing this webhook. Shows up on the audit log.",
            "New in version 1.4.",
            "prefer_auth (bool) – Whether to use the bot token over the webhook token\nif available. Defaults to True.\n\nNew in version 2.0.",
            "Whether to use the bot token over the webhook token\nif available. Defaults to True.",
            "New in version 2.0.",
            "HTTPException – Editing the webhook failed.",
            "NotFound – This webhook does not exist.",
            "InvalidArgument – This webhook does not have a token associated with it, or\n    it tried editing a channel without authentication.",
            "Webhook",
            "This function is a coroutine.",
            "Sends a message using the webhook.",
            "The content must be a type that can convert to a string through str(content).",
            "To upload a single file, the file parameter should be used with a\nsingle File object.",
            "If the embed parameter is provided, it must be of type Embed and\nit must be a rich embed type. You cannot mix the embed parameter with the\nembeds parameter, which must be a list of Embed objects to send.",
            "content (str) – The content of the message to send.",
            "wait (bool) – Whether the server should wait before sending a response. This essentially\nmeans that the return type of this function changes from None to\na WebhookMessage if set to True. If the type of webhook\nis WebhookType.application then this is always set to True.",
            "username (str) – The username to send with this message. If no username is provided\nthen the default username for the webhook is used.",
            "avatar_url (str) – The avatar URL to send with this message. If no avatar URL is provided\nthen the default avatar for the webhook is used. If this is not a\nstring then it is explicitly cast using str.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "ephemeral (bool) – Indicates if the message should only be visible to the user.\nThis is only available to WebhookType.application webhooks.\nIf a view is sent with an ephemeral message, and it has no timeout set\nthen the timeout is set to 15 minutes.\n\nNew in version 2.0.",
            "Indicates if the message should only be visible to the user.\nThis is only available to WebhookType.application webhooks.\nIf a view is sent with an ephemeral message, and it has no timeout set\nthen the timeout is set to 15 minutes.",
            "New in version 2.0.",
            "file (File) – The file to upload. This cannot be mixed with files parameter.",
            "files (List[File]) – A list of files to send with the content. This cannot be mixed with the\nfile parameter.",
            "embed (Embed) – The rich embed for the content to send. This cannot be mixed with\nembeds parameter.",
            "embeds (List[Embed]) – A list of embeds to send with the content. Maximum of 10. This cannot\nbe mixed with the embed parameter.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message.",
            "New in version 1.4.",
            "view (discord.ui.View) – The view to send with the message. You can only send a view\nif this webhook is not partial and has state attached. A\nwebhook has state attached if the webhook is managed by the\nlibrary.\n\nNew in version 2.0.",
            "The view to send with the message. You can only send a view\nif this webhook is not partial and has state attached. A\nwebhook has state attached if the webhook is managed by the\nlibrary.",
            "New in version 2.0.",
            "thread (Snowflake) – The thread to send this webhook to.\n\nNew in version 2.0.",
            "The thread to send this webhook to.",
            "New in version 2.0.",
            "thread_name (str) – The name of the thread to create. Only works for forum channels.\n\nNew in version 2.0.",
            "The name of the thread to create. Only works for forum channels.",
            "New in version 2.0.",
            "applied_tags (List[Snowflake]) – A list of tags to apply to the message. Only works for threads.\n\nNew in version 2.5.",
            "A list of tags to apply to the message. Only works for threads.",
            "New in version 2.5.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "If wait is True then the message that was sent, otherwise None.",
            "Optional[WebhookMessage]",
            "HTTPException – Sending the message failed.",
            "NotFound – This webhook was not found.",
            "Forbidden – The authorization token for the webhook is incorrect.",
            "TypeError – You specified both embed and embeds or file and files.",
            "ValueError – The length of embeds was invalid.",
            "InvalidArgument – Either there was no token associated with this webhook, ephemeral was passed\n    with the improper webhook type, there was no state attached with this webhook when\n    giving it a view, you specified both thread_name and thread, or applied_tags\n    was passed with neither thread_name nor thread specified.",
            "Returns an Asset for the avatar the webhook has.",
            "If the webhook does not have a traditional avatar, an asset for\nthe default avatar is returned instead.",
            "The text channel this webhook belongs to.",
            "If this is a partial webhook, then this will always return None.",
            "Returns the webhook’s creation time in UTC.",
            "This function is a coroutine.",
            "Retrieves a single WebhookMessage owned by this webhook.",
            "New in version 2.0.",
            "id (int) – The message ID to look for.",
            "thread_id (Optional[int]) – The ID of the thread that contains the message.",
            "The message asked for.",
            "WebhookMessage",
            "NotFound – The specified message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "InvalidArgument – There was no token associated with this webhook.",
            "The guild this webhook belongs to.",
            "If this is a partial webhook, then this will always return None.",
            "Whether the webhook is authenticated with a bot token.\n:rtype: bool",
            "New in version 2.0.",
            "Whether the webhook is a “partial” webhook.\n:rtype: bool",
            "New in version 2.0.",
            "This function is a coroutine.",
            "Edits a message owned by this webhook.",
            "This is a lower level interface to WebhookMessage.edit() in case\nyou only have an ID.",
            "New in version 1.6.",
            "Changed in version 2.0: The edit is no longer in-place, instead the newly edited message is returned.",
            "message_id (int) – The message ID to edit.",
            "content (Optional[str]) – The content to edit the message with or None to clear it.",
            "embeds (List[Embed]) – A list of embeds to edit the message with.",
            "embed (Optional[Embed]) – The embed to edit the message with. None suppresses the embeds.\nThis should not be mixed with the embeds parameter.",
            "attachments (List[Attachment]) – A list of attachments to keep in the message. If [] is passed\nthen all attachments are removed.",
            "file (File) – The file to upload. This cannot be mixed with files parameter.\n\nNew in version 2.0.",
            "The file to upload. This cannot be mixed with files parameter.",
            "New in version 2.0.",
            "files (List[File]) – A list of files to send with the content. This cannot be mixed with the\nfile parameter.\n\nNew in version 2.0.",
            "A list of files to send with the content. This cannot be mixed with the\nfile parameter.",
            "New in version 2.0.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message.\nSee abc.Messageable.send() for more information.",
            "view (Optional[View]) – The updated view to update this message with. If None is passed then\nthe view is removed. The webhook must have state attached, similar to\nsend().\n\nNew in version 2.0.",
            "The updated view to update this message with. If None is passed then\nthe view is removed. The webhook must have state attached, similar to\nsend().",
            "New in version 2.0.",
            "thread (Optional[Snowflake]) – The thread that contains the message.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "The newly edited webhook message.",
            "WebhookMessage",
            "HTTPException – Editing the message failed.",
            "Forbidden – Edited a message that is not yours.",
            "TypeError – You specified both embed and embeds or file and files",
            "ValueError – The length of embeds was invalid",
            "InvalidArgument – There was no token associated with this webhook or the webhook had\n    no state.",
            "This function is a coroutine.",
            "Deletes a message owned by this webhook.",
            "This is a lower level interface to WebhookMessage.delete() in case\nyou only have an ID.",
            "New in version 1.6.",
            "message_id (int) – The message ID to delete.",
            "thread_id (Optional[int]) – The ID of the thread that contains the message.",
            "HTTPException – Deleting the message failed.",
            "Forbidden – Deleted a message that is not yours.",
            "None",
            "Represents a message sent from your webhook.",
            "This allows you to edit or delete a message sent by your\nwebhook.",
            "This inherits from discord.Message with changes to\nedit() and delete() to work.",
            "New in version 1.6.",
            "state (ConnectionState) –",
            "channel (Union[TextChannel, VoiceChannel, StageChannel, Thread, DMChannel, PartialMessageable, GroupChannel]) –",
            "data (Message) –",
            "This function is a coroutine.",
            "Edits the message.",
            "New in version 1.6.",
            "Changed in version 2.0: The edit is no longer in-place, instead the newly edited message is returned.",
            "content (Optional[str]) – The content to edit the message with or None to clear it.",
            "embeds (List[Embed]) – A list of embeds to edit the message with.",
            "embed (Optional[Embed]) – The embed to edit the message with. None suppresses the embeds.\nThis should not be mixed with the embeds parameter.",
            "file (File) – The file to upload. This cannot be mixed with files parameter.\n\nNew in version 2.0.",
            "The file to upload. This cannot be mixed with files parameter.",
            "New in version 2.0.",
            "files (List[File]) – A list of files to send with the content. This cannot be mixed with the\nfile parameter.\n\nNew in version 2.0.",
            "A list of files to send with the content. This cannot be mixed with the\nfile parameter.",
            "New in version 2.0.",
            "attachments (List[Attachment]) – A list of attachments to keep in the message. If [] is passed\nthen all attachments are removed.\n\nNew in version 2.0.",
            "A list of attachments to keep in the message. If [] is passed\nthen all attachments are removed.",
            "New in version 2.0.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message.\nSee abc.Messageable.send() for more information.",
            "view (Optional[View]) – The updated view to update this message with. If None is passed then\nthe view is removed.\n\nNew in version 2.0.",
            "The updated view to update this message with. If None is passed then\nthe view is removed.",
            "New in version 2.0.",
            "suppress (Optional[bool]) – Whether to suppress embeds for the message.",
            "The newly edited message.",
            "WebhookMessage",
            "HTTPException – Editing the message failed.",
            "Forbidden – Edited a message that is not yours.",
            "TypeError – You specified both embed and embeds or file and files",
            "ValueError – The length of embeds was invalid",
            "InvalidArgument – There was no token associated with this webhook.",
            "This function is a coroutine.",
            "Deletes the message.",
            "delay (Optional[float]) – If provided, the number of seconds to wait before deleting the message.\nThe waiting is done in the background and deletion failures are ignored.",
            "Forbidden – You do not have proper permissions to delete the message.",
            "NotFound – The message was deleted already.",
            "HTTPException – Deleting the message failed.",
            "None",
            "Represents a synchronous Discord webhook.",
            "For an asynchronous counterpart, see Webhook.",
            "Checks if two webhooks are equal.",
            "Checks if two webhooks are not equal.",
            "Returns the webhook’s hash.",
            "Changed in version 1.4: Webhooks are now comparable and hashable.",
            "The webhook’s ID",
            "int",
            "The type of the webhook.",
            "New in version 1.3.",
            "WebhookType",
            "The authentication token of the webhook. If this is None\nthen the webhook cannot be used to make requests.",
            "Optional[str]",
            "The guild ID this webhook is for.",
            "Optional[int]",
            "The channel ID this webhook is for.",
            "Optional[int]",
            "The user this webhook was created by. If the webhook was\nreceived without authentication then this will be None.",
            "Optional[abc.User]",
            "The default name of the webhook.",
            "Optional[str]",
            "The guild of the channel that this webhook is following.\nOnly given if type is WebhookType.channel_follower.",
            "New in version 2.0.",
            "Optional[PartialWebhookGuild]",
            "The channel that this webhook is following.\nOnly given if type is WebhookType.channel_follower.",
            "New in version 2.0.",
            "Optional[PartialWebhookChannel]",
            "data (WebhookPayload) –",
            "session (Session) –",
            "token (str | None) –",
            "Returns the webhook’s url.",
            "Creates a partial Webhook.",
            "id (int) – The ID of the webhook.",
            "token (str) – The authentication token of the webhook.",
            "session (requests.Session) – The session to use to send requests with. Note\nthat the library does not manage the session and\nwill not close it. If not given, the requests\nauto session creation functions are used instead.",
            "bot_token (Optional[str]) – The bot authentication token for authenticated requests\ninvolving the webhook.",
            "A partial Webhook.\nA partial webhook is just a webhook object with an ID and a token.",
            "Webhook",
            "Creates a partial Webhook from a webhook URL.",
            "url (str) – The URL of the webhook.",
            "session (requests.Session) – The session to use to send requests with. Note\nthat the library does not manage the session and\nwill not close it. If not given, the requests\nauto session creation functions are used instead.",
            "bot_token (Optional[str]) – The bot authentication token for authenticated requests\ninvolving the webhook.",
            "A partial Webhook.\nA partial webhook is just a webhook object with an ID and a token.",
            "Webhook",
            "InvalidArgument – The URL is invalid.",
            "Fetches the current webhook.",
            "This could be used to get a full webhook from a partial webhook.",
            "Note",
            "When fetching with an unauthenticated webhook, i.e.\nis_authenticated() returns False, then the\nreturned webhook does not contain any user information.",
            "prefer_auth (bool) – Whether to use the bot token over the webhook token\nif available. Defaults to True.",
            "The fetched webhook.",
            "SyncWebhook",
            "HTTPException – Could not fetch the webhook",
            "NotFound – Could not find the webhook by this ID",
            "InvalidArgument – This webhook does not have a token associated with it.",
            "Deletes this Webhook.",
            "reason (Optional[str]) – The reason for deleting this webhook. Shows up on the audit log.\n\nNew in version 1.4.",
            "The reason for deleting this webhook. Shows up on the audit log.",
            "New in version 1.4.",
            "prefer_auth (bool) – Whether to use the bot token over the webhook token\nif available. Defaults to True.",
            "HTTPException – Deleting the webhook failed.",
            "NotFound – This webhook does not exist.",
            "Forbidden – You do not have permissions to delete this webhook.",
            "InvalidArgument – This webhook does not have a token associated with it.",
            "None",
            "Edits this Webhook.",
            "name (Optional[str]) – The webhook’s new default name.",
            "avatar (Optional[bytes]) – A bytes-like object representing the webhook’s new default avatar.",
            "channel (Optional[abc.Snowflake]) – The webhook’s new channel. This requires an authenticated webhook.",
            "reason (Optional[str]) – The reason for editing this webhook. Shows up on the audit log.\n\nNew in version 1.4.",
            "The reason for editing this webhook. Shows up on the audit log.",
            "New in version 1.4.",
            "prefer_auth (bool) – Whether to use the bot token over the webhook token\nif available. Defaults to True.",
            "The newly edited webhook.",
            "SyncWebhook",
            "HTTPException – Editing the webhook failed.",
            "NotFound – This webhook does not exist.",
            "InvalidArgument – This webhook does not have a token associated with it, or\n    it tried editing a channel without authentication.",
            "Sends a message using the webhook.",
            "The content must be a type that can convert to a string through str(content).",
            "To upload a single file, the file parameter should be used with a\nsingle File object.",
            "If the embed parameter is provided, it must be of type Embed and\nit must be a rich embed type. You cannot mix the embed parameter with the\nembeds parameter, which must be a list of Embed objects to send.",
            "content (str) – The content of the message to send.",
            "wait (bool) – Whether the server should wait before sending a response. This essentially\nmeans that the return type of this function changes from None to\na WebhookMessage if set to True.",
            "username (str) – The username to send with this message. If no username is provided\nthen the default username for the webhook is used.",
            "avatar_url (str) – The avatar URL to send with this message. If no avatar URL is provided\nthen the default avatar for the webhook is used. If this is not a\nstring then it is explicitly cast using str.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "file (File) – The file to upload. This cannot be mixed with files parameter.",
            "files (List[File]) – A list of files to send with the content. This cannot be mixed with the\nfile parameter.",
            "embed (Embed) – The rich embed for the content to send. This cannot be mixed with\nembeds parameter.",
            "embeds (List[Embed]) – A list of embeds to send with the content. Maximum of 10. This cannot\nbe mixed with the embed parameter.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message.",
            "New in version 1.4.",
            "thread (Snowflake) – The thread to send this message to.\n\nNew in version 2.0.",
            "The thread to send this message to.",
            "New in version 2.0.",
            "thread_name (str) – The name of the thread to create. Only works for forum channels.\n\nNew in version 2.0.",
            "The name of the thread to create. Only works for forum channels.",
            "New in version 2.0.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "If wait is True then the message that was sent, otherwise None.",
            "Optional[SyncWebhookMessage]",
            "HTTPException – Sending the message failed.",
            "NotFound – This webhook was not found.",
            "Forbidden – The authorization token for the webhook is incorrect.",
            "TypeError – You specified both embed and embeds or file and files",
            "ValueError – The length of embeds was invalid",
            "InvalidArgument – There was no token associated with this webhook, or you specified both\n    a thread to send to and a thread to create (the thread and thread_name parameters).",
            "Retrieves a single SyncWebhookMessage owned by this webhook.",
            "New in version 2.0.",
            "id (int) – The message ID to look for.",
            "thread_id (Optional[int]) – The ID of the thread that contains the message.",
            "The message asked for.",
            "SyncWebhookMessage",
            "NotFound – The specified message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "InvalidArgument – There was no token associated with this webhook.",
            "Returns an Asset for the avatar the webhook has.",
            "If the webhook does not have a traditional avatar, an asset for\nthe default avatar is returned instead.",
            "The text channel this webhook belongs to.",
            "If this is a partial webhook, then this will always return None.",
            "Returns the webhook’s creation time in UTC.",
            "Edits a message owned by this webhook.",
            "This is a lower level interface to WebhookMessage.edit() in case\nyou only have an ID.",
            "New in version 1.6.",
            "message_id (int) – The message ID to edit.",
            "content (Optional[str]) – The content to edit the message with or None to clear it.",
            "embeds (List[Embed]) – A list of embeds to edit the message with.",
            "embed (Optional[Embed]) – The embed to edit the message with. None suppresses the embeds.\nThis should not be mixed with the embeds parameter.",
            "file (File) – The file to upload. This cannot be mixed with files parameter.",
            "files (List[File]) – A list of files to send with the content. This cannot be mixed with the\nfile parameter.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message.\nSee abc.Messageable.send() for more information.",
            "thread (Optional[Snowflake]) – The thread that contains the message.",
            "suppress (bool) –",
            "HTTPException – Editing the message failed.",
            "Forbidden – Edited a message that is not yours.",
            "TypeError – You specified both embed and embeds or file and files",
            "ValueError – The length of embeds was invalid",
            "InvalidArgument – There was no token associated with this webhook.",
            "SyncWebhookMessage",
            "The guild this webhook belongs to.",
            "If this is a partial webhook, then this will always return None.",
            "Whether the webhook is authenticated with a bot token.\n:rtype: bool",
            "New in version 2.0.",
            "Whether the webhook is a “partial” webhook.\n:rtype: bool",
            "New in version 2.0.",
            "Deletes a message owned by this webhook.",
            "This is a lower level interface to WebhookMessage.delete() in case\nyou only have an ID.",
            "New in version 1.6.",
            "message_id (int) – The message ID to delete.",
            "thread_id (Optional[int]) – The ID of the thread that contains the message.",
            "HTTPException – Deleting the message failed.",
            "Forbidden – Deleted a message that is not yours.",
            "None",
            "Represents a message sent from your webhook.",
            "This allows you to edit or delete a message sent by your\nwebhook.",
            "This inherits from discord.Message with changes to\nedit() and delete() to work.",
            "New in version 2.0.",
            "state (ConnectionState) –",
            "channel (Union[TextChannel, VoiceChannel, StageChannel, Thread, DMChannel, PartialMessageable, GroupChannel]) –",
            "data (Message) –",
            "Edits the message.",
            "content (Optional[str]) – The content to edit the message with or None to clear it.",
            "embeds (List[Embed]) – A list of embeds to edit the message with.",
            "embed (Optional[Embed]) – The embed to edit the message with. None suppresses the embeds.\nThis should not be mixed with the embeds parameter.",
            "file (File) – The file to upload. This cannot be mixed with files parameter.",
            "files (List[File]) – A list of files to send with the content. This cannot be mixed with the\nfile parameter.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message.\nSee abc.Messageable.send() for more information.",
            "suppress (Optional[bool]) – Whether to suppress embeds for the message.",
            "The newly edited message.",
            "SyncWebhookMessage",
            "HTTPException – Editing the message failed.",
            "Forbidden – Edited a message that is not yours.",
            "TypeError – You specified both embed and embeds or file and files",
            "ValueError – The length of embeds was invalid",
            "InvalidArgument – There was no token associated with this webhook.",
            "Deletes the message.",
            "delay (Optional[float]) – If provided, the number of seconds to wait before deleting the message.\nThis blocks the thread.",
            "Forbidden – You do not have proper permissions to delete the message.",
            "NotFound – The message was deleted already.",
            "HTTPException – Deleting the message failed.",
            "None"
        ],
        "code": [
            "Webhook",
            "Guild.webhooks()",
            "TextChannel.webhooks()",
            "from_url()",
            "partial()",
            "from discord import Webhook\nimport aiohttp\n\nasync def foo():\n    async with aiohttp.ClientSession() as session:\n        webhook = Webhook.from_url('url-here', session=session)\n        await webhook.send('Hello World', username='Foo')",
            "SyncWebhook",
            "int",
            "WebhookType",
            "None",
            "str",
            "int",
            "int",
            "None",
            "abc.User",
            "str",
            "type",
            "WebhookType.channel_follower",
            "PartialWebhookGuild",
            "type",
            "WebhookType.channel_follower",
            "PartialWebhookChannel",
            "Webhook",
            "int",
            "str",
            "aiohttp.ClientSession",
            "str",
            "Webhook",
            "Webhook",
            "Webhook",
            "str",
            "aiohttp.ClientSession",
            "str",
            "Webhook",
            "Webhook",
            "is_authenticated()",
            "False",
            "bool",
            "True",
            "Webhook",
            "str",
            "bool",
            "True",
            "str",
            "bytes",
            "abc.Snowflake",
            "str",
            "bool",
            "True",
            "str(content)",
            "file",
            "File",
            "embed",
            "Embed",
            "embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "None",
            "WebhookMessage",
            "True",
            "WebhookType.application",
            "True",
            "str",
            "str",
            "str",
            "bool",
            "bool",
            "WebhookType.application",
            "File",
            "files",
            "File",
            "file",
            "Embed",
            "embeds",
            "Embed",
            "embed",
            "AllowedMentions",
            "discord.ui.View",
            "Snowflake",
            "str",
            "Snowflake",
            "float",
            "Poll",
            "wait",
            "True",
            "None",
            "WebhookMessage",
            "embed",
            "embeds",
            "file",
            "files",
            "embeds",
            "ephemeral",
            "thread_name",
            "thread",
            "applied_tags",
            "thread_name",
            "thread",
            "Asset",
            "None",
            "WebhookMessage",
            "int",
            "int",
            "WebhookMessage",
            "None",
            "bool",
            "bool",
            "WebhookMessage.edit()",
            "int",
            "str",
            "None",
            "Embed",
            "Embed",
            "None",
            "embeds",
            "Attachment",
            "[]",
            "File",
            "files",
            "File",
            "file",
            "AllowedMentions",
            "abc.Messageable.send()",
            "View",
            "None",
            "send()",
            "Snowflake",
            "bool",
            "WebhookMessage",
            "embed",
            "embeds",
            "file",
            "files",
            "embeds",
            "WebhookMessage.delete()",
            "int",
            "int",
            "discord.Message",
            "edit()",
            "delete()",
            "ConnectionState",
            "Union",
            "TextChannel",
            "VoiceChannel",
            "StageChannel",
            "Thread",
            "DMChannel",
            "PartialMessageable",
            "GroupChannel",
            "Message",
            "str",
            "None",
            "Embed",
            "Embed",
            "None",
            "embeds",
            "File",
            "files",
            "File",
            "file",
            "Attachment",
            "[]",
            "AllowedMentions",
            "abc.Messageable.send()",
            "View",
            "None",
            "bool",
            "WebhookMessage",
            "embed",
            "embeds",
            "file",
            "files",
            "embeds",
            "float",
            "Webhook",
            "int",
            "WebhookType",
            "None",
            "str",
            "int",
            "int",
            "None",
            "abc.User",
            "str",
            "type",
            "WebhookType.channel_follower",
            "PartialWebhookGuild",
            "type",
            "WebhookType.channel_follower",
            "PartialWebhookChannel",
            "Webhook",
            "int",
            "str",
            "requests.Session",
            "requests",
            "str",
            "Webhook",
            "Webhook",
            "Webhook",
            "str",
            "requests.Session",
            "requests",
            "str",
            "Webhook",
            "Webhook",
            "is_authenticated()",
            "False",
            "bool",
            "True",
            "SyncWebhook",
            "str",
            "bool",
            "True",
            "str",
            "bytes",
            "abc.Snowflake",
            "str",
            "bool",
            "True",
            "SyncWebhook",
            "str(content)",
            "file",
            "File",
            "embed",
            "Embed",
            "embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "None",
            "WebhookMessage",
            "True",
            "str",
            "str",
            "str",
            "bool",
            "File",
            "files",
            "File",
            "file",
            "Embed",
            "embeds",
            "Embed",
            "embed",
            "AllowedMentions",
            "Snowflake",
            "str",
            "bool",
            "wait",
            "True",
            "None",
            "SyncWebhookMessage",
            "embed",
            "embeds",
            "file",
            "files",
            "embeds",
            "thread",
            "thread_name",
            "SyncWebhookMessage",
            "int",
            "int",
            "SyncWebhookMessage",
            "Asset",
            "None",
            "WebhookMessage.edit()",
            "int",
            "str",
            "None",
            "Embed",
            "Embed",
            "None",
            "embeds",
            "File",
            "files",
            "File",
            "file",
            "AllowedMentions",
            "abc.Messageable.send()",
            "Snowflake",
            "embed",
            "embeds",
            "file",
            "files",
            "embeds",
            "None",
            "bool",
            "bool",
            "WebhookMessage.delete()",
            "int",
            "int",
            "discord.Message",
            "edit()",
            "delete()",
            "ConnectionState",
            "Union",
            "TextChannel",
            "VoiceChannel",
            "StageChannel",
            "Thread",
            "DMChannel",
            "PartialMessageable",
            "GroupChannel",
            "Message",
            "str",
            "None",
            "Embed",
            "Embed",
            "None",
            "embeds",
            "File",
            "files",
            "File",
            "file",
            "AllowedMentions",
            "abc.Messageable.send()",
            "bool",
            "SyncWebhookMessage",
            "embed",
            "embeds",
            "file",
            "files",
            "embeds",
            "float",
            "Webhook",
            "id",
            "type",
            "token",
            "guild_id",
            "channel_id",
            "user",
            "name",
            "source_guild",
            "source_channel",
            "url",
            "partial()",
            "from_url()",
            "fetch()",
            "delete()",
            "edit()",
            "send()",
            "avatar",
            "channel",
            "created_at",
            "fetch_message()",
            "guild",
            "is_authenticated()",
            "is_partial()",
            "edit_message()",
            "delete_message()",
            "WebhookMessage",
            "edit()",
            "delete()",
            "SyncWebhook",
            "id",
            "type",
            "token",
            "guild_id",
            "channel_id",
            "user",
            "name",
            "source_guild",
            "source_channel",
            "url",
            "partial()",
            "from_url()",
            "fetch()",
            "delete()",
            "edit()",
            "send()",
            "fetch_message()",
            "avatar",
            "channel",
            "created_at",
            "edit_message()",
            "guild",
            "is_authenticated()",
            "is_partial()",
            "delete_message()",
            "SyncWebhookMessage",
            "edit()",
            "delete()"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/webhooks.html"
    },
    {
        "title": "Discord Models#",
        "content": [
            "Models are classes that are received from Discord and are not meant to be created by\nthe user of the library.",
            "Danger",
            "The classes listed below are not intended to be created by users and are also\nread-only.",
            "For example, this means that you should not make your own User instances\nnor should you modify the User instance yourself.",
            "If you want to get one of these model classes instances they’d have to be through\nthe cache, and a common way of doing so is through the utils.find() function\nor attributes of model classes that you receive from the events specified in the\nEvent Reference.",
            "Note",
            "Nearly all classes here have __slots__ defined which means that it is\nimpossible to have dynamic attributes to the data classes.",
            "Represents a CDN asset on Discord.",
            "Returns the URL of the CDN asset.",
            "Returns the length of the CDN asset’s URL.",
            "Checks if the asset is equal to another asset.",
            "Checks if the asset is not equal to another asset.",
            "Returns the hash of the asset.",
            "url (str) –",
            "key (str) –",
            "animated (bool) –",
            "Returns the underlying URL of the asset.",
            "Returns the identifying key of the asset.",
            "Returns whether the asset is animated.",
            "bool",
            "Returns a new asset with the passed components replaced.",
            "size (int) – The new size of the asset.",
            "format (str) – The new format to change it to. Must be either\n‘webp’, ‘jpeg’, ‘jpg’, ‘png’, or ‘gif’ if it’s animated.",
            "static_format (str) – The new format to change it to if the asset isn’t animated.\nMust be either ‘webp’, ‘jpeg’, ‘jpg’, or ‘png’.",
            "The newly updated asset.",
            "Asset",
            "InvalidArgument – An invalid size or format was passed.",
            "Returns a new asset with the specified size.",
            "size (int) – The new size of the asset.",
            "The new updated asset.",
            "Asset",
            "InvalidArgument – The asset had an invalid size.",
            "Returns a new asset with the specified format.",
            "format (str) – The new format of the asset.",
            "The new updated asset.",
            "Asset",
            "InvalidArgument – The asset has an invalid format.",
            "Returns a new asset with the specified static format.",
            "This only changes the format if the underlying asset is\nnot animated. Otherwise, the asset is not changed.",
            "format (str) – The new static format of the asset.",
            "The new updated asset.",
            "Asset",
            "InvalidArgument – The asset had an invalid format.",
            "This function is a coroutine.",
            "Retrieves the content of this asset as a bytes object.",
            "The content of the asset.",
            "bytes",
            "DiscordException – There was no internal connection state.",
            "HTTPException – Downloading the asset failed.",
            "NotFound – The asset was deleted.",
            "This function is a coroutine.",
            "Saves this asset into a file-like object.",
            "fp (Union[io.BufferedIOBase, os.PathLike]) – The file-like object to save this attachment to or the filename\nto use. If a filename is passed then a file is created with that\nfilename and used instead.",
            "seek_begin (bool) – Whether to seek to the beginning of the file after saving is\nsuccessfully done.",
            "The number of bytes written.",
            "int",
            "DiscordException – There was no internal connection state.",
            "HTTPException – Downloading the asset failed.",
            "NotFound – The asset was deleted.",
            "Represents a Spotify listening activity from Discord. This is a special case of\nActivity that makes it easier to work with the Spotify integration.",
            "Checks if two activities are equal.",
            "Checks if two activities are not equal.",
            "Returns the activity’s hash.",
            "Returns the string ‘Spotify’.",
            "Returns the activity’s type. This is for compatibility with Activity.",
            "It always returns ActivityType.listening.",
            "When the user started listening in UTC.",
            "New in version 1.3.",
            "Returns the Spotify integration colour, as a Colour.",
            "There is an alias for this named color",
            "Returns the Spotify integration colour, as a Colour.",
            "There is an alias for this named colour",
            "The activity’s name. This will always return “Spotify”.",
            "The title of the song being played.",
            "The artists of the song being played.",
            "The artist of the song being played.",
            "This does not attempt to split the artist information into\nmultiple artists. Useful if there’s only a single artist.",
            "The album that the song being played belongs to.",
            "The album cover image URL from Spotify’s CDN.",
            "The track ID used by Spotify to identify this song.",
            "The track URL to listen on Spotify.",
            "New in version 2.0.",
            "When the user started playing this song in UTC.",
            "When the user will stop playing this song in UTC.",
            "The duration of the song being played.",
            "The party ID of the listening party.",
            "Represents a Discord user’s voice state.",
            "Indicates if the user is currently deafened by the guild.",
            "bool",
            "Indicates if the user is currently muted by the guild.",
            "bool",
            "Indicates if the user is currently muted by their own accord.",
            "bool",
            "Indicates if the user is currently deafened by their own accord.",
            "bool",
            "Indicates if the user is currently streaming via ‘Go Live’ feature.",
            "New in version 1.3.",
            "bool",
            "Indicates if the user is currently broadcasting video.",
            "bool",
            "Indicates if the user is suppressed from speaking.",
            "Only applies to stage channels.",
            "New in version 1.7.",
            "bool",
            "An aware datetime object that specifies the date and time in UTC that the member\nrequested to speak. It will be None if they are not requesting to speak\nanymore or have been accepted to speak.",
            "Only applicable to stage channels.",
            "New in version 1.7.",
            "Optional[datetime.datetime]",
            "Indicates if the user is currently in the AFK channel in the guild.",
            "bool",
            "The voice channel that the user is currently connected to. None if the user\nis not currently in a voice channel.",
            "Optional[Union[VoiceChannel, StageChannel]]",
            "data (VoiceStatePayload | GuildVoiceStatePayload) –",
            "channel (VocalGuildChannel | None) –",
            "Represents a partial messageable to aid with working messageable channels when\nonly a channel ID are present.",
            "The only way to construct this class is through Client.get_partial_messageable().",
            "Note that this class is trimmed down and has no rich attributes.",
            "New in version 2.0.",
            "Checks if two partial messageables are equal.",
            "Checks if two partial messageables are not equal.",
            "Returns the partial messageable’s hash.",
            "The channel ID associated with this partial messageable.",
            "int",
            "The channel type associated with this partial messageable, if given.",
            "Optional[ChannelType]",
            "state (ConnectionState) –",
            "id (int) –",
            "type (ChannelType | None) –",
            "Returns a bool indicating whether you have the permissions to send the object(s).",
            "Indicates whether you have the permissions to send the object(s).",
            "bool",
            "TypeError – An invalid type has been passed.",
            "This function is a coroutine.",
            "Retrieves a single Message from the destination.",
            "id (int) – The message ID to look for.",
            "The message asked for.",
            "Message",
            "NotFound – The specified message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "Returns an AsyncIterator that enables receiving the destination’s message history.",
            "You must have read_message_history permissions to use this.",
            "limit (Optional[int]) – The number of messages to retrieve.\nIf None, retrieves every message in the channel. Note, however,\nthat this would make it a slow operation.",
            "before (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages before this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages after this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "around (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages around this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.\nWhen using this argument, the maximum limit is 101. Note that if the limit is an\neven number, then this will return at most limit + 1 messages.",
            "oldest_first (Optional[bool]) – If set to True, return messages in oldest->newest order. Defaults to True if\nafter is specified, otherwise False.",
            "Message – The message with the message data parsed.",
            "Forbidden – You do not have permissions to get channel message history.",
            "HTTPException – The request to get message history failed.",
            "HistoryIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "All parameters are optional.",
            "This function is a coroutine.",
            "Retrieves all messages that are currently pinned in the channel.",
            "Note",
            "Due to a limitation with the Discord API, the Message\nobjects returned by this method do not contain complete\nMessage.reactions data.",
            "The messages that are currently pinned.",
            "List[Message]",
            "HTTPException – Retrieving the pinned messages failed.",
            "This function is a coroutine.",
            "Sends a message to the destination with the content given.",
            "The content must be a type that can convert to a string through str(content).\nIf the content is set to None (the default), then the embed parameter must\nbe provided.",
            "To upload a single file, the file parameter should be used with a\nsingle File object. To upload multiple files, the files\nparameter should be used with a list of File objects.\nSpecifying both parameters will lead to an exception.",
            "To upload a single embed, the embed parameter should be used with a\nsingle Embed object. To upload multiple embeds, the embeds\nparameter should be used with a list of Embed objects.\nSpecifying both parameters will lead to an exception.",
            "content (Optional[str]) – The content of the message to send.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "embed (Embed) – The rich embed for the content.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "nonce (Union[str, int]) – The nonce to use for sending this message. If the message was successfully sent,\nthen the message will have a nonce with this value.",
            "enforce_nonce (Optional[bool]) – Whether nonce is enforced to be validated.\n\nNew in version 2.5.",
            "Whether nonce is enforced to be validated.",
            "New in version 2.5.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent. If the deletion fails,\nthen it is silently ignored.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "New in version 1.4.",
            "reference (Union[Message, MessageReference, PartialMessage]) – A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.\n\nNew in version 1.6.",
            "A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.",
            "New in version 1.6.",
            "mention_author (Optional[bool]) – If set, overrides the replied_user attribute of allowed_mentions.\n\nNew in version 1.6.",
            "If set, overrides the replied_user attribute of allowed_mentions.",
            "New in version 1.6.",
            "view (discord.ui.View) – A Discord UI View to add to the message.",
            "embeds (List[Embed]) – A list of embeds to upload. Must be a maximum of 10.\n\nNew in version 2.0.",
            "A list of embeds to upload. Must be a maximum of 10.",
            "New in version 2.0.",
            "stickers (Sequence[Union[GuildSticker, StickerItem]]) – A list of stickers to upload. Must be a maximum of 3.\n\nNew in version 2.0.",
            "A list of stickers to upload. Must be a maximum of 3.",
            "New in version 2.0.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "silent (bool) – Whether to suppress push and desktop notifications for the message.\n\nNew in version 2.4.",
            "Whether to suppress push and desktop notifications for the message.",
            "New in version 2.4.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size,\n    you specified both file and files,\n    or you specified both embed and embeds,\n    or the reference object is not a Message,\n    MessageReference or PartialMessage.",
            "This function is a coroutine.",
            "Triggers a typing indicator to the destination.",
            "Typing indicator will go away after 10 seconds, or after a message is sent.",
            "None",
            "Returns a context manager that allows you to type for an indefinite period of time.",
            "This is useful for denoting long computations in your bot.\n:rtype: Typing",
            "Note",
            "This is both a regular context manager and an async context manager.\nThis means that both with and async with work with this.",
            "Example Usage:",
            "Creates a PartialMessage from the message ID.",
            "This is useful if you want to work with a message and only have its ID without\ndoing an unnecessary API call.",
            "message_id (int) – The message ID to create a partial message for.",
            "The partial message.",
            "PartialMessage"
        ],
        "code": [
            "User",
            "User",
            "utils.find()",
            "str",
            "str",
            "bool",
            "bool",
            "int",
            "str",
            "str",
            "Asset",
            "int",
            "Asset",
            "str",
            "Asset",
            "str",
            "Asset",
            "bytes",
            "bytes",
            "io.BufferedIOBase",
            "os.PathLike",
            "bool",
            "int",
            "Activity",
            "Activity",
            "ActivityType.listening",
            "Colour",
            "color",
            "Colour",
            "colour",
            "bool",
            "bool",
            "bool",
            "bool",
            "bool",
            "bool",
            "bool",
            "None",
            "datetime.datetime",
            "bool",
            "None",
            "VoiceChannel",
            "StageChannel",
            "Client.get_partial_messageable()",
            "int",
            "ChannelType",
            "bool",
            "bool",
            "Message",
            "int",
            "Message",
            "AsyncIterator",
            "read_message_history",
            "int",
            "None",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "bool",
            "True",
            "True",
            "after",
            "False",
            "Message",
            "counter = 0\nasync for message in channel.history(limit=200):\n    if message.author == client.user:\n        counter += 1",
            "messages = await channel.history(limit=123).flatten()\n# messages is now a list of Message...",
            "Message",
            "Message.reactions",
            "Message",
            "str(content)",
            "None",
            "embed",
            "file",
            "File",
            "files",
            "list",
            "File",
            "embed",
            "Embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "Embed",
            "File",
            "File",
            "str",
            "int",
            "bool",
            "nonce",
            "float",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "Message",
            "MessageReference",
            "PartialMessage",
            "Message",
            "to_reference()",
            "Message",
            "replied_user",
            "allowed_mentions",
            "mention_author",
            "bool",
            "replied_user",
            "allowed_mentions",
            "discord.ui.View",
            "Embed",
            "GuildSticker",
            "StickerItem",
            "bool",
            "bool",
            "Poll",
            "Message",
            "files",
            "file",
            "files",
            "embed",
            "embeds",
            "reference",
            "Message",
            "MessageReference",
            "PartialMessage",
            "None",
            "Typing",
            "with",
            "async with",
            "async with channel.typing():\n    # simulate something heavy\n    await asyncio.sleep(10)\n\nawait channel.send('done!')",
            "PartialMessage",
            "int",
            "PartialMessage"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Users#",
        "content": [
            "Represents your Discord user.",
            "Checks if two users are equal.",
            "Checks if two users are not equal.",
            "Return the user’s hash.",
            "Returns the user’s name with discriminator or global_name.",
            "The user’s username.",
            "str",
            "The user’s unique ID.",
            "int",
            "The user’s discriminator. This is given when the username has conflicts.",
            "Note",
            "If the user has migrated to the new username system, this will always be 0.",
            "str",
            "The user’s global name.",
            "New in version 2.5.",
            "str",
            "Specifies if the user is a bot account.",
            "bool",
            "Specifies if the user is a system user (i.e. represents Discord officially).",
            "New in version 1.3.",
            "bool",
            "Specifies if the user’s email is verified.",
            "bool",
            "The IETF language tag used to identify the language the user is using.",
            "Optional[str]",
            "Specifies if the user has MFA turned on and working.",
            "bool",
            "state (ConnectionState) –",
            "data (User) –",
            "This function is a coroutine.",
            "Edits the current profile of the client.",
            "Note",
            "To upload an avatar or banner, a bytes-like object must be passed in that\nrepresents the image being uploaded. If this is done through a file\nthen the file must be opened via open('some_filename', 'rb') and\nthe bytes-like object is given through the use of fp.read().",
            "The only image formats supported for uploading are JPEG, PNG, and GIF.",
            "Changed in version 2.0: The edit is no longer in-place, instead the newly edited client user is returned.",
            "Changed in version 2.6: The banner keyword-only parameter was added.",
            "username (str) – The new username you wish to change to.",
            "avatar (bytes) – A bytes-like object representing the image to upload.\nCould be None to denote no avatar.",
            "banner (bytes) – A bytes-like object representing the image to upload.\nCould be None to denote no banner.",
            "The newly edited client user.",
            "ClientUser",
            "HTTPException – Editing your profile failed.",
            "InvalidArgument – Wrong image format passed for avatar or banner.",
            "Returns the user’s accent color, if applicable.",
            "There is an alias for this named accent_colour.",
            "New in version 2.0.",
            "Note",
            "This information is only available via Client.fetch_user().",
            "Returns the user’s accent colour, if applicable.",
            "There is an alias for this named accent_color.",
            "New in version 2.0.",
            "Note",
            "This information is only available via Client.fetch_user().",
            "Returns an Asset for the avatar the user has.",
            "If the user does not have a traditional avatar, None is returned.\nIf you want the avatar that a user has displayed, consider display_avatar.",
            "Returns the user’s avatar decoration, if available.",
            "New in version 2.5.",
            "Returns the user’s banner asset, if available.",
            "New in version 2.0.",
            "Note",
            "This information is only available via Client.fetch_user().",
            "A property that returns a color denoting the rendered color\nfor the user. This always returns Colour.default().",
            "There is an alias for this named colour.",
            "A property that returns a colour denoting the rendered colour\nfor the user. This always returns Colour.default().",
            "There is an alias for this named color.",
            "Returns the user’s creation time in UTC.",
            "This is when the user’s Discord account was created.",
            "Returns the default avatar for a given user.\nThis is calculated by the user’s ID if they’re on the new username system, otherwise their discriminator.",
            "Returns the user’s display avatar.",
            "For regular users this is just their default avatar or uploaded avatar.",
            "New in version 2.0.",
            "Returns the user’s display name.\nThis will be their global name if set, otherwise their username.",
            "Checks whether the user is already migrated to global name.",
            "Returns a URL that allows the client to jump to the user.",
            "New in version 2.0.",
            "Returns a string that allows you to mention the given user.",
            "Checks if the user is mentioned in the specified message.",
            "message (Message) – The message to check if you’re mentioned in.",
            "Indicates if the user is mentioned in the message.",
            "bool",
            "The publicly available flags the user has.",
            "Represents a Discord user.",
            "Checks if two users are equal.",
            "Checks if two users are not equal.",
            "Return the user’s hash.",
            "Returns the user’s name with discriminator or global_name.",
            "The user’s username.",
            "str",
            "The user’s unique ID.",
            "int",
            "The user’s discriminator. This is given when the username has conflicts.",
            "Note",
            "If the user has migrated to the new username system, this will always be “0”.",
            "str",
            "The user’s global name.",
            "New in version 2.5.",
            "str",
            "Specifies if the user is a bot account.",
            "bool",
            "Specifies if the user is a system user (i.e. represents Discord officially).",
            "bool",
            "state (ConnectionState) –",
            "data (User) –",
            "Returns an AsyncIterator that enables receiving the destination’s message history.",
            "You must have read_message_history permissions to use this.",
            "limit (Optional[int]) – The number of messages to retrieve.\nIf None, retrieves every message in the channel. Note, however,\nthat this would make it a slow operation.",
            "before (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages before this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages after this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "around (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages around this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.\nWhen using this argument, the maximum limit is 101. Note that if the limit is an\neven number, then this will return at most limit + 1 messages.",
            "oldest_first (Optional[bool]) – If set to True, return messages in oldest->newest order. Defaults to True if\nafter is specified, otherwise False.",
            "Message – The message with the message data parsed.",
            "Forbidden – You do not have permissions to get channel message history.",
            "HTTPException – The request to get message history failed.",
            "HistoryIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "All parameters are optional.",
            "Returns a context manager that allows you to type for an indefinite period of time.",
            "This is useful for denoting long computations in your bot.\n:rtype: Typing",
            "Note",
            "This is both a regular context manager and an async context manager.\nThis means that both with and async with work with this.",
            "Example Usage:",
            "Returns the channel associated with this user if it exists.",
            "If this returns None, you can create a DM channel by calling the\ncreate_dm() coroutine function.",
            "The guilds that the user shares with the client.",
            "Note",
            "This will only return mutual guilds within the client’s internal cache.",
            "New in version 1.7.",
            "This function is a coroutine.",
            "Creates a DMChannel with this user.",
            "This should be rarely called, as this is done transparently for most\npeople.",
            "The channel that was created.",
            "DMChannel",
            "This function is a coroutine.",
            "Creates a test entitlement for the user.",
            "sku (Snowflake) – The SKU to create a test entitlement for.",
            "The created entitlement.",
            "Entitlement",
            "Returns the user’s accent color, if applicable.",
            "There is an alias for this named accent_colour.",
            "New in version 2.0.",
            "Note",
            "This information is only available via Client.fetch_user().",
            "Returns the user’s accent colour, if applicable.",
            "There is an alias for this named accent_color.",
            "New in version 2.0.",
            "Note",
            "This information is only available via Client.fetch_user().",
            "Returns an Asset for the avatar the user has.",
            "If the user does not have a traditional avatar, None is returned.\nIf you want the avatar that a user has displayed, consider display_avatar.",
            "Returns the user’s avatar decoration, if available.",
            "New in version 2.5.",
            "Returns the user’s banner asset, if available.",
            "New in version 2.0.",
            "Note",
            "This information is only available via Client.fetch_user().",
            "Returns a bool indicating whether you have the permissions to send the object(s).",
            "Indicates whether you have the permissions to send the object(s).",
            "bool",
            "TypeError – An invalid type has been passed.",
            "A property that returns a color denoting the rendered color\nfor the user. This always returns Colour.default().",
            "There is an alias for this named colour.",
            "A property that returns a colour denoting the rendered colour\nfor the user. This always returns Colour.default().",
            "There is an alias for this named color.",
            "Returns the user’s creation time in UTC.",
            "This is when the user’s Discord account was created.",
            "Returns the default avatar for a given user.\nThis is calculated by the user’s ID if they’re on the new username system, otherwise their discriminator.",
            "Returns the user’s display avatar.",
            "For regular users this is just their default avatar or uploaded avatar.",
            "New in version 2.0.",
            "Returns the user’s display name.\nThis will be their global name if set, otherwise their username.",
            "Returns an AsyncIterator that enables fetching the user’s entitlements.",
            "This is identical to Client.entitlements() with the user parameter.",
            "New in version 2.6.",
            "skus (list[abc.Snowflake] | None) – Limit the fetched entitlements to entitlements that are for these SKUs.",
            "before (abc.Snowflake | datetime.datetime | None) – Retrieves guilds before this date or object.\nIf a datetime is provided, it is recommended to use a UTC-aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (abc.Snowflake | datetime.datetime | None) – Retrieve guilds after this date or object.\nIf a datetime is provided, it is recommended to use a UTC-aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "limit (Optional[int]) – The number of entitlements to retrieve.\nIf None, retrieves every entitlement, which may be slow.\nDefaults to 100.",
            "exclude_ended (bool) – Whether to limit the fetched entitlements to those that have not ended.\nDefaults to False.",
            "Entitlement – The application’s entitlements.",
            "HTTPException – Retrieving the entitlements failed.",
            "This function is a coroutine.",
            "Retrieves a single Message from the destination.",
            "id (int) – The message ID to look for.",
            "The message asked for.",
            "Message",
            "NotFound – The specified message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "Checks whether the user is already migrated to global name.",
            "Returns a URL that allows the client to jump to the user.",
            "New in version 2.0.",
            "Returns a string that allows you to mention the given user.",
            "Checks if the user is mentioned in the specified message.",
            "message (Message) – The message to check if you’re mentioned in.",
            "Indicates if the user is mentioned in the message.",
            "bool",
            "This function is a coroutine.",
            "Retrieves all messages that are currently pinned in the channel.",
            "Note",
            "Due to a limitation with the Discord API, the Message\nobjects returned by this method do not contain complete\nMessage.reactions data.",
            "The messages that are currently pinned.",
            "List[Message]",
            "HTTPException – Retrieving the pinned messages failed.",
            "The publicly available flags the user has.",
            "This function is a coroutine.",
            "Sends a message to the destination with the content given.",
            "The content must be a type that can convert to a string through str(content).\nIf the content is set to None (the default), then the embed parameter must\nbe provided.",
            "To upload a single file, the file parameter should be used with a\nsingle File object. To upload multiple files, the files\nparameter should be used with a list of File objects.\nSpecifying both parameters will lead to an exception.",
            "To upload a single embed, the embed parameter should be used with a\nsingle Embed object. To upload multiple embeds, the embeds\nparameter should be used with a list of Embed objects.\nSpecifying both parameters will lead to an exception.",
            "content (Optional[str]) – The content of the message to send.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "embed (Embed) – The rich embed for the content.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "nonce (Union[str, int]) – The nonce to use for sending this message. If the message was successfully sent,\nthen the message will have a nonce with this value.",
            "enforce_nonce (Optional[bool]) – Whether nonce is enforced to be validated.\n\nNew in version 2.5.",
            "Whether nonce is enforced to be validated.",
            "New in version 2.5.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent. If the deletion fails,\nthen it is silently ignored.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "New in version 1.4.",
            "reference (Union[Message, MessageReference, PartialMessage]) – A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.\n\nNew in version 1.6.",
            "A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.",
            "New in version 1.6.",
            "mention_author (Optional[bool]) – If set, overrides the replied_user attribute of allowed_mentions.\n\nNew in version 1.6.",
            "If set, overrides the replied_user attribute of allowed_mentions.",
            "New in version 1.6.",
            "view (discord.ui.View) – A Discord UI View to add to the message.",
            "embeds (List[Embed]) – A list of embeds to upload. Must be a maximum of 10.\n\nNew in version 2.0.",
            "A list of embeds to upload. Must be a maximum of 10.",
            "New in version 2.0.",
            "stickers (Sequence[Union[GuildSticker, StickerItem]]) – A list of stickers to upload. Must be a maximum of 3.\n\nNew in version 2.0.",
            "A list of stickers to upload. Must be a maximum of 3.",
            "New in version 2.0.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "silent (bool) – Whether to suppress push and desktop notifications for the message.\n\nNew in version 2.4.",
            "Whether to suppress push and desktop notifications for the message.",
            "New in version 2.4.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size,\n    you specified both file and files,\n    or you specified both embed and embeds,\n    or the reference object is not a Message,\n    MessageReference or PartialMessage.",
            "This function is a coroutine.",
            "Triggers a typing indicator to the destination.",
            "Typing indicator will go away after 10 seconds, or after a message is sent.",
            "None"
        ],
        "code": [
            "str",
            "int",
            "str",
            "str",
            "bool",
            "bool",
            "bool",
            "str",
            "bool",
            "ConnectionState",
            "User",
            "open('some_filename', 'rb')",
            "fp.read()",
            "banner",
            "str",
            "bytes",
            "None",
            "bytes",
            "None",
            "ClientUser",
            "avatar",
            "banner",
            "accent_colour",
            "Client.fetch_user()",
            "accent_color",
            "Client.fetch_user()",
            "Asset",
            "None",
            "display_avatar",
            "Client.fetch_user()",
            "Colour.default()",
            "colour",
            "Colour.default()",
            "color",
            "Message",
            "bool",
            "str",
            "int",
            "str",
            "str",
            "bool",
            "bool",
            "ConnectionState",
            "User",
            "AsyncIterator",
            "read_message_history",
            "int",
            "None",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "bool",
            "True",
            "True",
            "after",
            "False",
            "Message",
            "counter = 0\nasync for message in channel.history(limit=200):\n    if message.author == client.user:\n        counter += 1",
            "messages = await channel.history(limit=123).flatten()\n# messages is now a list of Message...",
            "Typing",
            "with",
            "async with",
            "async with channel.typing():\n    # simulate something heavy\n    await asyncio.sleep(10)\n\nawait channel.send('done!')",
            "None",
            "create_dm()",
            "DMChannel",
            "DMChannel",
            "Snowflake",
            "Entitlement",
            "accent_colour",
            "Client.fetch_user()",
            "accent_color",
            "Client.fetch_user()",
            "Asset",
            "None",
            "display_avatar",
            "Client.fetch_user()",
            "bool",
            "bool",
            "Colour.default()",
            "colour",
            "Colour.default()",
            "color",
            "AsyncIterator",
            "Client.entitlements()",
            "user",
            "abc.Snowflake",
            "abc.Snowflake",
            "datetime.datetime",
            "abc.Snowflake",
            "datetime.datetime",
            "int",
            "None",
            "100",
            "bool",
            "False",
            "Entitlement",
            "Message",
            "int",
            "Message",
            "Message",
            "bool",
            "Message",
            "Message.reactions",
            "Message",
            "str(content)",
            "None",
            "embed",
            "file",
            "File",
            "files",
            "list",
            "File",
            "embed",
            "Embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "Embed",
            "File",
            "File",
            "str",
            "int",
            "bool",
            "nonce",
            "float",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "Message",
            "MessageReference",
            "PartialMessage",
            "Message",
            "to_reference()",
            "Message",
            "replied_user",
            "allowed_mentions",
            "mention_author",
            "bool",
            "replied_user",
            "allowed_mentions",
            "discord.ui.View",
            "Embed",
            "GuildSticker",
            "StickerItem",
            "bool",
            "bool",
            "Poll",
            "Message",
            "files",
            "file",
            "files",
            "embed",
            "embeds",
            "reference",
            "Message",
            "MessageReference",
            "PartialMessage",
            "None"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Messages#",
        "content": [
            "Represents an attachment from Discord.",
            "Returns the URL of the attachment.",
            "Checks if the attachment is equal to another attachment.",
            "Checks if the attachment is not equal to another attachment.",
            "Returns the hash of the attachment.",
            "Changed in version 1.7: Attachment can now be cast to str and is hashable.",
            "The attachment ID.",
            "int",
            "The attachment size in bytes.",
            "int",
            "The attachment’s height, in pixels. Only applicable to images and videos.",
            "Optional[int]",
            "The attachment’s width, in pixels. Only applicable to images and videos.",
            "Optional[int]",
            "The attachment’s filename.",
            "str",
            "The attachment’s title. This is equal to the original filename (without an extension)\nif special characters were filtered from it.",
            "New in version 2.6.",
            "Optional[str]",
            "The attachment URL. If the message this attachment was attached\nto is deleted, then this will 404.",
            "str",
            "The proxy URL. This is a cached version of the url in the\ncase of images. When the message is deleted, this URL might be valid for a few\nminutes or not valid at all.",
            "str",
            "The attachment’s media type.",
            "Optional[str]",
            "Whether the attachment is ephemeral or not.",
            "New in version 1.7.",
            "bool",
            "The attachment’s description.",
            "New in version 2.0.",
            "Optional[str]",
            "The duration of the audio file (currently for voice messages).",
            "New in version 2.5.",
            "Optional[float]",
            "The base64 encoded bytearray representing a sampled waveform (currently for voice messages).",
            "New in version 2.5.",
            "Optional[str]",
            "Extra attributes of the attachment.",
            "New in version 2.5.",
            "AttachmentFlags",
            "The unique signature of this attachment’s instance.",
            "New in version 2.5.",
            "str",
            "data (Attachment) –",
            "state (ConnectionState) –",
            "This attachment URL’s expiry time in UTC.",
            "The attachment URL’s issue time in UTC.",
            "Whether this attachment contains a spoiler.",
            "bool",
            "This function is a coroutine.",
            "Saves this attachment into a file-like object.",
            "fp (Union[io.BufferedIOBase, os.PathLike]) – The file-like object to save this attachment to or the filename\nto use. If a filename is passed then a file is created with that\nfilename and used instead.",
            "seek_begin (bool) – Whether to seek to the beginning of the file after saving is\nsuccessfully done.",
            "use_cached (bool) – Whether to use proxy_url rather than url when downloading\nthe attachment. This will allow attachments to be saved after deletion\nmore often, compared to the regular URL which is generally deleted right\nafter the message is deleted. Note that this can still fail to download\ndeleted attachments if too much time has passed, and it does not work\non some types of attachments.",
            "The number of bytes written.",
            "int",
            "HTTPException – Saving the attachment failed.",
            "NotFound – The attachment was deleted.",
            "This function is a coroutine.",
            "Retrieves the content of this attachment as a bytes object.",
            "New in version 1.1.",
            "use_cached (bool) – Whether to use proxy_url rather than url when downloading\nthe attachment. This will allow attachments to be saved after deletion\nmore often, compared to the regular URL which is generally deleted right\nafter the message is deleted. Note that this can still fail to download\ndeleted attachments if too much time has passed, and it does not work\non some types of attachments.",
            "The contents of the attachment.",
            "bytes",
            "HTTPException – Downloading the attachment failed.",
            "Forbidden – You do not have permissions to access this attachment",
            "NotFound – The attachment was deleted.",
            "This function is a coroutine.",
            "Converts the attachment into a File suitable for sending via\nabc.Messageable.send().",
            "New in version 1.3.",
            "use_cached (bool) – Whether to use proxy_url rather than url when downloading\nthe attachment. This will allow attachments to be saved after deletion\nmore often, compared to the regular URL which is generally deleted right\nafter the message is deleted. Note that this can still fail to download\ndeleted attachments if too much time has passed, and it does not work\non some types of attachments.\n\nNew in version 1.4.",
            "Whether to use proxy_url rather than url when downloading\nthe attachment. This will allow attachments to be saved after deletion\nmore often, compared to the regular URL which is generally deleted right\nafter the message is deleted. Note that this can still fail to download\ndeleted attachments if too much time has passed, and it does not work\non some types of attachments.",
            "New in version 1.4.",
            "spoiler (bool) – Whether the file is a spoiler.\n\nNew in version 1.4.",
            "Whether the file is a spoiler.",
            "New in version 1.4.",
            "The attachment as a file suitable for sending.",
            "File",
            "HTTPException – Downloading the attachment failed.",
            "Forbidden – You do not have permissions to access this attachment",
            "NotFound – The attachment was deleted.",
            "Represents a message from Discord.",
            "Checks if two messages are equal.",
            "Checks if two messages are not equal.",
            "Returns the message’s hash.",
            "Specifies if the message was done with text-to-speech.\nThis can only be accurately received in on_message() due to\na discord limitation.",
            "bool",
            "The type of message. In most cases this should not be checked, but it is helpful\nin cases where it might be a system message for system_content.",
            "MessageType",
            "A Member that sent the message. If channel is a\nprivate channel or the user has the left the guild, then it is a User instead.",
            "Union[Member, abc.User]",
            "The actual contents of the message.",
            "str",
            "The value used by the discord guild and the client to verify that the message is successfully sent.\nThis is not stored long term within Discord’s servers and is only used ephemerally.",
            "Optional[Union[str, int]]",
            "A list of embeds the message has.",
            "List[Embed]",
            "The TextChannel or Thread that the message was sent from.\nCould be a DMChannel or GroupChannel if it’s a private message.",
            "Union[TextChannel, Thread, DMChannel, GroupChannel, PartialMessageable]",
            "The message that this message references. This is only applicable to messages of\ntype MessageType.pins_add, crossposted messages created by a\nfollowed channel integration, or message replies.",
            "New in version 1.5.",
            "Optional[MessageReference]",
            "Specifies if the message mentions everyone.",
            "Note",
            "This does not check if the @everyone or the @here text is in the message itself.\nRather this boolean indicates if either the @everyone or the @here text is in the message\nand it did end up mentioning.",
            "bool",
            "A list of Member that were mentioned. If the message is in a private message\nthen the list will be of User instead. For messages that are not of type\nMessageType.default, this array can be used to aid in system messages.\nFor more information, see system_content.",
            "Warning",
            "The order of the mentions list is not in any particular order, so you should\nnot rely on it. This is a Discord limitation, not one with the library.",
            "List[abc.User]",
            "A list of abc.GuildChannel that were mentioned. If the message is in a private message\nthen the list is always empty.",
            "List[abc.GuildChannel]",
            "A list of Role that were mentioned. If the message is in a private message\nthen the list is always empty.",
            "List[Role]",
            "The message ID.",
            "int",
            "If this message was sent by a webhook, then this is the webhook ID’s that sent this\nmessage.",
            "Optional[int]",
            "A list of attachments given to a message.",
            "List[Attachment]",
            "Specifies if the message is currently pinned.",
            "bool",
            "Extra features of the message.",
            "New in version 1.3.",
            "MessageFlags",
            "Reactions to a message. Reactions can be either custom emoji or standard unicode emoji.",
            "List[Reaction]",
            "The activity associated with this message. Sent with Rich-Presence related messages that for\nexample, request joining, spectating, or listening to or with another member.",
            "It is a dictionary with the following optional keys:",
            "type: An integer denoting the type of message activity being requested.",
            "party_id: The party ID associated with the party.",
            "Optional[dict]",
            "The rich presence enabled application associated with this message.",
            "It is a dictionary with the following keys:",
            "id: A string representing the application’s ID.",
            "name: A string representing the application’s name.",
            "description: A string representing the application’s description.",
            "icon: A string representing the icon ID of the application.",
            "cover_image: A string representing the embed’s image asset ID.",
            "Optional[dict]",
            "A list of sticker items given to the message.",
            "New in version 1.6.",
            "List[StickerItem]",
            "A list of components in the message.",
            "New in version 2.0.",
            "List[Component]",
            "The guild that the message belongs to, if applicable.",
            "Optional[Guild]",
            "The interaction associated with the message, if applicable.",
            "Deprecated since version 2.6: Use interaction_metadata instead.",
            "Optional[MessageInteraction]",
            "The interaction metadata associated with the message, if applicable.",
            "New in version 2.6.",
            "Optional[InteractionMetadata]",
            "The thread created from this message, if applicable.",
            "New in version 2.0.",
            "Optional[Thread]",
            "The poll associated with this message, if applicable.",
            "New in version 2.6.",
            "Optional[Poll]",
            "The call information associated with this message, if applicable.",
            "New in version 2.6.",
            "Optional[MessageCall]",
            "state (ConnectionState) –",
            "channel (Union[TextChannel, VoiceChannel, StageChannel, Thread, DMChannel, PartialMessageable, GroupChannel]) –",
            "data (Message) –",
            "A property that returns an array of user IDs matched with\nthe syntax of <@user_id> in the message content.",
            "This allows you to receive the user IDs of mentioned users\neven in a private message context.",
            "A property that returns an array of channel IDs matched with\nthe syntax of <#channel_id> in the message content.",
            "A property that returns an array of role IDs matched with\nthe syntax of <@&role_id> in the message content.",
            "A property that returns the content in a “cleaned up”\nmanner. This basically means that mentions are transformed\ninto the way the client shows it. e.g. <#id> will transform\ninto #name.",
            "This will also transform @everyone and @here mentions into\nnon-mentions.",
            "Note",
            "This does not affect markdown. If you want to escape\nor remove markdown then use utils.escape_markdown() or utils.remove_markdown()\nrespectively, along with this function.",
            "The message’s creation time in UTC.",
            "An aware UTC datetime object containing the\nedited time of the message.",
            "Returns a URL that allows the client to jump to this message.",
            "Whether the message is a system message.",
            "A system message is a message that is constructed entirely by the Discord API\nin response to something.\n:rtype: bool",
            "New in version 1.3.",
            "A property that returns the content that is rendered\nregardless of the Message.type.",
            "In the case of MessageType.default and MessageType.reply,\nthis just returns the regular Message.content. Otherwise, this\nreturns an English message denoting the contents of the system message.",
            "This function is a coroutine.",
            "Deletes the message.",
            "Your own messages could be deleted without any proper permissions. However, to\ndelete other people’s messages, you need the manage_messages\npermission.",
            "Changed in version 1.1: Added the new delay keyword-only parameter.",
            "delay (Optional[float]) – If provided, the number of seconds to wait in the background\nbefore deleting the message. If the deletion fails then it is silently ignored.",
            "reason (Optional[str]) – The reason for deleting the message. Shows up on the audit log.",
            "Forbidden – You do not have proper permissions to delete the message.",
            "NotFound – The message was deleted already",
            "HTTPException – Deleting the message failed.",
            "None",
            "This function is a coroutine.",
            "Edits the message.",
            "The content must be able to be transformed into a string via str(content).",
            "Changed in version 1.3: The suppress keyword-only parameter was added.",
            "content (Optional[str]) – The new content to replace the message with.\nCould be None to remove the content.",
            "embed (Optional[Embed]) – The new embed to replace the original with.\nCould be None to remove the embed.",
            "embeds (List[Embed]) – The new embeds to replace the original with. Must be a maximum of 10.\nTo remove all embeds [] should be passed.\n\nNew in version 2.0.",
            "The new embeds to replace the original with. Must be a maximum of 10.\nTo remove all embeds [] should be passed.",
            "New in version 2.0.",
            "file (Sequence[File]) – A new file to add to the message.",
            "files (List[Sequence[File]]) – New files to add to the message.",
            "attachments (List[Attachment]) – A list of attachments to keep in the message. If [] is passed\nthen all attachments are removed.",
            "suppress (bool) – Whether to suppress embeds for the message. This removes\nall the embeds if set to True. If set to False\nthis brings the embeds back if they were suppressed.\nUsing this parameter requires manage_messages.",
            "delete_after (Optional[float]) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just edited. If the deletion fails,\nthen it is silently ignored.",
            "allowed_mentions (Optional[AllowedMentions]) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "New in version 1.4.",
            "view (Optional[View]) – The updated view to update this message with. If None is passed then\nthe view is removed.",
            "HTTPException – Editing the message failed.",
            "Forbidden – Tried to suppress a message without permissions or\n    edited a message’s content or embed that isn’t yours.",
            "InvalidArgument – You specified both embed and embeds,\n    specified both file and files, or either``file``\n    or files were of the wrong type.",
            "Message",
            "This function is a coroutine.",
            "Publishes this message to your announcement channel.",
            "You must have the send_messages permission to do this.",
            "If the message is not your own then the manage_messages\npermission is also needed.",
            "Forbidden – You do not have the proper permissions to publish this message.",
            "HTTPException – Publishing the message failed.",
            "None",
            "This function is a coroutine.",
            "Pins the message.",
            "You must have the manage_messages permission to do\nthis in a non-private channel context.",
            "reason (Optional[str]) – The reason for pinning the message. Shows up on the audit log.\n\nNew in version 1.4.",
            "The reason for pinning the message. Shows up on the audit log.",
            "New in version 1.4.",
            "Forbidden – You do not have permissions to pin the message.",
            "NotFound – The message or channel was not found or deleted.",
            "HTTPException – Pinning the message failed, probably due to the channel\n    having more than 50 pinned messages.",
            "None",
            "This function is a coroutine.",
            "Unpins the message.",
            "You must have the manage_messages permission to do\nthis in a non-private channel context.",
            "reason (Optional[str]) – The reason for unpinning the message. Shows up on the audit log.\n\nNew in version 1.4.",
            "The reason for unpinning the message. Shows up on the audit log.",
            "New in version 1.4.",
            "Forbidden – You do not have permissions to unpin the message.",
            "NotFound – The message or channel was not found or deleted.",
            "HTTPException – Unpinning the message failed.",
            "None",
            "This function is a coroutine.",
            "Add a reaction to the message.",
            "The emoji may be a unicode emoji or a custom guild Emoji.",
            "You must have the read_message_history permission\nto use this. If nobody else has reacted to the message using this\nemoji, the add_reactions permission is required.",
            "emoji (Union[Emoji, Reaction, PartialEmoji, str]) – The emoji to react with.",
            "HTTPException – Adding the reaction failed.",
            "Forbidden – You do not have the proper permissions to react to the message.",
            "NotFound – The emoji you specified was not found.",
            "InvalidArgument – The emoji parameter is invalid.",
            "None",
            "This function is a coroutine.",
            "Remove a reaction by the member from the message.",
            "The emoji may be a unicode emoji or a custom guild Emoji.",
            "If the reaction is not your own (i.e. member parameter is not you) then\nthe manage_messages permission is needed.",
            "The member parameter must represent a member and meet\nthe abc.Snowflake abc.",
            "emoji (Union[Emoji, Reaction, PartialEmoji, str]) – The emoji to remove.",
            "member (abc.Snowflake) – The member for which to remove the reaction.",
            "HTTPException – Removing the reaction failed.",
            "Forbidden – You do not have the proper permissions to remove the reaction.",
            "NotFound – The member or emoji you specified was not found.",
            "InvalidArgument – The emoji parameter is invalid.",
            "None",
            "This function is a coroutine.",
            "Clears a specific reaction from the message.",
            "The emoji may be a unicode emoji or a custom guild Emoji.",
            "You need the manage_messages permission to use this.",
            "New in version 1.3.",
            "emoji (Union[Emoji, Reaction, PartialEmoji, str]) – The emoji to clear.",
            "HTTPException – Clearing the reaction failed.",
            "Forbidden – You do not have the proper permissions to clear the reaction.",
            "NotFound – The emoji you specified was not found.",
            "InvalidArgument – The emoji parameter is invalid.",
            "None",
            "This function is a coroutine.",
            "Removes all the reactions from the message.",
            "You need the manage_messages permission to use this.",
            "HTTPException – Removing the reactions failed.",
            "Forbidden – You do not have the proper permissions to remove all the reactions.",
            "None",
            "This function is a coroutine.",
            "Creates a public thread from this message.",
            "You must have create_public_threads in order to\ncreate a public thread from a message.",
            "The channel this message belongs in must be a TextChannel.",
            "New in version 2.0.",
            "name (str) – The name of the thread.",
            "auto_archive_duration (Optional[int]) – The duration in minutes before a thread is automatically archived for inactivity.\nIf not provided, the channel’s default auto archive duration is used.",
            "slowmode_delay (Optional[int]) – Specifies the slowmode rate limit for user in this thread, in seconds.\nA value of 0 disables slowmode. The maximum value possible is 21600.",
            "The created thread.",
            "Thread",
            "Forbidden – You do not have permissions to create a thread.",
            "HTTPException – Creating the thread failed.",
            "InvalidArgument – This message does not have guild info attached.",
            "This function is a coroutine.",
            "A shortcut method to abc.Messageable.send() to reply to the\nMessage.",
            "New in version 1.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size, or\n    you specified both file and files.",
            "content (str | None) –",
            "This function is a coroutine.",
            "Immediately ends the poll associated with this message. Only doable by the poll’s owner.",
            "New in version 2.6.",
            "The updated message.",
            "Message",
            "Forbidden – You do not have permissions to end this poll.",
            "HTTPException – Ending this poll failed.",
            "Creates a MessageReference from the current message.",
            "New in version 1.6.",
            "fail_if_not_exists (bool) – Whether replying using the message reference should raise HTTPException\nif the message no longer exists or Discord could not fetch the message.\n\nNew in version 1.7.",
            "Whether replying using the message reference should raise HTTPException\nif the message no longer exists or Discord could not fetch the message.",
            "New in version 1.7.",
            "The reference to this message.",
            "MessageReference",
            "A special sentinel type that denotes whether the\nresolved message referenced message had since been deleted.",
            "The purpose of this class is to separate referenced messages that could not be\nfetched and those that were previously fetched but have since been deleted.",
            "New in version 1.6.",
            "parent (MessageReference) –",
            "The message ID of the deleted referenced message.",
            "The channel ID of the deleted referenced message.",
            "The guild ID of the deleted referenced message.",
            "Represents a reaction to a message.",
            "Depending on the way this object was created, some of the attributes can\nhave a value of None.",
            "Checks if two reactions are equal. This works by checking if the emoji\nis the same. So two messages with the same reaction will be considered\n“equal”.",
            "Checks if two reactions are not equal.",
            "Returns the reaction’s hash.",
            "Returns the string form of the reaction’s emoji.",
            "The reaction emoji. May be a custom emoji, or a unicode emoji.",
            "Union[Emoji, PartialEmoji, str]",
            "The combined total of normal and super reactions for this emoji.",
            "int",
            "If the user sent this as a normal reaction.",
            "bool",
            "If the user sent this as a super reaction.",
            "bool",
            "Message this reaction is for.",
            "Message",
            "Whether this reaction is a burst (super) reaction.",
            "bool",
            "message (Message) –",
            "data (ReactionPayload) –",
            "emoji (PartialEmoji | Emoji | str | None) –",
            "Returns an AsyncIterator representing the users that have reacted to the message.",
            "The after parameter must represent a member\nand meet the abc.Snowflake abc.",
            "limit (Optional[int]) – The maximum number of results to return.\nIf not provided, returns all the users who\nreacted to the message.",
            "after (Optional[abc.Snowflake]) – For pagination, reactions are sorted by member.",
            "type (Optional[ReactionType]) – The type of reaction to get users for. Defaults to normal.",
            "Union[User, Member] – The member (if retrievable) or the user that has reacted\nto this message. The case where it can be a Member is\nin a guild message context. Sometimes it can be a User\nif the member has left the guild.",
            "HTTPException – Getting the users for the reaction failed.",
            "ReactionIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "Getting super reactors:",
            "Returns a list possible Colour this super reaction can be.",
            "There is an alias for this named burst_colors.",
            "Returns a list possible Colour this super reaction can be.",
            "There is an alias for this named burst_colours.",
            "Returns ReactionCountDetails for the individual counts of normal and super reactions made.",
            "If this is a custom emoji.",
            "bool",
            "This function is a coroutine.",
            "Remove the reaction by the provided User from the message.",
            "If the reaction is not your own (i.e. user parameter is not you) then\nthe manage_messages permission is needed.",
            "The user parameter must represent a user or member and meet\nthe abc.Snowflake abc.",
            "user (abc.Snowflake) – The user or member from which to remove the reaction.",
            "HTTPException – Removing the reaction failed.",
            "Forbidden – You do not have the proper permissions to remove the reaction.",
            "NotFound – The user you specified, or the reaction’s message was not found.",
            "None",
            "This function is a coroutine.",
            "Clears this reaction from the message.",
            "You need the manage_messages permission to use this.\n:rtype: None",
            "New in version 1.3.",
            "HTTPException – Clearing the reaction failed.",
            "Forbidden – You do not have the proper permissions to clear the reaction.",
            "NotFound – The emoji you specified was not found.",
            "InvalidArgument – The emoji parameter is invalid.",
            "Represents a breakdown of the normal and burst reaction counts for the emoji.",
            "The number of normal reactions for this emoji.",
            "int",
            "The number of super reactions for this emoji.",
            "bool",
            "data (ReactionCountDetails) –"
        ],
        "code": [
            "str",
            "int",
            "int",
            "int",
            "int",
            "str",
            "filename",
            "str",
            "str",
            "url",
            "str",
            "str",
            "bool",
            "str",
            "float",
            "str",
            "AttachmentFlags",
            "str",
            "Attachment",
            "ConnectionState",
            "bool",
            "io.BufferedIOBase",
            "os.PathLike",
            "bool",
            "bool",
            "proxy_url",
            "url",
            "int",
            "bytes",
            "bool",
            "proxy_url",
            "url",
            "bytes",
            "File",
            "abc.Messageable.send()",
            "bool",
            "proxy_url",
            "url",
            "bool",
            "File",
            "on_message()",
            "bool",
            "system_content",
            "MessageType",
            "Member",
            "channel",
            "User",
            "Member",
            "abc.User",
            "str",
            "str",
            "int",
            "Embed",
            "TextChannel",
            "Thread",
            "DMChannel",
            "GroupChannel",
            "TextChannel",
            "Thread",
            "DMChannel",
            "GroupChannel",
            "PartialMessageable",
            "MessageType.pins_add",
            "MessageReference",
            "@everyone",
            "@here",
            "@everyone",
            "@here",
            "bool",
            "Member",
            "User",
            "MessageType.default",
            "system_content",
            "abc.User",
            "abc.GuildChannel",
            "abc.GuildChannel",
            "Role",
            "Role",
            "int",
            "int",
            "Attachment",
            "bool",
            "MessageFlags",
            "Reaction",
            "type",
            "party_id",
            "dict",
            "id",
            "name",
            "description",
            "icon",
            "cover_image",
            "dict",
            "StickerItem",
            "Component",
            "Guild",
            "interaction_metadata",
            "MessageInteraction",
            "InteractionMetadata",
            "Thread",
            "Poll",
            "MessageCall",
            "ConnectionState",
            "Union",
            "TextChannel",
            "VoiceChannel",
            "StageChannel",
            "Thread",
            "DMChannel",
            "PartialMessageable",
            "GroupChannel",
            "Message",
            "<@user_id>",
            "<#channel_id>",
            "<@&role_id>",
            "<#id>",
            "#name",
            "utils.escape_markdown()",
            "utils.remove_markdown()",
            "bool",
            "Message.type",
            "MessageType.default",
            "MessageType.reply",
            "Message.content",
            "manage_messages",
            "delay",
            "float",
            "str",
            "str(content)",
            "suppress",
            "str",
            "None",
            "Embed",
            "None",
            "Embed",
            "[]",
            "File",
            "File",
            "Attachment",
            "[]",
            "bool",
            "True",
            "False",
            "manage_messages",
            "float",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "View",
            "None",
            "embed",
            "embeds",
            "file",
            "files",
            "files",
            "send_messages",
            "manage_messages",
            "None",
            "manage_messages",
            "str",
            "manage_messages",
            "str",
            "Emoji",
            "read_message_history",
            "add_reactions",
            "Emoji",
            "Reaction",
            "PartialEmoji",
            "str",
            "None",
            "Emoji",
            "member",
            "manage_messages",
            "member",
            "abc.Snowflake",
            "Emoji",
            "Reaction",
            "PartialEmoji",
            "str",
            "abc.Snowflake",
            "Emoji",
            "manage_messages",
            "Emoji",
            "Reaction",
            "PartialEmoji",
            "str",
            "manage_messages",
            "None",
            "create_public_threads",
            "TextChannel",
            "str",
            "int",
            "int",
            "0",
            "21600",
            "Thread",
            "abc.Messageable.send()",
            "Message",
            "Message",
            "files",
            "file",
            "files",
            "Message",
            "MessageReference",
            "bool",
            "HTTPException",
            "MessageReference",
            "MessageReference",
            "None",
            "Emoji",
            "PartialEmoji",
            "str",
            "int",
            "bool",
            "bool",
            "Message",
            "bool",
            "AsyncIterator",
            "after",
            "abc.Snowflake",
            "int",
            "abc.Snowflake",
            "ReactionType",
            "User",
            "Member",
            "Member",
            "User",
            "# I do not actually recommend doing this.\nasync for user in reaction.users():\n    await channel.send(f'{user} has reacted with {reaction.emoji}!')",
            "users = await reaction.users().flatten()\n# users is now a list of User...\nwinner = random.choice(users)\nawait channel.send(f'{winner} has won the raffle.')",
            "users = await reaction.users(type=ReactionType.burst).flatten()",
            "Colour",
            "burst_colors",
            "Colour",
            "burst_colours",
            "ReactionCountDetails",
            "bool",
            "User",
            "user",
            "manage_messages",
            "user",
            "abc.Snowflake",
            "abc.Snowflake",
            "None",
            "manage_messages",
            "None",
            "int",
            "bool",
            "ReactionCountDetails"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Monetization#",
        "content": [
            "Represents a Discord SKU (stock-keeping unit).",
            "New in version 2.5.",
            "The SKU’s ID.",
            "int",
            "The type of SKU.",
            "SKUType",
            "The ID of the application this SKU belongs to.",
            "int",
            "The name of the SKU.",
            "str",
            "The SKU’s slug.",
            "str",
            "The SKU’s flags.",
            "SKUFlags",
            "data (SKU) –",
            "Returns the URL for the SKU.",
            "str",
            "Represents a Discord entitlement.",
            "New in version 2.5.",
            "The entitlement’s ID.",
            "int",
            "The ID of the SKU this entitlement is for.",
            "int",
            "The ID of the application this entitlement belongs to.",
            "int",
            "The ID of the user that owns this entitlement.",
            "Union[int, MISSING]",
            "The type of entitlement.",
            "EntitlementType",
            "Whether the entitlement has been deleted.",
            "bool",
            "When the entitlement starts.",
            "Union[datetime.datetime, MISSING]",
            "When the entitlement expires.",
            "Union[datetime.datetime, MISSING]",
            "The ID of the guild that owns this entitlement.",
            "Union[int, MISSING]",
            "Whether or not this entitlement has been consumed.\nThis will always be False for entitlements that are not\nof type EntitlementType.consumable.",
            "bool",
            "data (Entitlement) –",
            "state (ConnectionState) –",
            "This function is a coroutine.",
            "Consumes this entitlement.",
            "This can only be done on entitlements of type EntitlementType.consumable.",
            "TypeError – The entitlement is not consumable.",
            "HTTPException – Consuming the entitlement failed.",
            "None",
            "This function is a coroutine.",
            "Deletes a test entitlement.",
            "A test entitlement is an entitlement that was created using Guild.create_test_entitlement() or User.create_test_entitlement().",
            "HTTPException – Deleting the entitlement failed.",
            "None"
        ],
        "code": [
            "int",
            "SKUType",
            "int",
            "str",
            "str",
            "SKUFlags",
            "SKU",
            "str",
            "int",
            "int",
            "int",
            "int",
            "MISSING",
            "EntitlementType",
            "bool",
            "datetime.datetime",
            "MISSING",
            "datetime.datetime",
            "MISSING",
            "int",
            "MISSING",
            "False",
            "EntitlementType.consumable",
            "bool",
            "Entitlement",
            "ConnectionState",
            "EntitlementType.consumable",
            "None",
            "Guild.create_test_entitlement()",
            "User.create_test_entitlement()",
            "None"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Guild#",
        "content": [
            "Represents a Discord guild.",
            "This is referred to as a “server” in the official Discord UI.",
            "Checks if two guilds are equal.",
            "Checks if two guilds are not equal.",
            "Returns the guild’s hash.",
            "Returns the guild’s name.",
            "The guild name.",
            "str",
            "All emojis that the guild owns.",
            "Tuple[Emoji, …]",
            "All stickers that the guild owns.",
            "New in version 2.0.",
            "Tuple[GuildSticker, …]",
            "The timeout to get sent to the AFK channel.",
            "int",
            "The channel that denotes the AFK channel. None if it doesn’t exist.",
            "Optional[VoiceChannel]",
            "The guild’s ID.",
            "int",
            "Indicates if the guild invites are disabled.",
            "bool",
            "The guild owner’s ID. Use Guild.owner instead.",
            "int",
            "Indicates if the guild is unavailable. If this is True then the\nreliability of other attributes outside of Guild.id is slim and they might\nall be None. It is best to not do anything with the guild if it is unavailable.",
            "Check the on_guild_unavailable() and on_guild_available() events.",
            "bool",
            "The maximum amount of presences for the guild.",
            "Optional[int]",
            "The maximum amount of members for the guild.",
            "Note",
            "This attribute is only available via Client.fetch_guild().",
            "Optional[int]",
            "The maximum amount of users in a video channel.",
            "New in version 1.4.",
            "Optional[int]",
            "The guild’s description.",
            "Optional[str]",
            "Indicates the guild’s two-factor authorisation level. If this value is 0 then\nthe guild does not require 2FA for their administrative members. If the value is\n1 then they do.",
            "int",
            "The guild’s verification level.",
            "VerificationLevel",
            "The guild’s explicit content filter.",
            "ContentFilter",
            "The guild’s notification settings.",
            "NotificationLevel",
            "A list of features that the guild has. The features that a guild can have are\nsubject to arbitrary change by Discord. You can find a catalog of guild features\nhere.",
            "List[str]",
            "The premium tier for this guild. Corresponds to “Nitro Server” in the official UI.\nThe number goes from 0 to 3 inclusive.",
            "int",
            "The number of “boosts” this guild currently has.",
            "int",
            "Indicates if the guild has premium progress bar enabled.",
            "New in version 2.0.",
            "bool",
            "The preferred locale for the guild. Used when filtering Server Discovery\nresults to a specific language.",
            "Optional[str]",
            "The guild’s NSFW level.",
            "New in version 2.0.",
            "NSFWLevel",
            "The approximate number of members in the guild. This is None unless the guild is obtained\nusing Client.fetch_guild() with with_counts=True.",
            "New in version 2.0.",
            "Optional[int]",
            "The approximate number of members currently active in the guild.\nThis includes idle, dnd, online, and invisible members. Offline members are excluded.\nThis is None unless the guild is obtained using Client.fetch_guild()\nwith with_counts=True.",
            "New in version 2.0.",
            "Optional[int]",
            "data (Guild) –",
            "state (ConnectionState) –",
            "Retrieves an AsyncIterator that enables receiving the guild’s members. In order to use this,\nIntents.members() must be enabled.",
            "Note",
            "This method is an API call. For general usage, consider members instead.",
            "New in version 1.3.",
            "All parameters are optional.",
            "limit (Optional[int]) – The number of members to retrieve. Defaults to 1000.\nPass None to fetch all members. Note that this is potentially slow.",
            "after (Optional[Union[abc.Snowflake, datetime.datetime]]) – Retrieve members after this date or object.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "Member – The member with the member data parsed.",
            "ClientException – The members intent is not enabled.",
            "HTTPException – Getting the members failed.",
            "MemberIterator",
            "Examples",
            "Usage",
            "Flattening into a list",
            "Returns an AsyncIterator that enables receiving the guild’s audit logs.",
            "You must have the view_audit_log permission to use this.",
            "See API documentation\nfor more information about the before and after parameters.",
            "limit (Optional[int]) – The number of entries to retrieve. If None retrieve all entries.",
            "before (Union[abc.Snowflake, datetime.datetime]) – Retrieve entries before this date or entry.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Union[abc.Snowflake, datetime.datetime]) – Retrieve entries after this date or entry.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "user (abc.Snowflake) – The moderator to filter entries from.",
            "action (AuditLogAction) – The action to filter with.",
            "AuditLogEntry – The audit log entry.",
            "Forbidden – You are not allowed to fetch audit logs",
            "HTTPException – An error occurred while fetching the audit logs.",
            "AuditLogIterator",
            "Examples",
            "Getting the first 100 entries:",
            "Getting entries for a specific action:",
            "Getting entries made by a specific user:",
            "A list of channels that belong to this guild.",
            "A list of threads that you have permission to view.",
            "New in version 2.0.",
            "Returns a URL that allows the client to jump to the guild.",
            "New in version 2.0.",
            "Indicates if the guild is a ‘large’ guild.",
            "A large guild is defined as having more than large_threshold count\nmembers, which for this library is set to the maximum of 250.",
            "A list of voice channels that belong to this guild.",
            "This is sorted by the position and are in UI order from top to bottom.",
            "A list of stage channels that belong to this guild.",
            "New in version 1.7.",
            "This is sorted by the position and are in UI order from top to bottom.",
            "A list of forum channels that belong to this guild.",
            "New in version 2.0.",
            "This is sorted by the position and are in UI order from top to bottom.",
            "Similar to Client.user except an instance of Member.\nThis is essentially used to get the member version of yourself.",
            "Returns the VoiceClient associated with this guild, if any.",
            "A list of text channels that belong to this guild.",
            "This is sorted by the position and are in UI order from top to bottom.",
            "A list of categories that belong to this guild.",
            "This is sorted by the position and are in UI order from top to bottom.",
            "Returns every CategoryChannel and their associated channels.",
            "These channels and categories are sorted in the official Discord UI order.",
            "If the channels do not have a category, then the first element of the tuple is\nNone.",
            "The categories and their associated channels.",
            "List[Tuple[Optional[CategoryChannel], List[abc.GuildChannel]]]",
            "Returns a channel or thread with the given ID.",
            "New in version 2.0.",
            "channel_id (int) – The ID to search for.",
            "The returned channel or thread or None if not found.",
            "Optional[Union[Thread, abc.GuildChannel]]",
            "Returns a channel with the given ID.",
            "Note",
            "This does not search for threads.",
            "channel_id (int) – The ID to search for.",
            "The returned channel or None if not found.",
            "Optional[abc.GuildChannel]",
            "Returns a thread with the given ID.",
            "New in version 2.0.",
            "thread_id (int) – The ID to search for.",
            "The returned thread or None if not found.",
            "Optional[Thread]",
            "Returns the guild’s channel used for system messages.",
            "If no channel is set, then this returns None.",
            "Returns the guild’s system channel settings.",
            "Return’s the guild’s channel used for the rules.\nThe guild must be a Community guild.",
            "If no channel is set, then this returns None.",
            "New in version 1.3.",
            "Return’s the guild’s channel where admins and\nmoderators of the guilds receive notices from Discord. The guild must be a\nCommunity guild.",
            "If no channel is set, then this returns None.",
            "New in version 1.4.",
            "The maximum number of emoji slots this guild has.",
            "The maximum number of sticker slots this guild has.",
            "New in version 2.0.",
            "The maximum bitrate for voice channels this guild can have.",
            "The maximum number of bytes files can have when uploaded to this guild.",
            "A list of members that belong to this guild.",
            "Returns a member with the given ID.",
            "user_id (int) – The ID to search for.",
            "The member or None if not found.",
            "Optional[Member]",
            "A list of members who have “boosted” this guild.",
            "Returns a list of the guild’s roles in hierarchy order.",
            "The first element of this list will be the lowest role in the\nhierarchy.",
            "Returns a role with the given ID.",
            "role_id (int) – The ID to search for.",
            "The role or None if not found.",
            "Optional[Role]",
            "Gets the @everyone role that all members have by default.",
            "Gets the premium subscriber role, AKA “boost” role, in this guild.",
            "New in version 1.6.",
            "Gets the role associated with this client’s user, if any.",
            "New in version 1.6.",
            "Returns a list of the guild’s stage instances that\nare currently running.",
            "New in version 2.0.",
            "Returns a stage instance with the given ID.",
            "New in version 2.0.",
            "stage_instance_id (int) – The ID to search for.",
            "The stage instance or None if not found.",
            "Optional[StageInstance]",
            "The member that owns the guild.",
            "Returns the guild’s icon asset, if available.",
            "Returns the guild’s banner asset, if available.",
            "Returns the guild’s invite splash asset, if available.",
            "Returns the guild’s discovery splash asset, if available.",
            "Returns the true member count regardless of it being loaded fully or not.",
            "Warning",
            "Due to a Discord limitation, in order for this attribute to remain up-to-date and\naccurate, it requires Intents.members to be specified.",
            "Returns a boolean indicating if the guild is “chunked”.",
            "A chunked guild means that member_count is equal to the\nnumber of members stored in the internal members cache.",
            "If this value returns False, then you should request for\noffline members.",
            "Returns the shard ID for this guild if applicable.",
            "Returns the guild’s creation time in UTC.",
            "Returns a boolean indicating if the guild invites are disabled.",
            "Returns the first member found that matches the name provided.",
            "The name can have an optional discriminator argument, e.g. “Jake#0001”\nor “Jake” will both do the lookup. However, the former will give a more\nprecise result. Note that the discriminator must have all 4 digits\nfor this to work.",
            "If a nickname is passed, then it is looked up via the nickname. Note\nhowever, that a nickname + discriminator combo will not look up the nickname\nbut rather the username + discriminator combo due to nickname + discriminator\nnot being unique.",
            "If no member is found, None is returned.",
            "name (str) – The name of the member to lookup with an optional discriminator.",
            "The member in this guild with the associated name. If not found\nthen None is returned.",
            "Optional[Member]",
            "This function is a coroutine.",
            "Creates a TextChannel for the guild.",
            "Note that you need the manage_channels permission\nto create the channel.",
            "The overwrites parameter can be used to create a ‘secret’\nchannel upon creation. This parameter expects a dict of\noverwrites with the target (either a Member or a Role)\nas the key and a PermissionOverwrite as the value.",
            "Note",
            "Creating a channel of a specified position will not update the position of\nother channels to follow suit. A follow-up call to edit()\nwill be required to update the position of the channel in the channel list.",
            "name (str) – The channel’s name.",
            "overwrites (Dict[Union[Role, Member, Snowflake], PermissionOverwrite]) – The overwrites to apply to the channel. Useful for creating secret channels.",
            "category (Optional[CategoryChannel]) – The category to place the newly created channel under.\nThe permissions will be automatically synced to category if no\noverwrites are provided.",
            "position (int) – The position in the channel list. This is a number that starts\nat 0. e.g. the top channel is position 0.",
            "topic (str) – The new channel’s topic.",
            "slowmode_delay (int) – Specifies the slowmode rate limit for user in this channel, in seconds.\nThe maximum value possible is 21600.",
            "nsfw (bool) – To mark the channel as NSFW or not.",
            "reason (Optional[str]) – The reason for creating this channel. Shows up on the audit log.",
            "The channel that was just created.",
            "TextChannel",
            "Forbidden – You do not have the proper permissions to create this channel.",
            "HTTPException – Creating the channel failed.",
            "InvalidArgument – The permission overwrite information is not in proper form.",
            "Examples",
            "Creating a basic channel:",
            "Creating a “secret” channel:",
            "This function is a coroutine.",
            "This is similar to create_text_channel() except makes a VoiceChannel instead.",
            "name (str) – The channel’s name.",
            "overwrites (Dict[Union[Role, Member, Snowflake], PermissionOverwrite]) – The overwrites to apply to the channel. Useful for creating secret channels.",
            "category (Optional[CategoryChannel]) – The category to place the newly created channel under.\nThe permissions will be automatically synced to category if no\noverwrites are provided.",
            "position (int) – The position in the channel list. This is a number that starts\nat 0. e.g. the top channel is position 0.",
            "bitrate (int) – The channel’s preferred audio bitrate in bits per second.",
            "user_limit (int) – The channel’s limit for number of members that can be in a voice channel.",
            "rtc_region (Optional[VoiceRegion]) – The region for the voice channel’s voice communication.\nA value of None indicates automatic voice region detection.\n\nNew in version 1.7.",
            "The region for the voice channel’s voice communication.\nA value of None indicates automatic voice region detection.",
            "New in version 1.7.",
            "video_quality_mode (VideoQualityMode) – The camera video quality for the voice channel’s participants.\n\nNew in version 2.0.",
            "The camera video quality for the voice channel’s participants.",
            "New in version 2.0.",
            "reason (Optional[str]) – The reason for creating this channel. Shows up on the audit log.",
            "The channel that was just created.",
            "VoiceChannel",
            "Forbidden – You do not have the proper permissions to create this channel.",
            "HTTPException – Creating the channel failed.",
            "InvalidArgument – The permission overwrite information is not in proper form.",
            "This function is a coroutine.",
            "This is similar to create_text_channel() except makes a StageChannel instead.",
            "New in version 1.7.",
            "name (str) – The channel’s name.",
            "topic (str) – The new channel’s topic.",
            "overwrites (Dict[Union[Role, Member, Snowflake], PermissionOverwrite]) – The overwrites to apply to the channel. Useful for creating secret channels.",
            "category (Optional[CategoryChannel]) – The category to place the newly created channel under.\nThe permissions will be automatically synced to category if no\noverwrites are provided.",
            "position (int) – The position in the channel list. This is a number that starts\nat 0. e.g. the top channel is position 0.",
            "reason (Optional[str]) – The reason for creating this channel. Shows up on the audit log.",
            "The channel that was just created.",
            "StageChannel",
            "Forbidden – You do not have the proper permissions to create this channel.",
            "HTTPException – Creating the channel failed.",
            "InvalidArgument – The permission overwrite information is not in proper form.",
            "This function is a coroutine.",
            "Creates a ForumChannel for the guild.",
            "Note that you need the manage_channels permission\nto create the channel.",
            "The overwrites parameter can be used to create a ‘secret’\nchannel upon creation. This parameter expects a dict of\noverwrites with the target (either a Member or a Role)\nas the key and a PermissionOverwrite as the value.",
            "Note",
            "Creating a channel of a specified position will not update the position of\nother channels to follow suit. A follow-up call to edit()\nwill be required to update the position of the channel in the channel list.",
            "name (str) – The channel’s name.",
            "overwrites (Dict[Union[Role, Member, Snowflake], PermissionOverwrite]) – The overwrites to apply to the channel. Useful for creating secret channels.",
            "category (Optional[CategoryChannel]) – The category to place the newly created channel under.\nThe permissions will be automatically synced to category if no\noverwrites are provided.",
            "position (int) – The position in the channel list. This is a number that starts\nat 0. e.g. the top channel is position 0.",
            "topic (str) – The new channel’s topic.",
            "slowmode_delay (int) – Specifies the slowmode rate limit for user in this channel, in seconds.\nThe maximum value possible is 21600.",
            "nsfw (bool) – To mark the channel as NSFW or not.",
            "reason (Optional[str]) – The reason for creating this channel. Shows up on the audit log.",
            "default_reaction_emoji (Optional[Emoji | int | str]) – The default reaction emoji.\nCan be a unicode emoji or a custom emoji in the forms:\nEmoji, snowflake ID, string representation (eg. ‘<a:emoji_name:emoji_id>’).\n\nNew in version v2.5.",
            "The default reaction emoji.\nCan be a unicode emoji or a custom emoji in the forms:\nEmoji, snowflake ID, string representation (eg. ‘<a:emoji_name:emoji_id>’).",
            "New in version v2.5.",
            "The channel that was just created.",
            "ForumChannel",
            "Forbidden – You do not have the proper permissions to create this channel.",
            "HTTPException – Creating the channel failed.",
            "InvalidArgument – The argument is not in proper form.",
            "Examples",
            "Creating a basic channel:",
            "Creating a “secret” channel:",
            "This function is a coroutine.",
            "Same as create_text_channel() except makes a CategoryChannel instead.",
            "Note",
            "The category parameter is not supported in this function since categories\ncannot have categories.",
            "The channel that was just created.",
            "CategoryChannel",
            "Forbidden – You do not have the proper permissions to create this channel.",
            "HTTPException – Creating the channel failed.",
            "InvalidArgument – The permission overwrite information is not in proper form.",
            "name (str) –",
            "overwrites (dict[Role | Member, PermissionOverwrite]) –",
            "reason (str | None) –",
            "position (int) –",
            "This function is a coroutine.",
            "Same as create_text_channel() except makes a CategoryChannel instead.",
            "Note",
            "The category parameter is not supported in this function since categories\ncannot have categories.",
            "The channel that was just created.",
            "CategoryChannel",
            "Forbidden – You do not have the proper permissions to create this channel.",
            "HTTPException – Creating the channel failed.",
            "InvalidArgument – The permission overwrite information is not in proper form.",
            "name (str) –",
            "overwrites (dict[Role | Member, PermissionOverwrite]) –",
            "reason (str | None) –",
            "position (int) –",
            "This function is a coroutine.",
            "Leaves the guild.\n:rtype: None",
            "Note",
            "You cannot leave the guild that you own, you must delete it instead\nvia delete().",
            "HTTPException – Leaving the guild failed.",
            "This function is a coroutine.",
            "Deletes the guild. You must be the guild owner to delete the\nguild.",
            "HTTPException – Deleting the guild failed.",
            "Forbidden – You do not have permissions to delete the guild.",
            "None",
            "This function is a coroutine.",
            "Set whether it is required to have MFA enabled on your account\nto perform moderation actions. You must be the guild owner to do this.",
            "required (bool) – Whether MFA should be required to perform moderation actions.",
            "reason (str) – The reason to show up in the audit log.",
            "HTTPException – The operation failed.",
            "Forbidden – You are not the owner of the guild.",
            "None",
            "This function is a coroutine.",
            "Edits the guild.",
            "You must have the manage_guild permission\nto edit the guild.",
            "Changed in version 1.4: The rules_channel and public_updates_channel keyword-only parameters were added.",
            "Changed in version 2.0: The discovery_splash and community keyword-only parameters were added.",
            "Changed in version 2.0: The newly updated guild is returned.",
            "name (str) – The new name of the guild.",
            "description (Optional[str]) – The new description of the guild. Could be None for no description.\nThis is only available to guilds that contain PUBLIC in Guild.features.",
            "icon (bytes) – A bytes-like object representing the icon. Only PNG/JPEG is supported.\nGIF is only available to guilds that contain ANIMATED_ICON in Guild.features.\nCould be None to denote removal of the icon.",
            "banner (bytes) – A bytes-like object representing the banner.\nCould be None to denote removal of the banner. This is only available to guilds that contain\nBANNER in Guild.features.",
            "splash (bytes) – A bytes-like object representing the invite splash.\nOnly PNG/JPEG supported. Could be None to denote removing the\nsplash. This is only available to guilds that contain INVITE_SPLASH\nin Guild.features.",
            "discovery_splash (bytes) – A bytes-like object representing the discovery splash.\nOnly PNG/JPEG supported. Could be None to denote removing the\nsplash. This is only available to guilds that contain DISCOVERABLE\nin Guild.features.",
            "community (bool) – Whether the guild should be a Community guild. If set to True, both rules_channel\nand public_updates_channel parameters are required.",
            "afk_channel (Optional[VoiceChannel]) – The new channel that is the AFK channel. Could be None for no AFK channel.",
            "afk_timeout (int) – The number of seconds until someone is moved to the AFK channel.",
            "owner (Member) – The new owner of the guild to transfer ownership to. Note that you must\nbe owner of the guild to do this.",
            "verification_level (VerificationLevel) – The new verification level for the guild.",
            "default_notifications (NotificationLevel) – The new default notification level for the guild.",
            "explicit_content_filter (ContentFilter) – The new explicit content filter for the guild.",
            "system_channel (Optional[TextChannel]) – The new channel that is used for the system channel. Could be None for no system channel.",
            "system_channel_flags (SystemChannelFlags) – The new system channel settings to use with the new system channel.",
            "preferred_locale (str) – The new preferred locale for the guild. Used as the primary language in the guild.\nIf set, this must be an ISO 639 code, e.g. en-US or ja or zh-CN.",
            "rules_channel (Optional[TextChannel]) – The new channel that is used for rules. This is only available to\nguilds that contain PUBLIC in Guild.features. Could be None for no rules\nchannel.",
            "public_updates_channel (Optional[TextChannel]) – The new channel that is used for public updates from Discord. This is only available to\nguilds that contain PUBLIC in Guild.features. Could be None for no\npublic updates channel.",
            "premium_progress_bar_enabled (bool) – Whether the guild should have premium progress bar enabled.",
            "disable_invites (bool) – Whether the guild should have server invites enabled or disabled.",
            "reason (Optional[str]) – The reason for editing this guild. Shows up on the audit log.",
            "Forbidden – You do not have permissions to edit the guild.",
            "HTTPException – Editing the guild failed.",
            "InvalidArgument – The image format passed in to icon is invalid. It must be\n    PNG or JPG. This is also raised if you are not the owner of the\n    guild and request an ownership transfer.",
            "The newly updated guild. Note that this has the same limitations as\nmentioned in Client.fetch_guild() and may not have full data.",
            "Guild",
            "This function is a coroutine.",
            "Retrieves all abc.GuildChannel that the guild has.",
            "Note",
            "This method is an API call. For general usage, consider channels instead.",
            "New in version 1.2.",
            "All channels in the guild.",
            "Sequence[abc.GuildChannel]",
            "InvalidData – An unknown channel type was received from Discord.",
            "HTTPException – Retrieving the channels failed.",
            "This function is a coroutine.",
            "Returns a list of active Thread that the client can access.",
            "This includes both private and public threads.",
            "New in version 2.0.",
            "The active threads",
            "List[Thread]",
            "HTTPException – The request to get the active threads failed.",
            "Search for guild members whose usernames or nicknames start with the query string. Unlike fetch_members(), this does not require Intents.members().",
            "Note",
            "This method is an API call. For general usage, consider filtering members instead.",
            "New in version 2.6.",
            "query (str) – Searches for usernames and nicknames that start with this string, case-insensitive.",
            "limit (int) – The maximum number of members to retrieve, up to 1000.",
            "The list of members that have matched the query.",
            "List[Member]",
            "HTTPException – Getting the members failed.",
            "This function is a coroutine.",
            "Retrieves a Member from a guild ID, and a member ID.",
            "Note",
            "This method is an API call. If you have Intents.members and\nmember cache enabled, consider get_member() instead.",
            "member_id (int) – The member’s ID to fetch from.",
            "The member from the member ID.",
            "Member",
            "Forbidden – You do not have access to the guild.",
            "HTTPException – Fetching the member failed.",
            "This function is a coroutine.",
            "Retrieves the BanEntry for a user.",
            "You must have the ban_members permission\nto get this information.",
            "user (abc.Snowflake) – The user to get ban information from.",
            "The BanEntry object for the specified user.",
            "BanEntry",
            "Forbidden – You do not have proper permissions to get the information.",
            "NotFound – This user is not banned.",
            "HTTPException – An error occurred while fetching the information.",
            "This function is a coroutine.",
            "Retrieves a abc.GuildChannel or Thread with the specified ID.",
            "Note",
            "This method is an API call. For general usage, consider get_channel_or_thread() instead.",
            "New in version 2.0.",
            "The channel from the ID.",
            "Union[abc.GuildChannel, Thread]",
            "InvalidData – An unknown channel type was received from Discord\n    or the guild the channel belongs to is not the same\n    as the one in this object points to.",
            "HTTPException – Retrieving the channel failed.",
            "NotFound – Invalid Channel ID.",
            "Forbidden – You do not have permission to fetch this channel.",
            "channel_id (int) –",
            "This function is a coroutine.",
            "Retrieves an AsyncIterator that enables receiving the guild’s bans. In order to use this, you must\nhave the ban_members permission.\nUsers will always be returned in ascending order sorted by user ID.\nIf both the before and after parameters are provided, only before is respected.",
            "Changed in version 2.5: The before. and after parameters were changed. They are now of the type abc.Snowflake instead of\nSnowflakeTime to comply with the discord api.",
            "Changed in version 2.0: The limit, before. and after parameters were added. Now returns a BanIterator instead\nof a list of BanEntry objects.",
            "All parameters are optional.",
            "limit (Optional[int]) – The number of bans to retrieve. Defaults to 1000.",
            "before (Optional[abc.Snowflake]) – Retrieve bans before the given user.",
            "after (Optional[abc.Snowflake]) – Retrieve bans after the given user.",
            "BanEntry – The ban entry for the ban.",
            "Forbidden – You do not have proper permissions to get the information.",
            "HTTPException – An error occurred while fetching the information.",
            "BanIterator",
            "Examples",
            "Usage",
            "Flattening into a list",
            "This function is a coroutine.",
            "Prunes the guild from its inactive members.",
            "The inactive members are denoted if they have not logged on in\ndays number of days and have no roles.",
            "You must have the kick_members permission\nto use this.",
            "To check how many members you would prune without actually pruning,\nsee the estimate_pruned_members() function.",
            "To prune members that have specific roles see the roles parameter.",
            "Changed in version 1.4: The roles keyword-only parameter was added.",
            "days (int) – The number of days before counting as inactive.",
            "reason (Optional[str]) – The reason for doing this action. Shows up on the audit log.",
            "compute_prune_count (bool) – Whether to compute the prune count. This defaults to True\nwhich makes it prone to timeouts in very large guilds. In order\nto prevent timeouts, you must set this to False. If this is\nset to False, then this function will always return None.",
            "roles (List[abc.Snowflake]) – A list of abc.Snowflake that represent roles to include in the pruning process. If a member\nhas a role that is not specified, they’ll be excluded.",
            "Forbidden – You do not have permissions to prune members.",
            "HTTPException – An error occurred while pruning members.",
            "InvalidArgument – An integer was not passed for days.",
            "The number of members pruned. If compute_prune_count is False\nthen this returns None.",
            "Optional[int]",
            "This function is a coroutine.",
            "Gets the list of templates from this guild.",
            "Requires manage_guild permissions.",
            "New in version 1.7.",
            "The templates for this guild.",
            "List[Template]",
            "Forbidden – You don’t have permissions to get the templates.",
            "This function is a coroutine.",
            "Gets the list of webhooks from this guild.",
            "Requires manage_webhooks permissions.",
            "The webhooks for this guild.",
            "List[Webhook]",
            "Forbidden – You don’t have permissions to get the webhooks.",
            "This function is a coroutine.",
            "Similar to prune_members() except instead of actually\npruning members, it returns how many members it would prune\nfrom the guild had it been called.",
            "days (int) – The number of days before counting as inactive.",
            "roles (List[abc.Snowflake]) – A list of abc.Snowflake that represent roles to include in the estimate. If a member\nhas a role that is not specified, they’ll be excluded.\n\nNew in version 1.7.",
            "A list of abc.Snowflake that represent roles to include in the estimate. If a member\nhas a role that is not specified, they’ll be excluded.",
            "New in version 1.7.",
            "The number of members estimated to be pruned.",
            "int",
            "Forbidden – You do not have permissions to prune members.",
            "HTTPException – An error occurred while fetching the prune members estimate.",
            "InvalidArgument – An integer was not passed for days.",
            "This function is a coroutine.",
            "Returns a list of all active instant invites from the guild.",
            "You must have the manage_guild permission to get\nthis information.",
            "The list of invites that are currently active.",
            "List[Invite]",
            "Forbidden – You do not have proper permissions to get the information.",
            "HTTPException – An error occurred while fetching the information.",
            "This function is a coroutine.",
            "Creates a template for the guild.",
            "You must have the manage_guild permission to\ndo this.",
            "New in version 1.7.",
            "name (str) – The name of the template.",
            "description (str) – The description of the template.",
            "Template",
            "This function is a coroutine.",
            "Attaches an integration to the guild.",
            "You must have the manage_guild permission to\ndo this.",
            "New in version 1.4.",
            "type (str) – The integration type (e.g. Twitch).",
            "id (int) – The integration ID.",
            "Forbidden – You do not have permission to create the integration.",
            "HTTPException – The account could not be found.",
            "None",
            "This function is a coroutine.",
            "Returns a list of all integrations attached to the guild.",
            "You must have the manage_guild permission to\ndo this.",
            "New in version 1.4.",
            "The list of integrations that are attached to the guild.",
            "List[Integration]",
            "Forbidden – You do not have permission to create the integration.",
            "HTTPException – Fetching the integrations failed.",
            "This function is a coroutine.",
            "Retrieves a list of all Stickers for the guild.",
            "New in version 2.0.",
            "Note",
            "This method is an API call. For general usage, consider stickers instead.",
            "HTTPException – An error occurred fetching the stickers.",
            "The retrieved stickers.",
            "List[GuildSticker]",
            "This function is a coroutine.",
            "Retrieves a custom Sticker from the guild.",
            "New in version 2.0.",
            "Note",
            "This method is an API call.\nFor general usage, consider iterating over stickers instead.",
            "sticker_id (int) – The sticker’s ID.",
            "The retrieved sticker.",
            "GuildSticker",
            "NotFound – The sticker requested could not be found.",
            "HTTPException – An error occurred fetching the sticker.",
            "This function is a coroutine.",
            "Creates a Sticker for the guild.",
            "You must have manage_emojis_and_stickers permission to\ndo this.",
            "New in version 2.0.",
            "name (str) – The sticker name. Must be 2 to 30 characters.",
            "description (Optional[str]) – The sticker’s description. If used, must be 2 to 100 characters.",
            "emoji (str) – The name of a unicode emoji that represents the sticker’s expression.",
            "file (File) – The file of the sticker to upload.",
            "reason (str) – The reason for creating this sticker. Shows up on the audit log.",
            "The created sticker.",
            "GuildSticker",
            "Forbidden – You are not allowed to create stickers.",
            "HTTPException – An error occurred creating a sticker.",
            "TypeError – The parameters for the sticker are not correctly formatted.",
            "This function is a coroutine.",
            "Deletes the custom Sticker from the guild.",
            "You must have manage_emojis_and_stickers permission to\ndo this.",
            "New in version 2.0.",
            "sticker (abc.Snowflake) – The sticker you are deleting.",
            "reason (Optional[str]) – The reason for deleting this sticker. Shows up on the audit log.",
            "Forbidden – You are not allowed to delete stickers.",
            "HTTPException – An error occurred deleting the sticker.",
            "None",
            "This function is a coroutine.",
            "Retrieves all custom Emojis from the guild.",
            "Note",
            "This method is an API call. For general usage, consider emojis instead.",
            "HTTPException – An error occurred fetching the emojis.",
            "The retrieved emojis.",
            "List[Emoji]",
            "This function is a coroutine.",
            "Retrieves a custom Emoji from the guild.",
            "Note",
            "This method is an API call.\nFor general usage, consider iterating over emojis instead.",
            "emoji_id (int) – The emoji’s ID.",
            "The retrieved emoji.",
            "Emoji",
            "NotFound – The emoji requested could not be found.",
            "HTTPException – An error occurred fetching the emoji.",
            "This function is a coroutine.",
            "Creates a custom Emoji for the guild.",
            "There is currently a limit of 50 static and animated emojis respectively per guild,\nunless the guild has the MORE_EMOJI feature which extends the limit to 200.",
            "You must have the manage_emojis permission to\ndo this.",
            "name (str) – The emoji name. Must be at least 2 characters.",
            "image (bytes) – The bytes-like object representing the image data to use.\nOnly JPG, PNG and GIF images are supported.",
            "roles (List[Role]) – A list of Roles that can use this emoji. Leave empty to make it available to everyone.",
            "reason (Optional[str]) – The reason for creating this emoji. Shows up on the audit log.",
            "Forbidden – You are not allowed to create emojis.",
            "HTTPException – An error occurred creating an emoji.",
            "The created emoji.",
            "Emoji",
            "This function is a coroutine.",
            "Deletes the custom Emoji from the guild.",
            "You must have manage_emojis permission to\ndo this.",
            "emoji (abc.Snowflake) – The emoji you are deleting.",
            "reason (Optional[str]) – The reason for deleting this emoji. Shows up on the audit log.",
            "Forbidden – You are not allowed to delete emojis.",
            "HTTPException – An error occurred deleting the emoji.",
            "None",
            "This function is a coroutine.",
            "Retrieves all Role that the guild has.",
            "Note",
            "This method is an API call. For general usage, consider roles instead.",
            "New in version 1.3.",
            "All roles in the guild.",
            "List[Role]",
            "HTTPException – Retrieving the roles failed.",
            "This function is a coroutine.",
            "Creates a Role for the guild.",
            "All fields are optional.",
            "You must have the manage_roles permission to\ndo this.",
            "Changed in version 1.6: Can now pass int to colour keyword-only parameter.",
            "name (str) – The role name. Defaults to ‘new role’.",
            "permissions (Permissions) – The permissions to have. Defaults to no permissions.",
            "colour (Union[Colour, int]) – The colour for the role. Defaults to Colour.default().\nThis is aliased to color as well.",
            "hoist (bool) – Indicates if the role should be shown separately in the member list.\nDefaults to False.",
            "mentionable (bool) – Indicates if the role should be mentionable by others.\nDefaults to False.",
            "reason (Optional[str]) – The reason for creating this role. Shows up on the audit log.",
            "icon (Optional[bytes]) – A bytes-like object representing the icon. Only PNG/JPEG/WebP is supported.\nIf this argument is passed, unicode_emoji is set to None.\nOnly available to guilds that contain ROLE_ICONS in Guild.features.",
            "unicode_emoji (Optional[str]) – The role’s unicode emoji. If this argument is passed, icon is set to None.\nOnly available to guilds that contain ROLE_ICONS in Guild.features.",
            "color (Colour | int) –",
            "The newly created role.",
            "Role",
            "Forbidden – You do not have permissions to create the role.",
            "HTTPException – Creating the role failed.",
            "InvalidArgument – An invalid keyword argument was given.",
            "This function is a coroutine.",
            "Bulk edits a list of Role in the guild.",
            "You must have the manage_roles permission to\ndo this.",
            "New in version 1.4.",
            "Example:",
            "positions (Dict[Role, int]) – A dict of Role to int to change the positions\nof each given role.",
            "reason (Optional[str]) – The reason for editing the role positions. Shows up on the audit log.",
            "A list of all the roles in the guild.",
            "List[Role]",
            "Forbidden – You do not have permissions to move the roles.",
            "HTTPException – Moving the roles failed.",
            "InvalidArgument – An invalid keyword argument was given.",
            "This function is a coroutine.",
            "Kicks a user from the guild.",
            "The user must meet the abc.Snowflake abc.",
            "You must have the kick_members permission to\ndo this.",
            "user (abc.Snowflake) – The user to kick from their guild.",
            "reason (Optional[str]) – The reason the user got kicked.",
            "Forbidden – You do not have the proper permissions to kick.",
            "HTTPException – Kicking failed.",
            "None",
            "This function is a coroutine.",
            "Bans a user from the guild.",
            "The user must meet the abc.Snowflake abc.",
            "You must have the ban_members permission to\ndo this.",
            "user (abc.Snowflake) – The user to ban from their guild.",
            "delete_message_seconds (Optional[int]) – The number of seconds worth of messages to delete from\nthe user in the guild. The minimum is 0 and the maximum\nis 604800 (i.e. 7 days). The default is 0.",
            "reason (Optional[str]) – The reason the user got banned.",
            "Forbidden – You do not have the proper permissions to ban.",
            "HTTPException – Banning failed.",
            "None",
            "This function is a coroutine.",
            "Bulk ban users from the guild.",
            "The users must meet the abc.Snowflake abc.",
            "You must have the ban_members permission to\ndo this.",
            "Example Usage:",
            "*users (abc.Snowflake) – An argument list of users to ban from the guild, up to 200.",
            "delete_message_seconds (Optional[int]) – The number of seconds worth of messages to delete from\nthe user in the guild. The minimum is 0 and the maximum\nis 604800 (i.e. 7 days). The default is 0.",
            "reason (Optional[str]) – The reason the users were banned.",
            "Returns two lists: the first contains members that were successfully banned, while the second is members that could not be banned.",
            "Tuple[List[abc.Snowflake], List[abc.Snowflake]]",
            "ValueError – You tried to ban more than 200 users.",
            "Forbidden – You do not have the proper permissions to ban.",
            "HTTPException – No users were banned.",
            "This function is a coroutine.",
            "Unbans a user from the guild.",
            "The user must meet the abc.Snowflake abc.",
            "You must have the ban_members permission to\ndo this.",
            "user (abc.Snowflake) – The user to unban.",
            "reason (Optional[str]) – The reason for doing this action. Shows up on the audit log.",
            "Forbidden – You do not have the proper permissions to unban.",
            "HTTPException – Unbanning failed.",
            "None",
            "This function is a coroutine.",
            "Returns the guild’s special vanity invite.",
            "The guild must have VANITY_URL in features.",
            "You must have the manage_guild permission to use\nthis as well.",
            "The special vanity invite. If None then the guild does not\nhave a vanity invite set.",
            "Optional[Invite]",
            "Forbidden – You do not have the proper permissions to get this.",
            "HTTPException – Retrieving the vanity invite failed.",
            "This function is a coroutine.",
            "Returns the widget of the guild.",
            "Note",
            "The guild must have the widget enabled to get this information.",
            "The guild’s widget.",
            "Widget",
            "Forbidden – The widget for this guild is disabled.",
            "HTTPException – Retrieving the widget failed.",
            "This function is a coroutine.",
            "Edits the widget of the guild.",
            "You must have the manage_guild permission to\nuse this",
            "New in version 2.0.",
            "enabled (bool) – Whether to enable the widget for the guild.",
            "channel (Optional[Snowflake]) – The new widget channel. None removes the widget channel.",
            "Forbidden – You do not have permission to edit the widget.",
            "HTTPException – Editing the widget failed.",
            "None",
            "This function is a coroutine.",
            "Requests all members that belong to this guild. In order to use this,\nIntents.members() must be enabled.",
            "This is a websocket operation and can be slow.",
            "New in version 1.5.",
            "cache (bool) – Whether to cache the members as well.",
            "ClientException – The members intent is not enabled.",
            "None",
            "This function is a coroutine.",
            "Request members that belong to this guild whose username starts with\nthe query given.",
            "This is a websocket operation and can be slow.",
            "New in version 1.3.",
            "query (Optional[str]) – The string that the username’s start with.",
            "user_ids (Optional[List[int]]) – List of user IDs to search for. If the user ID is not in the guild then it won’t be returned.\n\nNew in version 1.4.",
            "List of user IDs to search for. If the user ID is not in the guild then it won’t be returned.",
            "New in version 1.4.",
            "limit (Optional[int]) – The maximum number of members to send back. If no query is passed, passing None returns all members.\nIf a query or user_ids is passed, must be between 1 and 100. Defaults to 5.",
            "presences (Optional[bool]) – Whether to request for presences to be provided. This defaults\nto False.\n\nNew in version 1.6.",
            "Whether to request for presences to be provided. This defaults\nto False.",
            "New in version 1.6.",
            "cache (bool) – Whether to cache the members internally. This makes operations\nsuch as get_member() work for those that matched. Defaults to True.",
            "The list of members that have matched the query.",
            "List[Member]",
            "asyncio.TimeoutError – The query timed out waiting for the members.",
            "ValueError – Invalid parameters were passed to the function",
            "ClientException – The presences intent is not enabled.",
            "This function is a coroutine.",
            "Changes client’s voice state in the guild.",
            "New in version 1.4.",
            "channel (Optional[Union[VoiceChannel, StageChannel]]) – Channel the client wants to join. Use None to disconnect.",
            "self_mute (bool) – Indicates if the client should be self-muted.",
            "self_deaf (bool) – Indicates if the client should be self-deafened.",
            "This function is a coroutine.",
            "Returns the WelcomeScreen of the guild.",
            "The guild must have COMMUNITY in features.",
            "You must have the manage_guild permission in order to get this.",
            "New in version 2.0.",
            "The welcome screen of guild.",
            "WelcomeScreen",
            "Forbidden – You do not have the proper permissions to get this.",
            "HTTPException – Retrieving the welcome screen failed somehow.",
            "NotFound – The guild doesn’t have a welcome screen or community feature is disabled.",
            "This function is a coroutine.",
            "A shorthand for WelcomeScreen.edit without fetching the welcome screen.",
            "You must have the manage_guild permission in the\nguild to do this.",
            "The guild must have COMMUNITY in Guild.features",
            "description (Optional[str]) – The new description of welcome screen.",
            "welcome_channels (Optional[List[WelcomeScreenChannel]]) – The welcome channels. The order of the channels would be same as the passed list order.",
            "enabled (Optional[bool]) – Whether the welcome screen should be displayed.",
            "reason (Optional[str]) – The reason that shows up on audit log.",
            "The edited welcome screen.",
            "WelcomeScreen",
            "HTTPException – Editing the welcome screen failed somehow.",
            "Forbidden – You don’t have permissions to edit the welcome screen.",
            "NotFound – This welcome screen does not exist.",
            "This function is a coroutine.",
            "Returns a list of ScheduledEvent in the guild.",
            "Note",
            "This method is an API call. For general usage, consider scheduled_events instead.",
            "with_user_count (Optional[bool]) – If the scheduled event should be fetched with the number of\nusers that are interested in the events.\nDefaults to True.",
            "The fetched scheduled events.",
            "List[ScheduledEvent]",
            "ClientException – The scheduled events intent is not enabled.",
            "HTTPException – Getting the scheduled events failed.",
            "This function is a coroutine.",
            "Retrieves a ScheduledEvent from event ID.",
            "Note",
            "This method is an API call. If you have Intents.scheduled_events,\nconsider get_scheduled_event() instead.",
            "event_id (int) – The event’s ID to fetch with.",
            "with_user_count (Optional[bool]) – If the scheduled vent should be fetched with the number of\nusers that are interested in the event.\nDefaults to True.",
            "The scheduled event from the event ID.",
            "Optional[ScheduledEvent]",
            "HTTPException – Fetching the event failed.",
            "NotFound – Event not found.",
            "Returns a Scheduled Event with the given ID.",
            "event_id (int) – The ID to search for.",
            "The scheduled event or None if not found.",
            "Optional[ScheduledEvent]",
            "This function is a coroutine.\nCreates a scheduled event.",
            "name (str) – The name of the scheduled event.",
            "description (Optional[str]) – The description of the scheduled event.",
            "start_time (datetime.datetime) – A datetime object of when the scheduled event is supposed to start.",
            "end_time (Optional[datetime.datetime]) – A datetime object of when the scheduled event is supposed to end.",
            "location (ScheduledEventLocation) – The location of where the event is happening.",
            "privacy_level (ScheduledEventPrivacyLevel) – The privacy level of the event. Currently, the only possible value\nis ScheduledEventPrivacyLevel.guild_only, which is default,\nso there is no need to change this parameter.",
            "reason (Optional[str]) – The reason to show in the audit log.",
            "image (Optional[bytes]) – The cover image of the scheduled event",
            "The created scheduled event.",
            "Optional[ScheduledEvent]",
            "Forbidden – You do not have the Manage Events permission.",
            "HTTPException – The operation failed.",
            "A list of scheduled events in this guild.",
            "This function is a coroutine.",
            "Retrieves a list of auto moderation rules for this guild.",
            "The auto moderation rules for this guild.",
            "List[AutoModRule]",
            "HTTPException – Getting the auto moderation rules failed.",
            "Forbidden – You do not have the Manage Guild permission.",
            "This function is a coroutine.",
            "Retrieves a AutoModRule from rule ID.",
            "The requested auto moderation rule.",
            "AutoModRule",
            "HTTPException – Getting the auto moderation rule failed.",
            "Forbidden – You do not have the Manage Guild permission.",
            "id (int) –",
            "Creates an auto moderation rule.",
            "name (str) – The name of the auto moderation rule.",
            "event_type (AutoModEventType) – The type of event that triggers the rule.",
            "trigger_type (AutoModTriggerType) – The rule’s trigger type.",
            "trigger_metadata (AutoModTriggerMetadata) – The rule’s trigger metadata.",
            "actions (List[AutoModAction]) – The actions to take when the rule is triggered.",
            "enabled (bool) – Whether the rule is enabled.",
            "exempt_roles (List[abc.Snowflake]) – A list of roles that are exempt from the rule.",
            "exempt_channels (List[abc.Snowflake]) – A list of channels that are exempt from the rule.",
            "reason (Optional[str]) – The reason for creating the rule. Shows up in the audit log.",
            "The new auto moderation rule.",
            "AutoModRule",
            "HTTPException – Creating the auto moderation rule failed.",
            "Forbidden – You do not have the Manage Guild permission.",
            "This function is a coroutine.",
            "Returns the Onboarding flow for the guild.",
            "New in version 2.5.",
            "The onboarding flow for the guild.",
            "Onboarding",
            "HTTPException – Retrieving the onboarding flow failed somehow.",
            "This function is a coroutine.",
            "A shorthand for Onboarding.edit without fetching the onboarding flow.",
            "You must have the manage_guild and manage_roles permissions in the\nguild to do this.",
            "prompts (Optional[List[OnboardingPrompt]]) – The new list of prompts for this flow.",
            "default_channels (Optional[List[Snowflake]]) – The new default channels that users are opted into.",
            "enabled (Optional[bool]) – Whether onboarding should be enabled. Setting this to True requires\nthe guild to have COMMUNITY in features and at\nleast 7 default_channels.",
            "mode (Optional[OnboardingMode]) – The new onboarding mode.",
            "reason (Optional[str]) – The reason that shows up on Audit log.",
            "The updated onboarding flow.",
            "Onboarding",
            "HTTPException – Editing the onboarding flow failed somehow.",
            "Forbidden – You don’t have permissions to edit the onboarding flow.",
            "Deletes an auto moderation rule.",
            "id (int) – The ID of the auto moderation rule.",
            "reason (Optional[str]) – The reason for deleting the rule. Shows up in the audit log.",
            "HTTPException – Deleting the auto moderation rule failed.",
            "Forbidden – You do not have the Manage Guild permission.",
            "None",
            "This function is a coroutine.",
            "Creates a test entitlement for the guild.",
            "sku (Snowflake) – The SKU to create a test entitlement for.",
            "The created entitlement.",
            "Entitlement",
            "Returns an AsyncIterator that enables fetching the guild’s entitlements.",
            "This is identical to Client.entitlements() with the guild parameter.",
            "New in version 2.6.",
            "skus (list[abc.Snowflake] | None) – Limit the fetched entitlements to entitlements that are for these SKUs.",
            "before (abc.Snowflake | datetime.datetime | None) – Retrieves guilds before this date or object.\nIf a datetime is provided, it is recommended to use a UTC-aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (abc.Snowflake | datetime.datetime | None) – Retrieve guilds after this date or object.\nIf a datetime is provided, it is recommended to use a UTC-aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "limit (Optional[int]) – The number of entitlements to retrieve.\nIf None, retrieves every entitlement, which may be slow.\nDefaults to 100.",
            "exclude_ended (bool) – Whether to limit the fetched entitlements to those that have not ended.\nDefaults to False.",
            "Entitlement – The application’s entitlements.",
            "HTTPException – Retrieving the entitlements failed.",
            "A namedtuple which represents a ban returned from bans().",
            "The reason this user was banned.",
            "Optional[str]",
            "The User that was banned.",
            "User",
            "Represents a Discord member to a Guild.",
            "This implements a lot of the functionality of User.",
            "Checks if two members are equal.\nNote that this works with User instances too.",
            "Checks if two members are not equal.\nNote that this works with User instances too.",
            "Returns the member’s hash.",
            "Returns the member’s name with the discriminator or global_name.",
            "An aware datetime object that specifies the date and time in UTC that the member joined the guild.\nIf the member left and rejoined the guild, this will be the latest date. In certain cases, this can be None.",
            "Optional[datetime.datetime]",
            "The activities that the user is currently doing.",
            "Note",
            "Due to a Discord API limitation, a user’s Spotify activity may not appear\nif they are listening to a song with a title longer\nthan 128 characters.",
            "Tuple[Union[BaseActivity, Spotify]]",
            "The guild that the member belongs to.",
            "Guild",
            "The guild specific nickname of the user.",
            "Optional[str]",
            "Whether the member is pending member verification.",
            "New in version 1.6.",
            "bool",
            "An aware datetime object that specifies the date and time in UTC when the member used their\n“Nitro boost” on the guild, if available. This could be None.",
            "Optional[datetime.datetime]",
            "An aware datetime object that specifies the date and time in UTC when the member will be removed from timeout.",
            "New in version 2.0.",
            "Optional[datetime.datetime]",
            "Extra attributes of the member.",
            "New in version 2.6.",
            "MemberFlags",
            "data (MemberWithUser) –",
            "guild (Guild) –",
            "state (ConnectionState) –",
            "Returns an AsyncIterator that enables receiving the destination’s message history.",
            "You must have read_message_history permissions to use this.",
            "limit (Optional[int]) – The number of messages to retrieve.\nIf None, retrieves every message in the channel. Note, however,\nthat this would make it a slow operation.",
            "before (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages before this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages after this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "around (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages around this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.\nWhen using this argument, the maximum limit is 101. Note that if the limit is an\neven number, then this will return at most limit + 1 messages.",
            "oldest_first (Optional[bool]) – If set to True, return messages in oldest->newest order. Defaults to True if\nafter is specified, otherwise False.",
            "Message – The message with the message data parsed.",
            "Forbidden – You do not have permissions to get channel message history.",
            "HTTPException – The request to get message history failed.",
            "HistoryIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "All parameters are optional.",
            "Returns a context manager that allows you to type for an indefinite period of time.",
            "This is useful for denoting long computations in your bot.\n:rtype: Typing",
            "Note",
            "This is both a regular context manager and an async context manager.\nThis means that both with and async with work with this.",
            "Example Usage:",
            "Equivalent to User.name",
            "Equivalent to User.id",
            "Equivalent to User.discriminator",
            "Equivalent to User.bot",
            "Equivalent to User.system",
            "Equivalent to User.created_at",
            "Equivalent to User.default_avatar",
            "Equivalent to User.avatar",
            "Equivalent to User.dm_channel",
            "This function is a coroutine.",
            "Creates a DMChannel with this user.",
            "This should be rarely called, as this is done transparently for most\npeople.",
            "The channel that was created.",
            "DMChannel",
            "Equivalent to User.mutual_guilds",
            "Equivalent to User.public_flags",
            "Equivalent to User.banner",
            "Equivalent to User.accent_color",
            "Equivalent to User.accent_colour",
            "The member’s overall status as a string value.",
            "New in version 1.5.",
            "The member’s overall status.\nIf the value is unknown, then it will be a str instead.",
            "The member’s status on a mobile device, if applicable.",
            "The member’s status on the desktop client, if applicable.",
            "The member’s status on the web client, if applicable.",
            "The member’s global name, if applicable.",
            "A helper function that determines if a member is active on a mobile device.",
            "bool",
            "A property that returns a colour denoting the rendered colour\nfor the member. If the default colour is the one rendered then an instance\nof Colour.default() is returned.",
            "There is an alias for this named color.",
            "A property that returns a color denoting the rendered color for\nthe member. If the default color is the one rendered then an instance of Colour.default()\nis returned.",
            "There is an alias for this named colour.",
            "A list of Role that the member belongs to. Note\nthat the first element of this list is always the default ‘@everyone’\nrole.",
            "These roles are sorted by their position in the role hierarchy.",
            "Returns a string that allows you to mention the member.",
            "Returns the user’s display name.\nThis will either be their guild specific nickname, global name or username.",
            "Returns the member’s display avatar.",
            "For regular members this is just their avatar, but\nif they have a guild specific avatar then that\nis returned instead.",
            "New in version 2.0.",
            "Returns an Asset for the guild avatar\nthe member has. If unavailable, None is returned.",
            "New in version 2.0.",
            "Returns the primary\nactivity the user is currently doing. Could be None if no activity is being done.",
            "Note",
            "Due to a Discord API limitation, this may be None if\nthe user is listening to a song on Spotify with a title longer\nthan 128 characters.",
            "Note",
            "A user may have multiple activities, these can be accessed under activities.",
            "Checks if the member is mentioned in the specified message.",
            "message (Message) – The message to check if you’re mentioned in.",
            "Indicates if the member is mentioned in the message.",
            "bool",
            "Returns the member’s highest role.",
            "This is useful for figuring where a member stands in the role\nhierarchy chain.",
            "Returns the member’s guild permissions.",
            "This only takes into consideration the guild permissions\nand not most of the implied permissions or any of the\nchannel permission overwrites. For 100% accurate permission\ncalculation, please use abc.GuildChannel.permissions_for().",
            "This does take into consideration guild ownership and the\nadministrator implication.",
            "Returns the member’s current voice state.",
            "Returns whether the member is timed out.",
            "New in version 2.0.",
            "This function is a coroutine.",
            "Bans this member. Equivalent to Guild.ban().",
            "delete_message_seconds (int | None) –",
            "reason (str | None) –",
            "None",
            "This function is a coroutine.",
            "Unbans this member. Equivalent to Guild.unban().",
            "reason (str | None) –",
            "None",
            "This function is a coroutine.",
            "Kicks this member. Equivalent to Guild.kick().",
            "reason (str | None) –",
            "None",
            "This function is a coroutine.",
            "Edits the member’s data.",
            "Depending on the parameter passed, this requires different permissions listed below:",
            "Parameter",
            "Permission",
            "nick",
            "Permissions.manage_nicknames",
            "mute",
            "Permissions.mute_members",
            "deafen",
            "Permissions.deafen_members",
            "roles",
            "Permissions.manage_roles",
            "voice_channel",
            "Permissions.move_members",
            "communication_disabled_until",
            "Permissions.moderate_members",
            "bypass_verification",
            "See note below",
            "Note",
            "bypass_verification may be edited under three scenarios:",
            "Client has Permissions.manage_guild",
            "Client has Permissions.manage_roles",
            "Client has ALL THREE of Permissions.moderate_members, Permissions.kick_members, and Permissions.ban_members",
            "All parameters are optional.",
            "Changed in version 1.1: Can now pass None to voice_channel to kick a member from voice.",
            "Changed in version 2.0: The newly member is now optionally returned, if applicable.",
            "nick (Optional[str]) – The member’s new nickname. Use None to remove the nickname.",
            "mute (bool) – Indicates if the member should be guild muted or un-muted.",
            "deafen (bool) – Indicates if the member should be guild deafened or un-deafened.",
            "suppress (bool) – Indicates if the member should be suppressed in stage channels.\n\nNew in version 1.7.",
            "Indicates if the member should be suppressed in stage channels.",
            "New in version 1.7.",
            "roles (List[Role]) – The member’s new list of roles. This replaces the roles.",
            "voice_channel (Optional[Union[VoiceChannel, StageChannel]]) – The voice channel to move the member to.\nPass None to kick them from voice.",
            "reason (Optional[str]) – The reason for editing this member. Shows up on the audit log.",
            "communication_disabled_until (Optional[datetime.datetime]) – Temporarily puts the member in timeout until this time. If the value is None, then the user is removed\nfrom timeout.\n\nNew in version 2.0.",
            "Temporarily puts the member in timeout until this time. If the value is None, then the user is removed\nfrom timeout.",
            "New in version 2.0.",
            "bypass_verification (Optional[bool]) – Indicates if the member should bypass the guild’s verification requirements.\n\nNew in version 2.6.",
            "Indicates if the member should bypass the guild’s verification requirements.",
            "New in version 2.6.",
            "The newly updated member, if applicable. This is only returned\nwhen certain fields are updated.",
            "Optional[Member]",
            "Forbidden – You do not have the proper permissions to the action requested.",
            "HTTPException – The operation failed.",
            "This function is a coroutine.",
            "Applies a timeout to a member in the guild until a set datetime.",
            "You must have the moderate_members permission to timeout a member.",
            "until (datetime.datetime) – The date and time to timeout the member for. If this is None then the member is removed from timeout.",
            "reason (Optional[str]) – The reason for doing this action. Shows up on the audit log.",
            "Forbidden – You do not have permissions to timeout members.",
            "HTTPException – An error occurred doing the request.",
            "None",
            "This function is a coroutine.",
            "Applies a timeout to a member in the guild for a set duration. A shortcut method for timeout(), and\nequivalent to timeout(until=datetime.utcnow() + duration, reason=reason).",
            "You must have the moderate_members permission to\ntimeout a member.",
            "duration (datetime.timedelta) – The duration to timeout the member for.",
            "reason (Optional[str]) – The reason for doing this action. Shows up on the audit log.",
            "Forbidden – You do not have permissions to timeout members.",
            "HTTPException – An error occurred doing the request.",
            "None",
            "This function is a coroutine.",
            "Removes the timeout from a member.",
            "You must have the moderate_members permission to\nremove the timeout.",
            "This is equivalent to calling timeout() and passing None to the until parameter.",
            "reason (Optional[str]) – The reason for doing this action. Shows up on the audit log.",
            "Forbidden – You do not have permissions to remove the timeout.",
            "HTTPException – An error occurred doing the request.",
            "None",
            "This function is a coroutine.",
            "Request to speak in the connected channel.",
            "Only applies to stage channels.\n:rtype: None",
            "Note",
            "Requesting members that are not the client is equivalent\nto edit providing suppress as False.",
            "New in version 1.7.",
            "Forbidden – You do not have the proper permissions to the action requested.",
            "HTTPException – The operation failed.",
            "This function is a coroutine.",
            "Moves a member to a new voice channel (they must be connected first).",
            "You must have the move_members permission to\nuse this.",
            "This raises the same exceptions as edit().",
            "Changed in version 1.1: Can now pass None to kick a member from voice.",
            "channel (Optional[Union[VoiceChannel, StageChannel]]) – The new voice channel to move the member to.\nPass None to kick them from voice.",
            "reason (Optional[str]) – The reason for doing this action. Shows up on the audit log.",
            "None",
            "This function is a coroutine.",
            "Gives the member a number of Roles.",
            "You must have the manage_roles permission to\nuse this, and the added Roles must appear lower in the list\nof roles than the highest role of the member.",
            "*roles (abc.Snowflake) – An argument list of abc.Snowflake representing a Role\nto give to the member.",
            "reason (Optional[str]) – The reason for adding these roles. Shows up on the audit log.",
            "atomic (bool) – Whether to atomically add roles. This will ensure that multiple\noperations will always be applied regardless of the current\nstate of the cache.",
            "Forbidden – You do not have permissions to add these roles.",
            "HTTPException – Adding roles failed.",
            "None",
            "Equivalent to User.avatar_decoration",
            "Returns a bool indicating whether you have the permissions to send the object(s).",
            "Indicates whether you have the permissions to send the object(s).",
            "bool",
            "TypeError – An invalid type has been passed.",
            "This function is a coroutine.",
            "Creates a test entitlement for the user.",
            "sku (Snowflake) – The SKU to create a test entitlement for.",
            "The created entitlement.",
            "Entitlement",
            "Returns an AsyncIterator that enables fetching the user’s entitlements.",
            "This is identical to Client.entitlements() with the user parameter.",
            "New in version 2.6.",
            "skus (list[abc.Snowflake] | None) – Limit the fetched entitlements to entitlements that are for these SKUs.",
            "before (abc.Snowflake | datetime.datetime | None) – Retrieves guilds before this date or object.\nIf a datetime is provided, it is recommended to use a UTC-aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (abc.Snowflake | datetime.datetime | None) – Retrieve guilds after this date or object.\nIf a datetime is provided, it is recommended to use a UTC-aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "limit (Optional[int]) – The number of entitlements to retrieve.\nIf None, retrieves every entitlement, which may be slow.\nDefaults to 100.",
            "exclude_ended (bool) – Whether to limit the fetched entitlements to those that have not ended.\nDefaults to False.",
            "Entitlement – The application’s entitlements.",
            "HTTPException – Retrieving the entitlements failed.",
            "This function is a coroutine.",
            "Retrieves a single Message from the destination.",
            "id (int) – The message ID to look for.",
            "The message asked for.",
            "Message",
            "NotFound – The specified message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "Equivalent to User.is_migrated",
            "Equivalent to User.jump_url",
            "This function is a coroutine.",
            "Retrieves all messages that are currently pinned in the channel.",
            "Note",
            "Due to a limitation with the Discord API, the Message\nobjects returned by this method do not contain complete\nMessage.reactions data.",
            "The messages that are currently pinned.",
            "List[Message]",
            "HTTPException – Retrieving the pinned messages failed.",
            "This function is a coroutine.",
            "Removes Roles from this member.",
            "You must have the manage_roles permission to\nuse this, and the removed Roles must appear lower in the list\nof roles than the highest role of the member.",
            "*roles (abc.Snowflake) – An argument list of abc.Snowflake representing a Role\nto remove from the member.",
            "reason (Optional[str]) – The reason for removing these roles. Shows up on the audit log.",
            "atomic (bool) – Whether to atomically remove roles. This will ensure that multiple\noperations will always be applied regardless of the current\nstate of the cache.",
            "Forbidden – You do not have permissions to remove these roles.",
            "HTTPException – Removing the roles failed.",
            "None",
            "This function is a coroutine.",
            "Sends a message to the destination with the content given.",
            "The content must be a type that can convert to a string through str(content).\nIf the content is set to None (the default), then the embed parameter must\nbe provided.",
            "To upload a single file, the file parameter should be used with a\nsingle File object. To upload multiple files, the files\nparameter should be used with a list of File objects.\nSpecifying both parameters will lead to an exception.",
            "To upload a single embed, the embed parameter should be used with a\nsingle Embed object. To upload multiple embeds, the embeds\nparameter should be used with a list of Embed objects.\nSpecifying both parameters will lead to an exception.",
            "content (Optional[str]) – The content of the message to send.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "embed (Embed) – The rich embed for the content.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "nonce (Union[str, int]) – The nonce to use for sending this message. If the message was successfully sent,\nthen the message will have a nonce with this value.",
            "enforce_nonce (Optional[bool]) – Whether nonce is enforced to be validated.\n\nNew in version 2.5.",
            "Whether nonce is enforced to be validated.",
            "New in version 2.5.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent. If the deletion fails,\nthen it is silently ignored.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "New in version 1.4.",
            "reference (Union[Message, MessageReference, PartialMessage]) – A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.\n\nNew in version 1.6.",
            "A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.",
            "New in version 1.6.",
            "mention_author (Optional[bool]) – If set, overrides the replied_user attribute of allowed_mentions.\n\nNew in version 1.6.",
            "If set, overrides the replied_user attribute of allowed_mentions.",
            "New in version 1.6.",
            "view (discord.ui.View) – A Discord UI View to add to the message.",
            "embeds (List[Embed]) – A list of embeds to upload. Must be a maximum of 10.\n\nNew in version 2.0.",
            "A list of embeds to upload. Must be a maximum of 10.",
            "New in version 2.0.",
            "stickers (Sequence[Union[GuildSticker, StickerItem]]) – A list of stickers to upload. Must be a maximum of 3.\n\nNew in version 2.0.",
            "A list of stickers to upload. Must be a maximum of 3.",
            "New in version 2.0.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "silent (bool) – Whether to suppress push and desktop notifications for the message.\n\nNew in version 2.4.",
            "Whether to suppress push and desktop notifications for the message.",
            "New in version 2.4.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size,\n    you specified both file and files,\n    or you specified both embed and embeds,\n    or the reference object is not a Message,\n    MessageReference or PartialMessage.",
            "This function is a coroutine.",
            "Triggers a typing indicator to the destination.",
            "Typing indicator will go away after 10 seconds, or after a message is sent.",
            "None",
            "Returns a role with the given ID from roles which the member has.",
            "New in version 2.0.",
            "role_id (int) – The ID to search for.",
            "The role or None if not found in the member’s roles.",
            "Optional[Role]",
            "Represents a Discord template.",
            "New in version 1.4.",
            "The template code.",
            "str",
            "How many times the template has been used.",
            "int",
            "The name of the template.",
            "str",
            "The description of the template.",
            "str",
            "The creator of the template.",
            "User",
            "An aware datetime in UTC representing when the template was created.",
            "datetime.datetime",
            "An aware datetime in UTC representing when the template was last updated.\nThis is referred to as “last synced” in the official Discord client.",
            "datetime.datetime",
            "The source guild.",
            "Guild",
            "Whether the template has unsynced changes.",
            "New in version 2.0.",
            "Optional[bool]",
            "state (ConnectionState) –",
            "data (Template) –",
            "This function is a coroutine.",
            "Creates a Guild using the template.",
            "Bot accounts in more than 10 guilds are not allowed to create guilds.",
            "name (str) – The name of the guild.",
            "icon (bytes) – The bytes-like object representing the icon. See ClientUser.edit()\nfor more details on what is expected.",
            "The guild created. This is not the same guild that is\nadded to cache.",
            "Guild",
            "HTTPException – Guild creation failed.",
            "InvalidArgument – Invalid icon image format given. Must be PNG or JPG.",
            "This function is a coroutine.",
            "Sync the template to the guild’s current state.",
            "You must have the manage_guild permission in the\nsource guild to do this.",
            "New in version 1.7.",
            "Changed in version 2.0: The template is no longer synced in-place, instead it is returned.",
            "The newly synced template.",
            "Template",
            "HTTPException – Syncing the template failed.",
            "Forbidden – You don’t have permissions to sync the template.",
            "NotFound – This template does not exist.",
            "This function is a coroutine.",
            "Edit the template metadata.",
            "You must have the manage_guild permission in the\nsource guild to do this.",
            "New in version 1.7.",
            "Changed in version 2.0: The template is no longer edited in-place, instead it is returned.",
            "name (str) – The template’s new name.",
            "description (Optional[str]) – The template’s new description.",
            "The newly edited template.",
            "Template",
            "HTTPException – Editing the template failed.",
            "Forbidden – You don’t have permissions to edit the template.",
            "NotFound – This template does not exist.",
            "This function is a coroutine.",
            "Delete the template.",
            "You must have the manage_guild permission in the\nsource guild to do this.\n:rtype: None",
            "New in version 1.7.",
            "HTTPException – Deleting the template failed.",
            "Forbidden – You don’t have permissions to delete the template.",
            "NotFound – This template does not exist.",
            "The template url.",
            "New in version 2.0."
        ],
        "code": [
            "str",
            "Emoji",
            "GuildSticker",
            "int",
            "None",
            "VoiceChannel",
            "int",
            "bool",
            "Guild.owner",
            "int",
            "True",
            "Guild.id",
            "None",
            "on_guild_unavailable()",
            "on_guild_available()",
            "bool",
            "int",
            "Client.fetch_guild()",
            "int",
            "int",
            "str",
            "int",
            "VerificationLevel",
            "ContentFilter",
            "NotificationLevel",
            "str",
            "int",
            "int",
            "bool",
            "str",
            "NSFWLevel",
            "None",
            "Client.fetch_guild()",
            "with_counts=True",
            "int",
            "None",
            "Client.fetch_guild()",
            "with_counts=True",
            "int",
            "Guild",
            "ConnectionState",
            "AsyncIterator",
            "Intents.members()",
            "members",
            "int",
            "None",
            "abc.Snowflake",
            "datetime.datetime",
            "Member",
            "async for member in guild.fetch_members(limit=150):\n    print(member.name)",
            "members = await guild.fetch_members(limit=150).flatten()\n# members is now a list of Member...",
            "AsyncIterator",
            "view_audit_log",
            "int",
            "None",
            "abc.Snowflake",
            "datetime.datetime",
            "abc.Snowflake",
            "datetime.datetime",
            "abc.Snowflake",
            "AuditLogAction",
            "AuditLogEntry",
            "async for entry in guild.audit_logs(limit=100):\n    print(f'{entry.user} did {entry.action} to {entry.target}')",
            "async for entry in guild.audit_logs(action=discord.AuditLogAction.ban):\n    print(f'{entry.user} banned {entry.target}')",
            "entries = await guild.audit_logs(limit=None, user=guild.me).flatten()\nawait channel.send(f'I made {len(entries)} moderation actions.')",
            "large_threshold",
            "Client.user",
            "Member",
            "VoiceClient",
            "CategoryChannel",
            "None",
            "CategoryChannel",
            "abc.GuildChannel",
            "int",
            "None",
            "Thread",
            "abc.GuildChannel",
            "int",
            "None",
            "abc.GuildChannel",
            "int",
            "None",
            "Thread",
            "None",
            "None",
            "None",
            "int",
            "None",
            "Member",
            "list",
            "int",
            "None",
            "Role",
            "list",
            "int",
            "None",
            "StageInstance",
            "Intents.members",
            "member_count",
            "members",
            "False",
            "None",
            "str",
            "None",
            "Member",
            "TextChannel",
            "manage_channels",
            "overwrites",
            "dict",
            "Member",
            "Role",
            "PermissionOverwrite",
            "edit()",
            "str",
            "Role",
            "Member",
            "Snowflake",
            "PermissionOverwrite",
            "CategoryChannel",
            "int",
            "str",
            "int",
            "bool",
            "str",
            "TextChannel",
            "channel = await guild.create_text_channel('cool-channel')",
            "overwrites = {\n    guild.default_role: discord.PermissionOverwrite(read_messages=False),\n    guild.me: discord.PermissionOverwrite(read_messages=True)\n}\n\nchannel = await guild.create_text_channel('secret', overwrites=overwrites)",
            "create_text_channel()",
            "VoiceChannel",
            "str",
            "Role",
            "Member",
            "Snowflake",
            "PermissionOverwrite",
            "CategoryChannel",
            "int",
            "int",
            "int",
            "VoiceRegion",
            "None",
            "VideoQualityMode",
            "str",
            "VoiceChannel",
            "create_text_channel()",
            "StageChannel",
            "str",
            "str",
            "Role",
            "Member",
            "Snowflake",
            "PermissionOverwrite",
            "CategoryChannel",
            "int",
            "str",
            "StageChannel",
            "ForumChannel",
            "manage_channels",
            "overwrites",
            "dict",
            "Member",
            "Role",
            "PermissionOverwrite",
            "edit()",
            "str",
            "Role",
            "Member",
            "Snowflake",
            "PermissionOverwrite",
            "CategoryChannel",
            "int",
            "str",
            "int",
            "bool",
            "str",
            "Emoji",
            "int",
            "str",
            "Emoji",
            "ForumChannel",
            "channel = await guild.create_forum_channel('cool-channel')",
            "overwrites = {\n    guild.default_role: discord.PermissionOverwrite(read_messages=False),\n    guild.me: discord.PermissionOverwrite(read_messages=True)\n}\n\nchannel = await guild.create_forum_channel('secret', overwrites=overwrites)",
            "create_text_channel()",
            "CategoryChannel",
            "category",
            "CategoryChannel",
            "create_text_channel()",
            "CategoryChannel",
            "category",
            "CategoryChannel",
            "None",
            "delete()",
            "None",
            "bool",
            "str",
            "None",
            "manage_guild",
            "str",
            "str",
            "None",
            "PUBLIC",
            "Guild.features",
            "bytes",
            "ANIMATED_ICON",
            "Guild.features",
            "None",
            "bytes",
            "None",
            "BANNER",
            "Guild.features",
            "bytes",
            "None",
            "INVITE_SPLASH",
            "Guild.features",
            "bytes",
            "None",
            "DISCOVERABLE",
            "Guild.features",
            "bool",
            "True",
            "rules_channel",
            "public_updates_channel",
            "VoiceChannel",
            "None",
            "int",
            "Member",
            "VerificationLevel",
            "NotificationLevel",
            "ContentFilter",
            "TextChannel",
            "None",
            "SystemChannelFlags",
            "str",
            "en-US",
            "ja",
            "zh-CN",
            "TextChannel",
            "PUBLIC",
            "Guild.features",
            "None",
            "TextChannel",
            "PUBLIC",
            "Guild.features",
            "None",
            "bool",
            "bool",
            "str",
            "icon",
            "Client.fetch_guild()",
            "Guild",
            "abc.GuildChannel",
            "channels",
            "abc.GuildChannel",
            "Thread",
            "Thread",
            "fetch_members()",
            "Intents.members()",
            "members",
            "str",
            "int",
            "Member",
            "Member",
            "Intents.members",
            "get_member()",
            "int",
            "Member",
            "BanEntry",
            "ban_members",
            "abc.Snowflake",
            "BanEntry",
            "BanEntry",
            "abc.GuildChannel",
            "Thread",
            "get_channel_or_thread()",
            "abc.GuildChannel",
            "Thread",
            "AsyncIterator",
            "ban_members",
            "before",
            "after",
            "before",
            "after",
            "abc.Snowflake",
            "limit",
            "before",
            "after",
            "BanIterator",
            "BanEntry",
            "int",
            "abc.Snowflake",
            "abc.Snowflake",
            "BanEntry",
            "async for ban in guild.bans(limit=150):\n    print(ban.user.name)",
            "bans = await guild.bans(limit=150).flatten()\n# bans is now a list of BanEntry...",
            "days",
            "kick_members",
            "estimate_pruned_members()",
            "roles",
            "roles",
            "int",
            "str",
            "bool",
            "True",
            "False",
            "False",
            "None",
            "abc.Snowflake",
            "abc.Snowflake",
            "days",
            "compute_prune_count",
            "False",
            "None",
            "int",
            "manage_guild",
            "Template",
            "manage_webhooks",
            "Webhook",
            "prune_members()",
            "int",
            "abc.Snowflake",
            "abc.Snowflake",
            "int",
            "days",
            "manage_guild",
            "Invite",
            "manage_guild",
            "str",
            "str",
            "Template",
            "manage_guild",
            "str",
            "int",
            "None",
            "manage_guild",
            "Integration",
            "Sticker",
            "stickers",
            "GuildSticker",
            "Sticker",
            "stickers",
            "int",
            "GuildSticker",
            "Sticker",
            "manage_emojis_and_stickers",
            "str",
            "str",
            "str",
            "File",
            "str",
            "GuildSticker",
            "Sticker",
            "manage_emojis_and_stickers",
            "abc.Snowflake",
            "str",
            "Emoji",
            "emojis",
            "Emoji",
            "Emoji",
            "emojis",
            "int",
            "Emoji",
            "Emoji",
            "MORE_EMOJI",
            "manage_emojis",
            "str",
            "bytes",
            "Role",
            "list",
            "Role",
            "str",
            "Emoji",
            "Emoji",
            "manage_emojis",
            "abc.Snowflake",
            "str",
            "Role",
            "roles",
            "Role",
            "Role",
            "manage_roles",
            "int",
            "colour",
            "str",
            "Permissions",
            "Colour",
            "int",
            "Colour.default()",
            "color",
            "bool",
            "False",
            "bool",
            "False",
            "str",
            "bytes",
            "unicode_emoji",
            "ROLE_ICONS",
            "Guild.features",
            "str",
            "icon",
            "ROLE_ICONS",
            "Guild.features",
            "Role",
            "Role",
            "manage_roles",
            "positions = {\n    bots_role: 1, # penultimate role\n    tester_role: 2,\n    admin_role: 6\n}\n\nawait guild.edit_role_positions(positions=positions)",
            "Role",
            "int",
            "dict",
            "Role",
            "int",
            "str",
            "Role",
            "abc.Snowflake",
            "kick_members",
            "abc.Snowflake",
            "str",
            "abc.Snowflake",
            "ban_members",
            "abc.Snowflake",
            "int",
            "str",
            "abc.Snowflake",
            "ban_members",
            "# Ban multiple users\nsuccesses, failures = await guild.bulk_ban(user1, user2, user3, ..., reason=\"Raid\")\n\n# Ban a list of users\nsuccesses, failures = await guild.bulk_ban(*users)",
            "abc.Snowflake",
            "int",
            "str",
            "abc.Snowflake",
            "abc.Snowflake",
            "abc.Snowflake",
            "ban_members",
            "abc.Snowflake",
            "str",
            "VANITY_URL",
            "features",
            "manage_guild",
            "None",
            "Invite",
            "Widget",
            "manage_guild",
            "bool",
            "Snowflake",
            "None",
            "Intents.members()",
            "bool",
            "None",
            "str",
            "int",
            "int",
            "None",
            "query",
            "user_ids",
            "bool",
            "False",
            "bool",
            "get_member()",
            "True",
            "Member",
            "VoiceChannel",
            "StageChannel",
            "None",
            "bool",
            "bool",
            "WelcomeScreen",
            "COMMUNITY",
            "features",
            "manage_guild",
            "WelcomeScreen",
            "WelcomeScreen.edit",
            "manage_guild",
            "COMMUNITY",
            "Guild.features",
            "str",
            "WelcomeScreenChannel",
            "bool",
            "str",
            "WelcomeScreen",
            "ScheduledEvent",
            "scheduled_events",
            "bool",
            "True",
            "ScheduledEvent",
            "ScheduledEvent",
            "Intents.scheduled_events",
            "get_scheduled_event()",
            "int",
            "bool",
            "True",
            "ScheduledEvent",
            "int",
            "None",
            "ScheduledEvent",
            "str",
            "str",
            "datetime.datetime",
            "datetime.datetime",
            "ScheduledEventLocation",
            "ScheduledEventPrivacyLevel",
            "ScheduledEventPrivacyLevel.guild_only",
            "str",
            "bytes",
            "ScheduledEvent",
            "AutoModRule",
            "AutoModRule",
            "AutoModRule",
            "int",
            "str",
            "AutoModEventType",
            "AutoModTriggerType",
            "AutoModTriggerMetadata",
            "AutoModAction",
            "bool",
            "abc.Snowflake",
            "abc.Snowflake",
            "str",
            "AutoModRule",
            "Onboarding",
            "Onboarding",
            "Onboarding.edit",
            "manage_guild",
            "manage_roles",
            "OnboardingPrompt",
            "Snowflake",
            "bool",
            "True",
            "COMMUNITY",
            "features",
            "default_channels",
            "OnboardingMode",
            "str",
            "Onboarding",
            "int",
            "str",
            "Snowflake",
            "Entitlement",
            "AsyncIterator",
            "Client.entitlements()",
            "guild",
            "abc.Snowflake",
            "abc.Snowflake",
            "datetime.datetime",
            "abc.Snowflake",
            "datetime.datetime",
            "int",
            "None",
            "100",
            "bool",
            "False",
            "Entitlement",
            "bans()",
            "str",
            "User",
            "User",
            "Guild",
            "User",
            "User",
            "User",
            "None",
            "datetime.datetime",
            "BaseActivity",
            "Spotify",
            "Guild",
            "str",
            "bool",
            "None",
            "datetime.datetime",
            "datetime.datetime",
            "MemberFlags",
            "MemberWithUser",
            "Guild",
            "ConnectionState",
            "AsyncIterator",
            "read_message_history",
            "int",
            "None",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "bool",
            "True",
            "True",
            "after",
            "False",
            "Message",
            "counter = 0\nasync for message in channel.history(limit=200):\n    if message.author == client.user:\n        counter += 1",
            "messages = await channel.history(limit=123).flatten()\n# messages is now a list of Message...",
            "Typing",
            "with",
            "async with",
            "async with channel.typing():\n    # simulate something heavy\n    await asyncio.sleep(10)\n\nawait channel.send('done!')",
            "User.name",
            "User.id",
            "User.discriminator",
            "User.bot",
            "User.system",
            "User.created_at",
            "User.default_avatar",
            "User.avatar",
            "User.dm_channel",
            "DMChannel",
            "DMChannel",
            "User.mutual_guilds",
            "User.public_flags",
            "User.banner",
            "User.accent_color",
            "User.accent_colour",
            "str",
            "bool",
            "Colour.default()",
            "color",
            "Colour.default()",
            "colour",
            "list",
            "Role",
            "Asset",
            "None",
            "None",
            "None",
            "activities",
            "Message",
            "bool",
            "abc.GuildChannel.permissions_for()",
            "Guild.ban()",
            "Guild.unban()",
            "Guild.kick()",
            "Permissions.manage_nicknames",
            "Permissions.mute_members",
            "Permissions.deafen_members",
            "Permissions.manage_roles",
            "Permissions.move_members",
            "Permissions.moderate_members",
            "Permissions.manage_guild",
            "Permissions.manage_roles",
            "Permissions.moderate_members",
            "Permissions.kick_members",
            "Permissions.ban_members",
            "None",
            "voice_channel",
            "str",
            "None",
            "bool",
            "bool",
            "bool",
            "Role",
            "VoiceChannel",
            "StageChannel",
            "None",
            "str",
            "datetime.datetime",
            "None",
            "bool",
            "Member",
            "moderate_members",
            "datetime.datetime",
            "None",
            "str",
            "timeout()",
            "timeout(until=datetime.utcnow() + duration, reason=reason)",
            "moderate_members",
            "datetime.timedelta",
            "str",
            "moderate_members",
            "timeout()",
            "None",
            "until",
            "str",
            "None",
            "edit",
            "suppress",
            "False",
            "move_members",
            "edit()",
            "None",
            "VoiceChannel",
            "StageChannel",
            "None",
            "str",
            "Role",
            "manage_roles",
            "Role",
            "abc.Snowflake",
            "abc.Snowflake",
            "Role",
            "str",
            "bool",
            "User.avatar_decoration",
            "bool",
            "bool",
            "Snowflake",
            "Entitlement",
            "AsyncIterator",
            "Client.entitlements()",
            "user",
            "abc.Snowflake",
            "abc.Snowflake",
            "datetime.datetime",
            "abc.Snowflake",
            "datetime.datetime",
            "int",
            "None",
            "100",
            "bool",
            "False",
            "Entitlement",
            "Message",
            "int",
            "Message",
            "User.is_migrated",
            "User.jump_url",
            "Message",
            "Message.reactions",
            "Message",
            "Role",
            "manage_roles",
            "Role",
            "abc.Snowflake",
            "abc.Snowflake",
            "Role",
            "str",
            "bool",
            "str(content)",
            "None",
            "embed",
            "file",
            "File",
            "files",
            "list",
            "File",
            "embed",
            "Embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "Embed",
            "File",
            "File",
            "str",
            "int",
            "bool",
            "nonce",
            "float",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "Message",
            "MessageReference",
            "PartialMessage",
            "Message",
            "to_reference()",
            "Message",
            "replied_user",
            "allowed_mentions",
            "mention_author",
            "bool",
            "replied_user",
            "allowed_mentions",
            "discord.ui.View",
            "Embed",
            "GuildSticker",
            "StickerItem",
            "bool",
            "bool",
            "Poll",
            "Message",
            "files",
            "file",
            "files",
            "embed",
            "embeds",
            "reference",
            "Message",
            "MessageReference",
            "PartialMessage",
            "None",
            "int",
            "None",
            "Role",
            "str",
            "int",
            "str",
            "str",
            "User",
            "datetime.datetime",
            "datetime.datetime",
            "Guild",
            "bool",
            "ConnectionState",
            "Template",
            "Guild",
            "str",
            "bytes",
            "ClientUser.edit()",
            "Guild",
            "manage_guild",
            "Template",
            "manage_guild",
            "str",
            "str",
            "Template",
            "manage_guild",
            "None"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "AutoMod#",
        "content": [
            "Represents a guild’s auto moderation rule.",
            "New in version 2.0.",
            "Checks if two rules are equal.",
            "Checks if two rules are not equal.",
            "Returns the rule’s hash.",
            "Returns the rule’s name.",
            "The rule’s ID.",
            "int",
            "The rule’s name.",
            "str",
            "The ID of the user who created this rule.",
            "int",
            "Indicates in what context the rule is checked.",
            "AutoModEventType",
            "Indicates what type of information is checked to determine whether the rule is triggered.",
            "AutoModTriggerType",
            "The rule’s trigger metadata.",
            "AutoModTriggerMetadata",
            "The actions to perform when the rule is triggered.",
            "List[AutoModAction]",
            "Whether this rule is enabled.",
            "bool",
            "The IDs of the roles that are exempt from this rule.",
            "List[int]",
            "The IDs of the channels that are exempt from this rule.",
            "List[int]",
            "state (ConnectionState) –",
            "data (AutoModRule) –",
            "The guild this rule belongs to.",
            "The member who created this rule.",
            "The roles that are exempt\nfrom this rule.",
            "If a role is not found in the guild’s cache,\nthen it will be returned as an Object.",
            "The channels that are exempt from this rule.",
            "If a channel is not found in the guild’s cache,\nthen it will be returned as an Object.",
            "This function is a coroutine.",
            "Deletes this rule.",
            "reason (Optional[str]) – The reason for deleting this rule. Shows up in the audit log.",
            "Forbidden – You do not have the Manage Guild permission.",
            "HTTPException – The operation failed.",
            "None",
            "This function is a coroutine.",
            "Edits this rule.",
            "name (str) – The rule’s new name.",
            "event_type (AutoModEventType) – The new context in which the rule is checked.",
            "trigger_metadata (AutoModTriggerMetadata) – The new trigger metadata.",
            "actions (List[AutoModAction]) – The new actions to perform when the rule is triggered.",
            "enabled (bool) – Whether this rule is enabled.",
            "exempt_roles (List[abc.Snowflake]) – The roles that will be exempt from this rule.",
            "exempt_channels (List[abc.Snowflake]) – The channels that will be exempt from this rule.",
            "reason (Optional[str]) – The reason for editing this rule. Shows up in the audit log.",
            "The newly updated rule, if applicable. This is only returned\nwhen fields are updated.",
            "Optional[AutoModRule]",
            "Forbidden – You do not have the Manage Guild permission.",
            "HTTPException – The operation failed.",
            "Represents an action for a guild’s auto moderation rule.",
            "New in version 2.0.",
            "The action’s type.",
            "AutoModActionType",
            "The action’s metadata.",
            "AutoModActionMetadata",
            "action_type (AutoModActionType) –",
            "metadata (AutoModActionMetadata) –",
            "Represents an action’s metadata.",
            "Depending on the action’s type, different attributes will be used.",
            "New in version 2.0.",
            "The ID of the channel to send the message to.\nOnly for actions of type AutoModActionType.send_alert_message.",
            "int",
            "How long the member that triggered the action should be timed out for.\nOnly for actions of type AutoModActionType.timeout.",
            "datetime.timedelta",
            "An additional message shown to members when their message is blocked.\nMaximum 150 characters.\nOnly for actions of type AutoModActionType.block_message.",
            "str",
            "channel_id (int) –",
            "timeout_duration (timedelta) –",
            "custom_message (str) –",
            "Represents a rule’s trigger metadata, defining additional data used to determine when a rule triggers.",
            "Depending on the trigger type, different metadata attributes will be used:",
            "Attribute",
            "Trigger Types",
            "keyword_filter",
            "AutoModTriggerType.keyword",
            "regex_patterns",
            "AutoModTriggerType.keyword",
            "presets",
            "AutoModTriggerType.keyword_preset",
            "allow_list",
            "AutoModTriggerType.keyword, AutoModTriggerType.keyword_preset",
            "mention_total_limit",
            "AutoModTriggerType.mention_spam",
            "Each attribute has limits that may change based on the trigger type.\nSee here\nfor information on attribute limits.",
            "New in version 2.0.",
            "A list of substrings to filter.",
            "List[str]",
            "A list of regex patterns to filter using Rust-flavored regex, which is not\nfully compatible with regex syntax supported by the builtin re module.",
            "New in version 2.4.",
            "List[str]",
            "A list of preset keyword sets to filter.",
            "List[AutoModKeywordPresetType]",
            "A list of substrings to allow, overriding keyword and regex matches.",
            "New in version 2.4.",
            "List[str]",
            "The total number of unique role and user mentions allowed.",
            "New in version 2.4.",
            "int"
        ],
        "code": [
            "int",
            "str",
            "int",
            "AutoModEventType",
            "AutoModTriggerType",
            "AutoModTriggerMetadata",
            "AutoModAction",
            "bool",
            "int",
            "int",
            "ConnectionState",
            "AutoModRule",
            "Object",
            "Object",
            "str",
            "str",
            "AutoModEventType",
            "AutoModTriggerMetadata",
            "AutoModAction",
            "bool",
            "abc.Snowflake",
            "abc.Snowflake",
            "str",
            "AutoModRule",
            "AutoModActionType",
            "AutoModActionMetadata",
            "AutoModActionType",
            "AutoModActionMetadata",
            "AutoModActionType.send_alert_message",
            "int",
            "AutoModActionType.timeout",
            "datetime.timedelta",
            "AutoModActionType.block_message",
            "str",
            "int",
            "timedelta",
            "str",
            "keyword_filter",
            "AutoModTriggerType.keyword",
            "regex_patterns",
            "AutoModTriggerType.keyword",
            "presets",
            "AutoModTriggerType.keyword_preset",
            "allow_list",
            "AutoModTriggerType.keyword",
            "AutoModTriggerType.keyword_preset",
            "mention_total_limit",
            "AutoModTriggerType.mention_spam",
            "str",
            "str",
            "AutoModKeywordPresetType",
            "str",
            "int"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Invites#",
        "content": [
            "Represents a “partial” invite guild.",
            "This model will be given when the user is not part of the\nguild the Invite resolves to.",
            "Checks if two partial guilds are the same.",
            "Checks if two partial guilds are not the same.",
            "Return the partial guild’s hash.",
            "Returns the partial guild’s name.",
            "The partial guild’s name.",
            "str",
            "The partial guild’s ID.",
            "int",
            "The partial guild’s verification level.",
            "VerificationLevel",
            "A list of features the guild has. See Guild.features for more information.",
            "List[str]",
            "The partial guild’s description.",
            "Optional[str]",
            "state (ConnectionState) –",
            "data (InviteGuild) –",
            "id (int) –",
            "Returns the guild’s creation time in UTC.",
            "Returns the guild’s icon asset, if available.",
            "Returns the guild’s banner asset, if available.",
            "Returns the guild’s invite splash asset, if available.",
            "Represents a “partial” invite channel.",
            "This model will be given when the user is not part of the\nguild the Invite resolves to.",
            "Checks if two partial channels are the same.",
            "Checks if two partial channels are not the same.",
            "Return the partial channel’s hash.",
            "Returns the partial channel’s name.",
            "The partial channel’s name.",
            "str",
            "The partial channel’s ID.",
            "int",
            "The partial channel’s type.",
            "ChannelType",
            "data (PartialChannel) –",
            "The string that allows you to mention the channel.",
            "Returns the channel’s creation time in UTC.",
            "Represents a Discord Guild or abc.GuildChannel invite.",
            "Depending on the way this object was created, some of the attributes can\nhave a value of None.",
            "Checks if two invites are equal.",
            "Checks if two invites are not equal.",
            "Returns the invite hash.",
            "Returns the invite URL.",
            "The following table illustrates what methods will obtain the attributes:",
            "Attribute",
            "Method",
            "max_age",
            "abc.GuildChannel.invites(), Guild.invites()",
            "max_uses",
            "abc.GuildChannel.invites(), Guild.invites()",
            "created_at",
            "abc.GuildChannel.invites(), Guild.invites()",
            "temporary",
            "abc.GuildChannel.invites(), Guild.invites()",
            "uses",
            "abc.GuildChannel.invites(), Guild.invites()",
            "approximate_member_count",
            "Client.fetch_invite() with with_counts enabled",
            "approximate_presence_count",
            "Client.fetch_invite() with with_counts enabled",
            "expires_at",
            "Client.fetch_invite() with with_expiration enabled",
            "If it’s not in the table above then it is available by all methods.",
            "How long before the invite expires in seconds.\nA value of 0 indicates that it doesn’t expire.",
            "int",
            "The URL fragment used for the invite.",
            "str",
            "The guild the invite is for. Can be None if it’s from a group direct message.",
            "Optional[Union[Guild, Object, PartialInviteGuild]]",
            "Indicates if the invite has been revoked.",
            "bool",
            "An aware UTC datetime object denoting the time the invite was created.",
            "datetime.datetime",
            "Indicates that the invite grants temporary membership.\nIf True, members who joined via this invite will be kicked upon disconnect.",
            "bool",
            "How many times the invite has been used.",
            "int",
            "How many times the invite can be used.\nA value of 0 indicates that it has unlimited uses.",
            "int",
            "The user who created the invite.",
            "Optional[User]",
            "The approximate number of members in the guild.",
            "Optional[int]",
            "The approximate number of members currently active in the guild.\nThis includes idle, dnd, online, and invisible members. Offline members are excluded.",
            "Optional[int]",
            "The expiration date of the invite. If the value is None when received through\nClient.fetch_invite with with_expiration enabled, the invite will never expire.",
            "New in version 2.0.",
            "Optional[datetime.datetime]",
            "The channel the invite is for.",
            "Union[abc.GuildChannel, Object, PartialInviteChannel]",
            "The type of target for the voice channel invite.",
            "New in version 2.0.",
            "InviteTarget",
            "The user whose stream to display for this invite, if any.",
            "New in version 2.0.",
            "Optional[User]",
            "The embedded application the invite targets, if any.",
            "New in version 2.0.",
            "Optional[PartialAppInfo]",
            "The scheduled event linked with the invite.",
            "Optional[ScheduledEvent]",
            "state (ConnectionState) –",
            "data (InvitePayload | VanityInvitePayload) –",
            "guild (PartialInviteGuild | Guild | None) –",
            "channel (PartialInviteChannel | GuildChannel | None) –",
            "Returns the proper code portion of the invite.",
            "A property that retrieves the invite URL.",
            "This function is a coroutine.",
            "Revokes the instant invite.",
            "You must have the manage_channels permission to do this.",
            "reason (Optional[str]) – The reason for deleting this invite. Shows up on the audit log.",
            "Forbidden – You do not have permissions to revoke invites.",
            "NotFound – The invite is invalid or expired.",
            "HTTPException – Revoking the invite failed.",
            "Links the given scheduled event to this invite.",
            "Note",
            "Scheduled events aren’t actually associated with invites on the API.\nAny guild channel invite can have an event attached to it. Using\nabc.GuildChannel.create_invite(), Client.fetch_invite(),\nor this method, you can link scheduled events.",
            "New in version 2.0.",
            "event (ScheduledEvent) – The scheduled event object to link.",
            "None"
        ],
        "code": [
            "Invite",
            "str",
            "int",
            "VerificationLevel",
            "Guild.features",
            "str",
            "str",
            "ConnectionState",
            "InviteGuild",
            "int",
            "Invite",
            "str",
            "int",
            "ChannelType",
            "PartialChannel",
            "Guild",
            "abc.GuildChannel",
            "None",
            "max_age",
            "abc.GuildChannel.invites()",
            "Guild.invites()",
            "max_uses",
            "abc.GuildChannel.invites()",
            "Guild.invites()",
            "created_at",
            "abc.GuildChannel.invites()",
            "Guild.invites()",
            "temporary",
            "abc.GuildChannel.invites()",
            "Guild.invites()",
            "uses",
            "abc.GuildChannel.invites()",
            "Guild.invites()",
            "approximate_member_count",
            "Client.fetch_invite()",
            "approximate_presence_count",
            "Client.fetch_invite()",
            "expires_at",
            "Client.fetch_invite()",
            "0",
            "int",
            "str",
            "None",
            "Guild",
            "Object",
            "PartialInviteGuild",
            "bool",
            "datetime.datetime",
            "True",
            "bool",
            "int",
            "0",
            "int",
            "User",
            "int",
            "int",
            "None",
            "datetime.datetime",
            "abc.GuildChannel",
            "Object",
            "PartialInviteChannel",
            "InviteTarget",
            "User",
            "PartialAppInfo",
            "ScheduledEvent",
            "manage_channels",
            "str",
            "abc.GuildChannel.create_invite()",
            "Client.fetch_invite()",
            "ScheduledEvent",
            "None"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Role#",
        "content": [
            "Represents a Discord role in a Guild.",
            "Checks if two roles are equal.",
            "Checks if two roles are not equal.",
            "Checks if a role is higher than another in the hierarchy.",
            "Checks if a role is lower than another in the hierarchy.",
            "Checks if a role is higher or equal to another in the hierarchy.",
            "Checks if a role is lower or equal to another in the hierarchy.",
            "Return the role’s hash.",
            "Returns the role’s name.",
            "The ID for the role.",
            "int",
            "The name of the role.",
            "str",
            "The guild the role belongs to.",
            "Guild",
            "Indicates if the role will be displayed separately from other members.",
            "bool",
            "The position of the role. This number is usually positive. The bottom\nrole has a position of 0.",
            "Warning",
            "Multiple roles can have the same position number. As a consequence\nof this, comparing via role position is prone to subtle bugs if\nchecking for role hierarchy. The recommended and correct way to\ncompare for roles in the hierarchy is using the comparison\noperators on the role objects themselves.",
            "int",
            "Indicates if the role is managed by the guild through some form of\nintegrations such as Twitch.",
            "bool",
            "Indicates if the role can be mentioned by users.",
            "bool",
            "The role tags associated with this role.",
            "Optional[RoleTags]",
            "The role’s unicode emoji.\nOnly available to guilds that contain ROLE_ICONS in Guild.features.",
            "New in version 2.0.",
            "Optional[str]",
            "Extra attributes of the role.",
            "New in version 2.6.",
            "RoleFlags",
            "guild (Guild) –",
            "state (ConnectionState) –",
            "data (Role) –",
            "Checks if the role is the default role.",
            "bool",
            "Whether the role is associated with a bot.\n:rtype: bool",
            "New in version 1.6.",
            "Whether the role is the premium subscriber, AKA “boost”, role for the guild.\n:rtype: bool",
            "New in version 1.6.",
            "Whether the role is managed by an integration.\n:rtype: bool",
            "New in version 1.6.",
            "Whether the role is able to be assigned or removed by the bot.\n:rtype: bool",
            "New in version 2.0.",
            "Returns the role’s permissions.",
            "Returns the role colour. An alias exists under color.",
            "Returns the role color. An alias exists under colour.",
            "Returns the role’s creation time in UTC.",
            "Returns a string that allows you to mention a role.",
            "Returns all the members with this role.",
            "Returns the role’s icon asset, if available.",
            "New in version 2.0.",
            "This function is a coroutine.",
            "Edits the role.",
            "You must have the manage_roles permission to\nuse this.",
            "All fields are optional.",
            "Changed in version 1.4: Can now pass int to colour keyword-only parameter.",
            "Changed in version 2.0: Edits are no longer in-place, the newly edited role is returned instead.\nAdded icon and unicode_emoji.",
            "name (str) – The new role name to change to.",
            "permissions (Permissions) – The new permissions to change to.",
            "colour (Union[Colour, int]) – The new colour to change to. (aliased to color as well)",
            "hoist (bool) – Indicates if the role should be shown separately in the member list.",
            "mentionable (bool) – Indicates if the role should be mentionable by others.",
            "position (int) – The new role’s position. This must be below your top role’s\nposition, or it will fail.",
            "reason (Optional[str]) – The reason for editing this role. Shows up on the audit log.",
            "icon (Optional[bytes]) – A bytes-like object representing the icon. Only PNG/JPEG/WebP is supported.\nIf this argument is passed, unicode_emoji is set to None.\nOnly available to guilds that contain ROLE_ICONS in Guild.features.\nCould be None to denote removal of the icon.",
            "unicode_emoji (Optional[str]) – The role’s unicode emoji. If this argument is passed, icon is set to None.\nOnly available to guilds that contain ROLE_ICONS in Guild.features.",
            "color (Colour | int) –",
            "The newly edited role.",
            "Role",
            "Forbidden – You do not have permissions to change the role.",
            "HTTPException – Editing the role failed.",
            "InvalidArgument – An invalid position was given or the default\n    role was asked to be moved.",
            "This function is a coroutine.",
            "Deletes the role.",
            "You must have the manage_roles permission to\nuse this.",
            "reason (Optional[str]) – The reason for deleting this role. Shows up on the audit log.",
            "Forbidden – You do not have permissions to delete the role.",
            "HTTPException – Deleting the role failed.",
            "None",
            "Represents tags on a role.",
            "A role tag is a piece of extra information attached to a managed role\nthat gives it context for the reason the role is managed.",
            "While this can be accessed, a useful interface is also provided in the\nRole and Guild classes as well.",
            "New in version 1.6.",
            "The bot’s user ID that manages this role.",
            "Optional[int]",
            "The integration ID that manages the role.",
            "Optional[int]",
            "data (RoleTags) –",
            "Whether the role is associated with a bot.",
            "bool",
            "Whether the role is the premium subscriber, AKA “boost”, role for the guild.",
            "bool",
            "Whether the role is managed by an integration.",
            "bool"
        ],
        "code": [
            "Guild",
            "int",
            "str",
            "Guild",
            "bool",
            "int",
            "bool",
            "bool",
            "RoleTags",
            "ROLE_ICONS",
            "Guild.features",
            "str",
            "RoleFlags",
            "Guild",
            "ConnectionState",
            "Role",
            "bool",
            "bool",
            "bool",
            "bool",
            "bool",
            "color",
            "colour",
            "manage_roles",
            "int",
            "colour",
            "icon",
            "unicode_emoji",
            "str",
            "Permissions",
            "Colour",
            "int",
            "bool",
            "bool",
            "int",
            "str",
            "bytes",
            "unicode_emoji",
            "ROLE_ICONS",
            "Guild.features",
            "None",
            "str",
            "icon",
            "ROLE_ICONS",
            "Guild.features",
            "Role",
            "manage_roles",
            "str",
            "Role",
            "Guild",
            "int",
            "int",
            "RoleTags",
            "bool",
            "bool",
            "bool"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Scheduled Event#",
        "content": [
            "Represents a Discord Guild Scheduled Event.",
            "Checks if two scheduled events are equal.",
            "Checks if two scheduled events are not equal.",
            "Returns the scheduled event’s hash.",
            "Returns the scheduled event’s name.",
            "New in version 2.0.",
            "The guild where the scheduled event is happening.",
            "Guild",
            "The name of the scheduled event.",
            "str",
            "The description of the scheduled event.",
            "Optional[str]",
            "The time when the event will start",
            "datetime.datetime",
            "The time when the event is supposed to end.",
            "Optional[datetime.datetime]",
            "The status of the scheduled event.",
            "ScheduledEventStatus",
            "The location of the event.\nSee ScheduledEventLocation for more information.",
            "ScheduledEventLocation",
            "The number of users that have marked themselves as interested in the event.",
            "Optional[int]",
            "The ID of the user who created the event.\nIt may be None because events created before October 25th, 2021 haven’t\nhad their creators tracked.",
            "Optional[int]",
            "The resolved user object of who created the event.",
            "Optional[User]",
            "The privacy level of the event. Currently, the only possible value\nis ScheduledEventPrivacyLevel.guild_only, which is default,\nso there is no need to use this attribute.",
            "ScheduledEventPrivacyLevel",
            "state (ConnectionState) –",
            "guild (Guild) –",
            "creator (Member | None) –",
            "data (ScheduledEventPayload) –",
            "Returns the scheduled event’s creation time in UTC.",
            "An alias to subscriber_count",
            "The url to reference the scheduled event.",
            "Returns the scheduled event cover image asset, if available.",
            "This function is a coroutine.",
            "Edits the Scheduled Event’s data",
            "All parameters are optional unless location.type is\nScheduledEventLocationType.external, then end_time\nis required.",
            "Will return a new ScheduledEvent object if applicable.",
            "name (str) – The new name of the event.",
            "description (str) – The new description of the event.",
            "location (ScheduledEventLocation) – The location of the event.",
            "status (ScheduledEventStatus) – The status of the event. It is recommended, however,\nto use start(), complete(), and\ncancel() to edit statuses instead.",
            "start_time (datetime.datetime) – The new starting time for the event.",
            "end_time (datetime.datetime) – The new ending time of the event.",
            "privacy_level (ScheduledEventPrivacyLevel) – The privacy level of the event. Currently, the only possible value\nis ScheduledEventPrivacyLevel.guild_only, which is default,\nso there is no need to change this parameter.",
            "reason (Optional[str]) – The reason to show in the audit log.",
            "cover (Optional[bytes]) – The cover image of the scheduled event.",
            "The newly updated scheduled event object. This is only returned when certain\nfields are updated.",
            "Optional[ScheduledEvent]",
            "Forbidden – You do not have the Manage Events permission.",
            "HTTPException – The operation failed.",
            "This function is a coroutine.",
            "Deletes the scheduled event.",
            "Forbidden – You do not have the Manage Events permission.",
            "HTTPException – The operation failed.",
            "None",
            "This function is a coroutine.",
            "Starts the scheduled event. Shortcut from edit().",
            "Note",
            "This method can only be used if status is ScheduledEventStatus.scheduled.",
            "reason (Optional[str]) – The reason to show in the audit log.",
            "The newly updated scheduled event object.",
            "Optional[ScheduledEvent]",
            "Forbidden – You do not have the Manage Events permission.",
            "HTTPException – The operation failed.",
            "This function is a coroutine.",
            "Ends/completes the scheduled event. Shortcut from edit().",
            "Note",
            "This method can only be used if status is ScheduledEventStatus.active.",
            "reason (Optional[str]) – The reason to show in the audit log.",
            "The newly updated scheduled event object.",
            "Optional[ScheduledEvent]",
            "Forbidden – You do not have the Manage Events permission.",
            "HTTPException – The operation failed.",
            "This function is a coroutine.",
            "Cancels the scheduled event. Shortcut from edit().",
            "Note",
            "This method can only be used if status is ScheduledEventStatus.scheduled.",
            "reason (Optional[str]) – The reason to show in the audit log.",
            "The newly updated scheduled event object.",
            "Optional[ScheduledEvent]",
            "Forbidden – You do not have the Manage Events permission.",
            "HTTPException – The operation failed.",
            "Returns an AsyncIterator representing the users or members subscribed to the event.",
            "The after and before parameters must represent member\nor user objects and meet the abc.Snowflake abc.",
            "Note",
            "Even is as_member is set to True, if the user\nis outside the guild, it will be a User object.",
            "limit (Optional[int]) – The maximum number of results to return.",
            "as_member (Optional[bool]) – Whether to fetch Member objects instead of user objects.\nThere may still be User objects if the user is outside\nthe guild.",
            "before (Optional[Union[abc.Snowflake, datetime.datetime]]) – Retrieves users before this date or object. If a datetime is provided,\nit is recommended to use a UTC aware datetime. If the datetime is naive,\nit is assumed to be local time.",
            "after (Optional[Union[abc.Snowflake, datetime.datetime]]) – Retrieves users after this date or object. If a datetime is provided,\nit is recommended to use a UTC aware datetime. If the datetime is naive,\nit is assumed to be local time.",
            "Union[User, Member] – The subscribed Member. If as_member is set to\nFalse or the user is outside the guild, it will be a\nUser object.",
            "HTTPException – Fetching the subscribed users failed.",
            "ScheduledEventSubscribersIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "Getting members instead of user objects:",
            "Represents a scheduled event’s location.",
            "Setting the value to its corresponding type will set the location type automatically:",
            "Type of Input",
            "Location Type",
            "StageChannel\nVoiceChannel\nstr",
            "ScheduledEventLocationType.stage_instance\nScheduledEventLocationType.voice\nScheduledEventLocationType.external",
            "New in version 2.0.",
            "The actual location of the scheduled event.",
            "Union[str, StageChannel, VoiceChannel, Object]",
            "The type of location.",
            "ScheduledEventLocationType",
            "state (ConnectionState) –",
            "value (str | int | StageChannel | VoiceChannel) –"
        ],
        "code": [
            "Guild",
            "str",
            "str",
            "datetime.datetime",
            "datetime.datetime",
            "ScheduledEventStatus",
            "ScheduledEventLocation",
            "ScheduledEventLocation",
            "int",
            "None",
            "int",
            "User",
            "ScheduledEventPrivacyLevel.guild_only",
            "ScheduledEventPrivacyLevel",
            "subscriber_count",
            "location.type",
            "ScheduledEventLocationType.external",
            "end_time",
            "ScheduledEvent",
            "str",
            "str",
            "ScheduledEventLocation",
            "ScheduledEventStatus",
            "start()",
            "complete()",
            "cancel()",
            "datetime.datetime",
            "datetime.datetime",
            "ScheduledEventPrivacyLevel",
            "ScheduledEventPrivacyLevel.guild_only",
            "str",
            "bytes",
            "ScheduledEvent",
            "None",
            "edit()",
            "status",
            "ScheduledEventStatus.scheduled",
            "str",
            "ScheduledEvent",
            "edit()",
            "status",
            "ScheduledEventStatus.active",
            "str",
            "ScheduledEvent",
            "edit()",
            "status",
            "ScheduledEventStatus.scheduled",
            "str",
            "ScheduledEvent",
            "AsyncIterator",
            "after",
            "before",
            "abc.Snowflake",
            "as_member",
            "True",
            "User",
            "int",
            "bool",
            "Member",
            "User",
            "abc.Snowflake",
            "datetime.datetime",
            "abc.Snowflake",
            "datetime.datetime",
            "User",
            "Member",
            "Member",
            "as_member",
            "False",
            "User",
            "async for user in event.subscribers(limit=100):\n    print(user.name)",
            "users = await event.subscribers(limit=100).flatten()\n# users is now a list of User...",
            "async for member in event.subscribers(limit=100, as_member=True):\n    print(member.display_name)",
            "value",
            "StageChannel",
            "VoiceChannel",
            "str",
            "ScheduledEventLocationType.stage_instance",
            "ScheduledEventLocationType.voice",
            "ScheduledEventLocationType.external",
            "str",
            "StageChannel",
            "VoiceChannel",
            "Object",
            "ScheduledEventLocationType"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Welcome Screen#",
        "content": [
            "Represents the welcome screen of a guild.",
            "New in version 2.0.",
            "The description text displayed on the welcome screen.",
            "str",
            "A list of channels displayed on welcome screen.",
            "List[WelcomeScreenChannel]",
            "data (WelcomeScreen) –",
            "guild (Guild) –",
            "Indicates whether the welcome screen is enabled or not.",
            "The guild this welcome screen belongs to.",
            "This function is a coroutine.",
            "Edits the welcome screen.",
            "You must have the manage_guild permission in the\nguild to do this.",
            "description (Optional[str]) – The new description of welcome screen.",
            "welcome_channels (Optional[List[WelcomeScreenChannel]]) – The welcome channels. The order of the channels would be same as the passed list order.",
            "enabled (Optional[bool]) – Whether the welcome screen should be displayed.",
            "reason (Optional[str]) – The reason that shows up on Audit log.",
            "HTTPException – Editing the welcome screen failed somehow.",
            "Forbidden – You don’t have permissions to edit the welcome screen.",
            "NotFound – This welcome screen does not exist.",
            "Example",
            "Note",
            "Welcome channels can only accept custom emojis if premium_tier is level 2 or above.",
            "Represents a welcome channel displayed on WelcomeScreen",
            "New in version 2.0.",
            "The channel that is being referenced.",
            "abc.Snowflake",
            "The description of the channel that is shown on the welcome screen.",
            "str",
            "The emoji of the channel that is shown on welcome screen.",
            "Union[Emoji, PartialEmoji, str]",
            "channel (Snowflake) –",
            "description (str) –",
            "emoji (Emoji | PartialEmoji | str) –"
        ],
        "code": [
            "str",
            "WelcomeScreenChannel",
            "WelcomeScreen",
            "Guild",
            "manage_guild",
            "str",
            "WelcomeScreenChannel",
            "bool",
            "str",
            "rules_channel = guild.get_channel(12345678)\nannouncements_channel = guild.get_channel(87654321)\ncustom_emoji = utils.get(guild.emojis, name='loudspeaker')\nawait welcome_screen.edit(\n    description='This is a very cool community server!',\n    welcome_channels=[\n        WelcomeChannel(channel=rules_channel, description='Read the rules!', emoji='👨‍🏫'),\n        WelcomeChannel(channel=announcements_channel, description='Watch out for announcements!',\n                       emoji=custom_emoji),\n    ]\n)",
            "premium_tier",
            "WelcomeScreen",
            "abc.Snowflake",
            "str",
            "Emoji",
            "PartialEmoji",
            "str"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Onboarding#",
        "content": [
            "Represents the onboarding flow for a guild.",
            "New in version 2.5.",
            "A list of prompts displayed in the onboarding flow.",
            "List[OnboardingPrompt]",
            "Whether onboarding is enabled in the guild.",
            "bool",
            "The current onboarding mode.",
            "OnboardingMode",
            "data (Onboarding) –",
            "guild (Guild) –",
            "The channels that members are opted into by default.",
            "If a channel is not found in the guild’s cache,\nthen it will be returned as an Object.",
            "This function is a coroutine.",
            "Edits this onboarding flow.",
            "You must have the manage_guild and manage_roles permissions in the\nguild to do this.",
            "prompts (Optional[List[OnboardingPrompt]]) – The new list of prompts for this flow.",
            "default_channels (Optional[List[Snowflake]]) – The new default channels that users are opted into.",
            "enabled (Optional[bool]) – Whether onboarding should be enabled. Setting this to True requires\nthe guild to have COMMUNITY in features and at\nleast 7 default_channels.",
            "mode (Optional[OnboardingMode]) – The new onboarding mode.",
            "reason (Optional[str]) – The reason for editing this onboarding flow. Shows up on the audit log.",
            "The updated onboarding flow.",
            "Onboarding",
            "HTTPException – Editing the onboarding flow failed somehow.",
            "Forbidden – You don’t have permissions to edit the onboarding flow.",
            "This function is a coroutine.",
            "Adds a new onboarding prompt.",
            "You must have the manage_guild and manage_roles permissions in the\nguild to do this.",
            "type (PromptType) – The type of onboarding prompt.",
            "title (str) – The prompt’s title.",
            "options (List[PromptOption]) – The list of options available in the prompt.",
            "single_select (bool) – Whether the user is limited to selecting one option on this prompt.",
            "required (bool) – Whether the user is required to answer this prompt.",
            "in_onboarding (bool) – Whether this prompt is displayed in the initial onboarding flow.",
            "reason (Optional[str]) – The reason for adding this prompt. Shows up on the audit log.",
            "The updated onboarding flow.",
            "Onboarding",
            "HTTPException – Editing the onboarding flow failed somehow.",
            "Forbidden – You don’t have permissions to edit the onboarding flow.",
            "This function is a coroutine.",
            "Append an onboarding prompt onto this flow.",
            "You must have the manage_guild and manage_roles permissions in the\nguild to do this.",
            "prompt (OnboardingPrompt) – The onboarding prompt to append.",
            "reason (Optional[str]) – The reason for appending this prompt. Shows up on the audit log.",
            "The updated onboarding flow.",
            "Onboarding",
            "HTTPException – Editing the onboarding flow failed somehow.",
            "Forbidden – You don’t have permissions to edit the onboarding flow.",
            "This function is a coroutine.",
            "Get an onboarding prompt with the given ID.",
            "id (int) – The ID of the prompt to get.",
            "The matching prompt, or None if it didn’t exist.",
            "OnboardingPrompt",
            "This function is a coroutine.",
            "Delete an onboarding prompt with the given ID.",
            "You must have the manage_guild and manage_roles permissions in the\nguild to do this.",
            "id (int) – The ID of the prompt to delete.",
            "reason (Optional[str]) – The reason for deleting this prompt. Shows up on the audit log.",
            "The updated onboarding flow.",
            "Onboarding",
            "ValueError – No prompt with this ID exists.",
            "HTTPException – Editing the onboarding flow failed somehow.",
            "Forbidden – You don’t have permissions to edit the onboarding flow.",
            "Represents an onboarding prompt displayed in Onboarding.",
            "New in version 2.5.",
            "The id of the prompt.",
            "int",
            "The type of onboarding prompt.",
            "PromptType",
            "The prompt’s title.",
            "str",
            "The list of options available in the prompt.",
            "List[PromptOption]",
            "Whether the user is limited to selecting one option on this prompt.",
            "bool",
            "Whether the user is required to answer this prompt.",
            "bool",
            "Whether this prompt is displayed in the initial onboarding flow.",
            "bool",
            "Represents an onboarding prompt option displayed in OnboardingPrompt.",
            "New in version 2.5.",
            "The id of the prompt option.",
            "int",
            "The channels assigned to the user when they select this option.",
            "List[Snowflake]",
            "The roles assigned to the user when they select this option.",
            "List[Snowflake]",
            "The emoji displayed with the option.",
            "Union[Emoji, PartialEmoji]",
            "The option’s title.",
            "str",
            "The option’s description.",
            "Optional[str]"
        ],
        "code": [
            "OnboardingPrompt",
            "bool",
            "OnboardingMode",
            "Onboarding",
            "Guild",
            "Object",
            "manage_guild",
            "manage_roles",
            "OnboardingPrompt",
            "Snowflake",
            "bool",
            "True",
            "COMMUNITY",
            "features",
            "default_channels",
            "OnboardingMode",
            "str",
            "Onboarding",
            "manage_guild",
            "manage_roles",
            "PromptType",
            "str",
            "PromptOption",
            "bool",
            "bool",
            "bool",
            "str",
            "Onboarding",
            "manage_guild",
            "manage_roles",
            "OnboardingPrompt",
            "str",
            "Onboarding",
            "int",
            "OnboardingPrompt",
            "manage_guild",
            "manage_roles",
            "int",
            "str",
            "Onboarding",
            "Onboarding",
            "int",
            "PromptType",
            "str",
            "PromptOption",
            "bool",
            "bool",
            "bool",
            "OnboardingPrompt",
            "int",
            "Snowflake",
            "Snowflake",
            "Emoji",
            "PartialEmoji",
            "str",
            "str"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Integration#",
        "content": [
            "Represents a guild integration.",
            "New in version 1.4.",
            "The integration ID.",
            "int",
            "The integration name.",
            "str",
            "The guild of the integration.",
            "Guild",
            "The integration type (i.e. Twitch).",
            "str",
            "Whether the integration is currently enabled.",
            "bool",
            "The account linked to this integration.",
            "IntegrationAccount",
            "The user that added this integration.",
            "User",
            "data (Union[BaseIntegration, StreamIntegration, BotIntegration]) –",
            "guild (Guild) –",
            "This function is a coroutine.",
            "Deletes the integration.",
            "You must have the manage_guild permission to\ndo this.",
            "reason (str) – The reason the integration was deleted. Shows up on the audit log.\n\nNew in version 2.0.",
            "The reason the integration was deleted. Shows up on the audit log.",
            "New in version 2.0.",
            "Forbidden – You do not have permission to delete the integration.",
            "HTTPException – Deleting the integration failed.",
            "None",
            "Represents an integration account.",
            "New in version 1.4.",
            "The account ID.",
            "str",
            "The account name.",
            "str",
            "data (IntegrationAccount) –",
            "Represents a bot integration on discord.",
            "New in version 2.0.",
            "The integration ID.",
            "int",
            "The integration name.",
            "str",
            "The guild of the integration.",
            "Guild",
            "The integration type (i.e. Twitch).",
            "str",
            "Whether the integration is currently enabled.",
            "bool",
            "The user that added this integration.",
            "User",
            "The integration account information.",
            "IntegrationAccount",
            "The application tied to this integration.",
            "IntegrationApplication",
            "data (Union[BaseIntegration, StreamIntegration, BotIntegration]) –",
            "guild (Guild) –",
            "Represents an application for a bot integration.",
            "New in version 2.0.",
            "The ID for this application.",
            "int",
            "The application’s name.",
            "str",
            "The application’s icon hash.",
            "Optional[str]",
            "The application’s description. Can be an empty string.",
            "str",
            "The summary of the application. Can be an empty string.",
            "str",
            "The bot user on this application.",
            "Optional[User]",
            "data (IntegrationApplication) –",
            "Represents a stream integration for Twitch or YouTube.",
            "New in version 2.0.",
            "The integration ID.",
            "int",
            "The integration name.",
            "str",
            "The guild of the integration.",
            "Guild",
            "The integration type (i.e. Twitch).",
            "str",
            "Whether the integration is currently enabled.",
            "bool",
            "Where the integration is currently syncing.",
            "bool",
            "Whether emoticons should be synced for this integration (currently twitch only).",
            "Optional[bool]",
            "The behaviour of expiring subscribers. Aliased to expire_behavior as well.",
            "ExpireBehaviour",
            "The grace period (in days) for expiring subscribers.",
            "int",
            "The user for the integration.",
            "User",
            "The integration account information.",
            "IntegrationAccount",
            "An aware UTC datetime representing when the integration was last synced.",
            "datetime.datetime",
            "data (Union[BaseIntegration, StreamIntegration, BotIntegration]) –",
            "guild (Guild) –",
            "An alias for expire_behaviour.",
            "The role which the integration uses for subscribers.",
            "This function is a coroutine.",
            "Edits the integration.",
            "You must have the manage_guild permission to\ndo this.",
            "expire_behaviour (ExpireBehaviour) – The behaviour when an integration subscription lapses. Aliased to expire_behavior as well.",
            "expire_grace_period (int) – The period (in days) where the integration will ignore lapsed subscriptions.",
            "enable_emoticons (bool) – Where emoticons should be synced for this integration (currently twitch only).",
            "Forbidden – You do not have permission to edit the integration.",
            "HTTPException – Editing the guild failed.",
            "InvalidArgument – expire_behaviour did not receive a ExpireBehaviour.",
            "None",
            "This function is a coroutine.",
            "Syncs the integration.",
            "You must have the manage_guild permission to\ndo this.",
            "Forbidden – You do not have permission to sync the integration.",
            "HTTPException – Syncing the integration failed.",
            "None"
        ],
        "code": [
            "int",
            "str",
            "Guild",
            "str",
            "bool",
            "IntegrationAccount",
            "User",
            "Union",
            "BaseIntegration",
            "StreamIntegration",
            "BotIntegration",
            "Guild",
            "manage_guild",
            "str",
            "str",
            "str",
            "IntegrationAccount",
            "int",
            "str",
            "Guild",
            "str",
            "bool",
            "User",
            "IntegrationAccount",
            "IntegrationApplication",
            "Union",
            "BaseIntegration",
            "StreamIntegration",
            "BotIntegration",
            "Guild",
            "int",
            "str",
            "str",
            "str",
            "str",
            "User",
            "IntegrationApplication",
            "int",
            "str",
            "Guild",
            "str",
            "bool",
            "bool",
            "bool",
            "expire_behavior",
            "ExpireBehaviour",
            "int",
            "User",
            "IntegrationAccount",
            "datetime.datetime",
            "Union",
            "BaseIntegration",
            "StreamIntegration",
            "BotIntegration",
            "Guild",
            "expire_behaviour",
            "manage_guild",
            "ExpireBehaviour",
            "expire_behavior",
            "int",
            "bool",
            "expire_behaviour",
            "ExpireBehaviour",
            "None",
            "manage_guild",
            "None"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Widget#",
        "content": [
            "Represents a Guild widget.",
            "Checks if two widgets are the same.",
            "Checks if two widgets are not the same.",
            "Returns the widget’s JSON URL.",
            "The guild’s ID.",
            "int",
            "The guild’s name.",
            "str",
            "The accessible voice channels in the guild.",
            "List[WidgetChannel]",
            "The online members in the server. Offline members\ndo not appear in the widget.",
            "Note",
            "Due to a Discord limitation, if this data is available\nthe users will be “anonymized” with linear IDs and discriminator\ninformation being incorrect. Likewise, the number of members\nretrieved is capped.",
            "List[Member]",
            "state (ConnectionState) –",
            "data (Widget) –",
            "Returns the member’s creation time in UTC.",
            "The JSON URL of the widget.",
            "The invite URL for the guild, if available.",
            "This function is a coroutine.",
            "Retrieves an Invite from the widget’s invite URL.\nThis is the same as Client.fetch_invite(); the invite\ncode is abstracted away.",
            "with_counts (bool) – Whether to include count information in the invite. This fills the\nInvite.approximate_member_count and Invite.approximate_presence_count\nfields.",
            "The invite from the widget’s invite URL.",
            "Invite",
            "Represents a “partial” widget channel.",
            "Checks if two partial channels are the same.",
            "Checks if two partial channels are not the same.",
            "Return the partial channel’s hash.",
            "Returns the partial channel’s name.",
            "The channel’s ID.",
            "int",
            "The channel’s name.",
            "str",
            "The channel’s position",
            "int",
            "id (int) –",
            "name (str) –",
            "position (int) –",
            "The string that allows you to mention the channel.",
            "Returns the channel’s creation time in UTC.",
            "Represents a “partial” member of the widget’s guild.",
            "Checks if two widget members are the same.",
            "Checks if two widget members are not the same.",
            "Return the widget member’s hash.",
            "Returns the widget member’s name#discriminator.",
            "The member’s ID.",
            "int",
            "The member’s username.",
            "str",
            "The member’s discriminator.",
            "str",
            "Whether the member is a bot.",
            "bool",
            "The member’s status.",
            "Status",
            "The member’s nickname.",
            "Optional[str]",
            "The member’s avatar hash.",
            "Optional[str]",
            "The member’s activity.",
            "Optional[Union[BaseActivity, Spotify]]",
            "Whether the member is currently deafened.",
            "Optional[bool]",
            "Whether the member is currently muted.",
            "Optional[bool]",
            "Whether the member is currently being suppressed.",
            "Optional[bool]",
            "Which channel the member is connected to.",
            "Optional[WidgetChannel]",
            "state (ConnectionState) –",
            "data (WidgetMemberPayload) –",
            "connected_channel (WidgetChannel | None) –",
            "Returns the member’s display name.",
            "Returns the user’s accent color, if applicable.",
            "There is an alias for this named accent_colour.",
            "New in version 2.0.",
            "Note",
            "This information is only available via Client.fetch_user().",
            "Returns the user’s accent colour, if applicable.",
            "There is an alias for this named accent_color.",
            "New in version 2.0.",
            "Note",
            "This information is only available via Client.fetch_user().",
            "Returns the user’s avatar decoration, if available.",
            "New in version 2.5.",
            "Returns the user’s banner asset, if available.",
            "New in version 2.0.",
            "Note",
            "This information is only available via Client.fetch_user().",
            "A property that returns a color denoting the rendered color\nfor the user. This always returns Colour.default().",
            "There is an alias for this named colour.",
            "A property that returns a colour denoting the rendered colour\nfor the user. This always returns Colour.default().",
            "There is an alias for this named color.",
            "Returns the user’s creation time in UTC.",
            "This is when the user’s Discord account was created.",
            "Returns the default avatar for a given user.\nThis is calculated by the user’s ID if they’re on the new username system, otherwise their discriminator.",
            "Returns the user’s display avatar.",
            "For regular users this is just their default avatar or uploaded avatar.",
            "New in version 2.0.",
            "Checks whether the user is already migrated to global name.",
            "Returns a URL that allows the client to jump to the user.",
            "New in version 2.0.",
            "Returns a string that allows you to mention the given user.",
            "Checks if the user is mentioned in the specified message.",
            "message (Message) – The message to check if you’re mentioned in.",
            "Indicates if the user is mentioned in the message.",
            "bool",
            "The publicly available flags the user has."
        ],
        "code": [
            "Guild",
            "int",
            "str",
            "WidgetChannel",
            "Member",
            "ConnectionState",
            "Widget",
            "Invite",
            "Client.fetch_invite()",
            "bool",
            "Invite.approximate_member_count",
            "Invite.approximate_presence_count",
            "Invite",
            "int",
            "str",
            "int",
            "int",
            "str",
            "int",
            "int",
            "str",
            "str",
            "bool",
            "Status",
            "str",
            "str",
            "BaseActivity",
            "Spotify",
            "bool",
            "bool",
            "bool",
            "WidgetChannel",
            "accent_colour",
            "Client.fetch_user()",
            "accent_color",
            "Client.fetch_user()",
            "Client.fetch_user()",
            "Colour.default()",
            "colour",
            "Colour.default()",
            "color",
            "Message",
            "bool"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Threads#",
        "content": [
            "Represents a Discord thread.",
            "Checks if two threads are equal.",
            "Checks if two threads are not equal.",
            "Returns the thread’s hash.",
            "Returns the thread’s name.",
            "New in version 2.0.",
            "The thread name.",
            "str",
            "The guild the thread belongs to.",
            "Guild",
            "The thread ID.",
            "Note",
            "This ID is the same as the thread starting message ID.",
            "int",
            "The parent TextChannel ID this thread belongs to.",
            "int",
            "The user’s ID that created this thread.",
            "int",
            "The last message ID of the message sent to this thread. It may\nnot point to an existing or valid message.",
            "Optional[int]",
            "The number of seconds a member must wait between sending messages\nin this thread. A value of 0 denotes that it is disabled.\nBots and users with manage_channels or\nmanage_messages bypass slowmode.",
            "int",
            "An approximate number of messages in this thread. This caps at 50.",
            "int",
            "An approximate number of members in this thread. This caps at 50.",
            "int",
            "A thread member representing yourself, if you’ve joined the thread.\nThis could not be available.",
            "Optional[ThreadMember]",
            "Whether the thread is archived.",
            "bool",
            "Whether the thread is locked.",
            "bool",
            "Whether non-moderators can add other non-moderators to this thread.\nThis is always True for public threads.",
            "bool",
            "The duration in minutes until the thread is automatically archived due to inactivity.\nUsually a value of 60, 1440, 4320 and 10080.",
            "int",
            "An aware timestamp of when the thread’s archived status was last updated in UTC.",
            "datetime.datetime",
            "An aware timestamp of when the thread was created.\nOnly available for threads created after 2022-01-09.",
            "Optional[datetime.datetime]",
            "Extra features of the thread.",
            "New in version 2.0.",
            "ChannelFlags",
            "Number of messages ever sent in a thread.\nIt’s similar to message_count on message creation,\nbut will not decrement the number when a message is deleted.",
            "New in version 2.3.",
            "int",
            "guild (Guild) –",
            "state (ConnectionState) –",
            "data (Thread) –",
            "Returns an AsyncIterator that enables receiving the destination’s message history.",
            "You must have read_message_history permissions to use this.",
            "limit (Optional[int]) – The number of messages to retrieve.\nIf None, retrieves every message in the channel. Note, however,\nthat this would make it a slow operation.",
            "before (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages before this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages after this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "around (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages around this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.\nWhen using this argument, the maximum limit is 101. Note that if the limit is an\neven number, then this will return at most limit + 1 messages.",
            "oldest_first (Optional[bool]) – If set to True, return messages in oldest->newest order. Defaults to True if\nafter is specified, otherwise False.",
            "Message – The message with the message data parsed.",
            "Forbidden – You do not have permissions to get channel message history.",
            "HTTPException – The request to get message history failed.",
            "HistoryIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "All parameters are optional.",
            "Returns a context manager that allows you to type for an indefinite period of time.",
            "This is useful for denoting long computations in your bot.\n:rtype: Typing",
            "Note",
            "This is both a regular context manager and an async context manager.\nThis means that both with and async with work with this.",
            "Example Usage:",
            "The channel’s Discord type.",
            "The parent channel this thread belongs to.",
            "The member this thread belongs to.",
            "The string that allows you to mention the thread.",
            "Returns a URL that allows the client to jump to the thread.",
            "New in version 2.0.",
            "A list of thread members in this thread, including the bot if it is a member of this thread.",
            "This requires Intents.members to be properly filled. Most of the time however,\nthis data is not provided by the gateway and a call to fetch_members() is\nneeded.",
            "A list of tags applied to this thread.",
            "This is only available for threads in forum channels.",
            "List[ForumTag]",
            "Returns the last message from this thread in cache.",
            "The message might not be valid or point to an existing message.",
            "Reliable Fetching",
            "For a slightly more reliable method of fetching the\nlast message, consider using either history()\nor fetch_message() with the last_message_id\nattribute.",
            "The last message in this channel or None if not found.",
            "Optional[Message]",
            "The category channel the parent channel belongs to, if applicable.",
            "The parent channel’s category.",
            "Optional[CategoryChannel]",
            "ClientException – The parent channel was not cached and returned None.",
            "The category channel ID the parent channel belongs to, if applicable.",
            "The parent channel’s category ID.",
            "Optional[int]",
            "ClientException – The parent channel was not cached and returned None.",
            "Returns the message that started this thread.",
            "The message might not be valid or point to an existing message.",
            "Note",
            "The ID for this message is the same as the thread ID.",
            "The message that started this thread or None if not found in the cache.",
            "Optional[Message]",
            "Whether the thread is pinned to the top of its parent forum channel.\n:rtype: bool",
            "New in version 2.3.",
            "Whether the thread is a private thread.",
            "A private thread is only viewable by those that have been explicitly\ninvited or have manage_threads.",
            "bool",
            "Whether the thread is a news thread.",
            "A news thread is a thread that has a parent that is a news channel,\ni.e. TextChannel.is_news() is True.",
            "bool",
            "Whether the thread is NSFW or not.",
            "An NSFW thread is a thread that has a parent that is an NSFW channel,\ni.e. TextChannel.is_nsfw() is True.",
            "bool",
            "Handles permission resolution for the Member\nor Role.",
            "Since threads do not have their own permissions, they inherit them\nfrom the parent channel. This is a convenience method for\ncalling permissions_for() on the\nparent channel.",
            "obj (Union[Member, Role]) – The object to resolve permissions for. This could be either\na member or a role. If it’s a role then member overwrites\nare not computed.",
            "The resolved permissions for the member or role.",
            "Permissions",
            "ClientException – The parent channel was not cached and returned None",
            "This function is a coroutine.",
            "Deletes a list of messages. This is similar to Message.delete()\nexcept it bulk deletes multiple messages.",
            "As a special case, if the number of messages is 0, then nothing\nis done. If the number of messages is 1 then single message\ndelete is done. If it’s more than two, then bulk delete is used.",
            "You cannot bulk delete more than 100 messages or messages that\nare older than 14 days old.",
            "You must have the manage_messages permission to\nuse this.",
            "Usable only by bot accounts.",
            "messages (Iterable[abc.Snowflake]) – An iterable of messages denoting which ones to bulk delete.",
            "reason (Optional[str]) – The reason for deleting the messages. Shows up on the audit log.",
            "ClientException – The number of messages to delete was more than 100.",
            "Forbidden – You do not have proper permissions to delete the messages, or\n    you’re not using a bot account.",
            "NotFound – If single delete, then the message was already deleted.",
            "HTTPException – Deleting the messages failed.",
            "None",
            "This function is a coroutine.",
            "Purges a list of messages that meet the criteria given by the predicate\ncheck. If a check is not provided then all messages are deleted\nwithout discrimination.",
            "You must have the manage_messages permission to\ndelete messages even if they are your own (unless you are a user\naccount). The read_message_history permission is\nalso needed to retrieve message history.",
            "limit (Optional[int]) – The number of messages to search through. This is not the number\nof messages that will be deleted, though it can be.",
            "check (Callable[[Message], bool]) – The function used to check if a message should be deleted.\nIt must take a Message as its sole parameter.",
            "before (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as before in history().",
            "after (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as after in history().",
            "around (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as around in history().",
            "oldest_first (Optional[bool]) – Same as oldest_first in history().",
            "bulk (bool) – If True, use bulk delete. Setting this to False is useful for mass-deleting\na bot’s own messages without Permissions.manage_messages. When True, will\nfall back to single delete if messages are older than two weeks.",
            "reason (Optional[str]) – The reason for deleting the messages. Shows up on the audit log.",
            "The list of messages that were deleted.",
            "List[Message]",
            "Forbidden – You do not have proper permissions to do the actions required.",
            "HTTPException – Purging the messages failed.",
            "Examples",
            "Deleting bot’s messages",
            "This function is a coroutine.",
            "Edits the thread.",
            "Editing the thread requires Permissions.manage_threads. The thread\ncreator can also edit name, archived or auto_archive_duration.\nNote that if the thread is locked then only those with Permissions.manage_threads\ncan send messages in it or unarchive a thread.",
            "The thread must be unarchived to be edited.",
            "name (str) – The new name of the thread.",
            "archived (bool) – Whether to archive the thread or not.",
            "locked (bool) – Whether to lock the thread or not.",
            "invitable (bool) – Whether non-moderators can add other non-moderators to this thread.\nOnly available for private threads.",
            "auto_archive_duration (int) – The new duration in minutes before a thread is automatically archived for inactivity.\nMust be one of 60, 1440, 4320, or 10080.",
            "slowmode_delay (int) – Specifies the slowmode rate limit for user in this thread, in seconds.\nA value of 0 disables slowmode. The maximum value possible is 21600.",
            "reason (Optional[str]) – The reason for editing this thread. Shows up on the audit log.",
            "pinned (bool) – Whether to pin the thread or not. This only works if the thread is part of a forum.",
            "applied_tags (List[ForumTag]) – The set of tags to apply to the thread. Each tag object should have an ID set.\n\nNew in version 2.3.",
            "The set of tags to apply to the thread. Each tag object should have an ID set.",
            "New in version 2.3.",
            "The newly edited thread.",
            "Thread",
            "Forbidden – You do not have permissions to edit the thread.",
            "HTTPException – Editing the thread failed.",
            "This function is a coroutine.",
            "Archives the thread. This is a shorthand of edit().",
            "locked (bool) – Whether to lock the thread on archive, Defaults to False.",
            "The updated thread.",
            "Thread",
            "This function is a coroutine.",
            "Unarchives the thread. This is a shorthand of edit().",
            "The updated thread.",
            "Thread",
            "This function is a coroutine.",
            "Joins this thread.",
            "You must have send_messages_in_threads to join a thread.\nIf the thread is private, manage_threads is also needed.",
            "Forbidden – You do not have permissions to join the thread.",
            "HTTPException – Joining the thread failed.",
            "This function is a coroutine.",
            "Leaves this thread.",
            "HTTPException – Leaving the thread failed.",
            "This function is a coroutine.",
            "Adds a user to this thread.",
            "You must have send_messages_in_threads\nto add a user to a public thread. If the thread is private and\ninvitable is False, then\nmanage_threads is required.",
            "user (abc.Snowflake) – The user to add to the thread.",
            "Forbidden – You do not have permissions to add the user to the thread.",
            "HTTPException – Adding the user to the thread failed.",
            "This function is a coroutine.",
            "Removes a user from this thread.",
            "You must have manage_threads or be the creator of the thread to remove a user.",
            "user (abc.Snowflake) – The user to remove from the thread.",
            "Forbidden – You do not have permissions to remove the user from the thread.",
            "HTTPException – Removing the user from the thread failed.",
            "This function is a coroutine.",
            "Retrieves all ThreadMember that are in this thread.",
            "This requires Intents.members to get information about members\nother than yourself.",
            "All thread members in the thread.",
            "List[ThreadMember]",
            "HTTPException – Retrieving the members failed.",
            "This function is a coroutine.",
            "Deletes this thread.",
            "You must have manage_threads to delete threads.",
            "Forbidden – You do not have permissions to delete this thread.",
            "HTTPException – Deleting the thread failed.",
            "Creates a PartialMessage from the message ID.",
            "This is useful if you want to work with a message and only have its ID without\ndoing an unnecessary API call.",
            "New in version 2.0.",
            "message_id (int) – The message ID to create a partial message for.",
            "The partial message.",
            "PartialMessage",
            "Returns a bool indicating whether you have the permissions to send the object(s).",
            "Indicates whether you have the permissions to send the object(s).",
            "bool",
            "TypeError – An invalid type has been passed.",
            "This function is a coroutine.",
            "Retrieves a single Message from the destination.",
            "id (int) – The message ID to look for.",
            "The message asked for.",
            "Message",
            "NotFound – The specified message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "This function is a coroutine.",
            "Retrieves all messages that are currently pinned in the channel.",
            "Note",
            "Due to a limitation with the Discord API, the Message\nobjects returned by this method do not contain complete\nMessage.reactions data.",
            "The messages that are currently pinned.",
            "List[Message]",
            "HTTPException – Retrieving the pinned messages failed.",
            "This function is a coroutine.",
            "Sends a message to the destination with the content given.",
            "The content must be a type that can convert to a string through str(content).\nIf the content is set to None (the default), then the embed parameter must\nbe provided.",
            "To upload a single file, the file parameter should be used with a\nsingle File object. To upload multiple files, the files\nparameter should be used with a list of File objects.\nSpecifying both parameters will lead to an exception.",
            "To upload a single embed, the embed parameter should be used with a\nsingle Embed object. To upload multiple embeds, the embeds\nparameter should be used with a list of Embed objects.\nSpecifying both parameters will lead to an exception.",
            "content (Optional[str]) – The content of the message to send.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "embed (Embed) – The rich embed for the content.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "nonce (Union[str, int]) – The nonce to use for sending this message. If the message was successfully sent,\nthen the message will have a nonce with this value.",
            "enforce_nonce (Optional[bool]) – Whether nonce is enforced to be validated.\n\nNew in version 2.5.",
            "Whether nonce is enforced to be validated.",
            "New in version 2.5.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent. If the deletion fails,\nthen it is silently ignored.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "New in version 1.4.",
            "reference (Union[Message, MessageReference, PartialMessage]) – A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.\n\nNew in version 1.6.",
            "A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.",
            "New in version 1.6.",
            "mention_author (Optional[bool]) – If set, overrides the replied_user attribute of allowed_mentions.\n\nNew in version 1.6.",
            "If set, overrides the replied_user attribute of allowed_mentions.",
            "New in version 1.6.",
            "view (discord.ui.View) – A Discord UI View to add to the message.",
            "embeds (List[Embed]) – A list of embeds to upload. Must be a maximum of 10.\n\nNew in version 2.0.",
            "A list of embeds to upload. Must be a maximum of 10.",
            "New in version 2.0.",
            "stickers (Sequence[Union[GuildSticker, StickerItem]]) – A list of stickers to upload. Must be a maximum of 3.\n\nNew in version 2.0.",
            "A list of stickers to upload. Must be a maximum of 3.",
            "New in version 2.0.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "silent (bool) – Whether to suppress push and desktop notifications for the message.\n\nNew in version 2.4.",
            "Whether to suppress push and desktop notifications for the message.",
            "New in version 2.4.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size,\n    you specified both file and files,\n    or you specified both embed and embeds,\n    or the reference object is not a Message,\n    MessageReference or PartialMessage.",
            "This function is a coroutine.",
            "Triggers a typing indicator to the destination.",
            "Typing indicator will go away after 10 seconds, or after a message is sent.",
            "None",
            "Represents a Discord thread member.",
            "Checks if two thread members are equal.",
            "Checks if two thread members are not equal.",
            "Returns the thread member’s hash.",
            "Returns the thread member’s name.",
            "New in version 2.0.",
            "The thread member’s ID.",
            "int",
            "The thread’s ID.",
            "int",
            "The time the member joined the thread in UTC.",
            "datetime.datetime",
            "parent (Thread) –",
            "data (ThreadMember) –",
            "The thread this member belongs to."
        ],
        "code": [
            "str",
            "Guild",
            "int",
            "TextChannel",
            "int",
            "int",
            "int",
            "manage_channels",
            "manage_messages",
            "int",
            "int",
            "int",
            "ThreadMember",
            "bool",
            "bool",
            "True",
            "bool",
            "int",
            "datetime.datetime",
            "datetime.datetime",
            "ChannelFlags",
            "int",
            "Guild",
            "ConnectionState",
            "Thread",
            "AsyncIterator",
            "read_message_history",
            "int",
            "None",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "bool",
            "True",
            "True",
            "after",
            "False",
            "Message",
            "counter = 0\nasync for message in channel.history(limit=200):\n    if message.author == client.user:\n        counter += 1",
            "messages = await channel.history(limit=123).flatten()\n# messages is now a list of Message...",
            "Typing",
            "with",
            "async with",
            "async with channel.typing():\n    # simulate something heavy\n    await asyncio.sleep(10)\n\nawait channel.send('done!')",
            "Intents.members",
            "fetch_members()",
            "ForumTag",
            "history()",
            "fetch_message()",
            "last_message_id",
            "None",
            "Message",
            "CategoryChannel",
            "None",
            "int",
            "None",
            "None",
            "Message",
            "bool",
            "manage_threads",
            "bool",
            "TextChannel.is_news()",
            "True",
            "bool",
            "TextChannel.is_nsfw()",
            "True",
            "bool",
            "Member",
            "Role",
            "permissions_for()",
            "Member",
            "Role",
            "Permissions",
            "None",
            "Message.delete()",
            "manage_messages",
            "abc.Snowflake",
            "str",
            "check",
            "check",
            "manage_messages",
            "read_message_history",
            "int",
            "Message",
            "bool",
            "Message",
            "abc.Snowflake",
            "datetime.datetime",
            "before",
            "history()",
            "abc.Snowflake",
            "datetime.datetime",
            "after",
            "history()",
            "abc.Snowflake",
            "datetime.datetime",
            "around",
            "history()",
            "bool",
            "oldest_first",
            "history()",
            "bool",
            "True",
            "False",
            "Permissions.manage_messages",
            "True",
            "str",
            "Message",
            "def is_me(m):\n    return m.author == client.user\n\ndeleted = await thread.purge(limit=100, check=is_me)\nawait thread.send(f'Deleted {len(deleted)} message(s)')",
            "Permissions.manage_threads",
            "name",
            "archived",
            "auto_archive_duration",
            "Permissions.manage_threads",
            "str",
            "bool",
            "bool",
            "bool",
            "int",
            "60",
            "1440",
            "4320",
            "10080",
            "int",
            "0",
            "21600",
            "str",
            "bool",
            "ForumTag",
            "Thread",
            "edit()",
            "bool",
            "False",
            "Thread",
            "edit()",
            "Thread",
            "send_messages_in_threads",
            "manage_threads",
            "send_messages_in_threads",
            "invitable",
            "False",
            "manage_threads",
            "abc.Snowflake",
            "manage_threads",
            "abc.Snowflake",
            "ThreadMember",
            "Intents.members",
            "ThreadMember",
            "manage_threads",
            "PartialMessage",
            "int",
            "PartialMessage",
            "bool",
            "bool",
            "Message",
            "int",
            "Message",
            "Message",
            "Message.reactions",
            "Message",
            "str(content)",
            "None",
            "embed",
            "file",
            "File",
            "files",
            "list",
            "File",
            "embed",
            "Embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "Embed",
            "File",
            "File",
            "str",
            "int",
            "bool",
            "nonce",
            "float",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "Message",
            "MessageReference",
            "PartialMessage",
            "Message",
            "to_reference()",
            "Message",
            "replied_user",
            "allowed_mentions",
            "mention_author",
            "bool",
            "replied_user",
            "allowed_mentions",
            "discord.ui.View",
            "Embed",
            "GuildSticker",
            "StickerItem",
            "bool",
            "bool",
            "Poll",
            "Message",
            "files",
            "file",
            "files",
            "embed",
            "embeds",
            "reference",
            "Message",
            "MessageReference",
            "PartialMessage",
            "None",
            "int",
            "int",
            "datetime.datetime",
            "Thread",
            "ThreadMember"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Stages#",
        "content": [
            "Represents a Discord guild stage channel.",
            "New in version 1.7.",
            "Checks if two channels are equal.",
            "Checks if two channels are not equal.",
            "Returns the channel’s hash.",
            "Returns the channel’s name.",
            "The channel name.",
            "str",
            "The guild the channel belongs to.",
            "Guild",
            "The channel ID.",
            "int",
            "The channel’s topic. None if it isn’t set.",
            "Optional[str]",
            "The category channel ID this channel belongs to, if applicable.",
            "Optional[int]",
            "The position in the channel list. This is a number that starts at 0. e.g. the\ntop channel is position 0. Can be None if the channel was received in an interaction.",
            "Optional[int]",
            "The channel’s preferred audio bitrate in bits per second.",
            "int",
            "The channel’s limit for number of members that can be in a stage channel.",
            "int",
            "The region for the stage channel’s voice communication.\nA value of None indicates automatic voice region detection.",
            "Optional[VoiceRegion]",
            "The camera video quality for the stage channel’s participants.",
            "New in version 2.0.",
            "VideoQualityMode",
            "Extra features of the channel.",
            "New in version 2.0.",
            "ChannelFlags",
            "The ID of the last message sent to this channel. It may not always point to an existing or valid message.\n.. versionadded:: 2.5",
            "Optional[int]",
            "state (ConnectionState) –",
            "guild (Guild) –",
            "data (VoiceChannelPayload | StageChannelPayload) –",
            "A list of members who are requesting to speak in the stage channel.",
            "A list of members who have been permitted to speak in the stage channel.",
            "New in version 2.0.",
            "A list of members who are listening in the stage channel.",
            "New in version 2.0.",
            "Checks if the channel is NSFW.",
            "bool",
            "Fetches the last message from this channel in cache.",
            "The message might not be valid or point to an existing message.",
            "Reliable Fetching",
            "For a slightly more reliable method of fetching the\nlast message, consider using either history()\nor fetch_message() with the last_message_id\nattribute.",
            "The last message in this channel or None if not found.",
            "Optional[Message]",
            "Creates a PartialMessage from the message ID.",
            "This is useful if you want to work with a message and only have its ID without\ndoing an unnecessary API call.",
            "New in version 1.6.",
            "message_id (int) – The message ID to create a partial message for.",
            "The partial message.",
            "PartialMessage",
            "This function is a coroutine.",
            "Deletes a list of messages. This is similar to Message.delete()\nexcept it bulk deletes multiple messages.",
            "As a special case, if the number of messages is 0, then nothing\nis done. If the number of messages is 1 then single message\ndelete is done. If it’s more than two, then bulk delete is used.",
            "You cannot bulk delete more than 100 messages or messages that\nare older than 14 days old.",
            "You must have the manage_messages permission to\nuse this.",
            "messages (Iterable[abc.Snowflake]) – An iterable of messages denoting which ones to bulk delete.",
            "reason (Optional[str]) – The reason for deleting the messages. Shows up on the audit log.",
            "ClientException – The number of messages to delete was more than 100.",
            "Forbidden – You do not have proper permissions to delete the messages.",
            "NotFound – If single delete, then the message was already deleted.",
            "HTTPException – Deleting the messages failed.",
            "None",
            "This function is a coroutine.",
            "Purges a list of messages that meet the criteria given by the predicate\ncheck. If a check is not provided then all messages are deleted\nwithout discrimination.",
            "You must have the manage_messages permission to\ndelete messages even if they are your own.\nThe read_message_history permission is\nalso needed to retrieve message history.",
            "limit (Optional[int]) – The number of messages to search through. This is not the number\nof messages that will be deleted, though it can be.",
            "check (Callable[[Message], bool]) – The function used to check if a message should be deleted.\nIt must take a Message as its sole parameter.",
            "before (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as before in history().",
            "after (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as after in history().",
            "around (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as around in history().",
            "oldest_first (Optional[bool]) – Same as oldest_first in history().",
            "bulk (bool) – If True, use bulk delete. Setting this to False is useful for mass-deleting\na bot’s own messages without Permissions.manage_messages. When True, will\nfall back to single delete if messages are older than two weeks.",
            "reason (Optional[str]) – The reason for deleting the messages. Shows up on the audit log.",
            "The list of messages that were deleted.",
            "List[Message]",
            "Forbidden – You do not have proper permissions to do the actions required.",
            "HTTPException – Purging the messages failed.",
            "Examples",
            "Deleting bot’s messages",
            "This function is a coroutine.",
            "Gets the list of webhooks from this channel.",
            "Requires manage_webhooks permissions.",
            "The webhooks for this channel.",
            "List[Webhook]",
            "Forbidden – You don’t have permissions to get the webhooks.",
            "This function is a coroutine.",
            "Creates a webhook for this channel.",
            "Requires manage_webhooks permissions.",
            "Changed in version 1.1: Added the reason keyword-only parameter.",
            "name (str) – The webhook’s name.",
            "avatar (Optional[bytes]) – A bytes-like object representing the webhook’s default avatar.\nThis operates similarly to edit().",
            "reason (Optional[str]) – The reason for creating this webhook. Shows up in the audit logs.",
            "The created webhook.",
            "Webhook",
            "HTTPException – Creating the webhook failed.",
            "Forbidden – You do not have permissions to create a webhook.",
            "A list of members who are moderating the stage channel.",
            "New in version 2.0.",
            "The channel’s Discord type.",
            "This function is a coroutine.",
            "Clones this channel. This creates a channel with the same properties\nas this channel.",
            "You must have the manage_channels permission to\ndo this.",
            "New in version 1.1.",
            "name (Optional[str]) – The name of the new channel. If not provided, defaults to this\nchannel name.",
            "reason (Optional[str]) – The reason for cloning this channel. Shows up on the audit log.",
            "The channel that was created.",
            "abc.GuildChannel",
            "Forbidden – You do not have the proper permissions to create this channel.",
            "HTTPException – Creating the channel failed.",
            "The running stage instance of the stage channel.",
            "New in version 2.0.",
            "This function is a coroutine.",
            "Create a stage instance.",
            "You must have the manage_channels permission to\nuse this.",
            "New in version 2.0.",
            "topic (str) – The stage instance’s topic.",
            "privacy_level (StagePrivacyLevel) – The stage instance’s privacy level. Defaults to StagePrivacyLevel.guild_only.",
            "reason (str) – The reason the stage instance was created. Shows up on the audit log.",
            "send_notification (bool) – Send a notification to everyone in the server that the stage instance has started.\nDefaults to False. Requires the mention_everyone permission.",
            "The newly created stage instance.",
            "StageInstance",
            "InvalidArgument – If the privacy_level parameter is not the proper type.",
            "Forbidden – You do not have permissions to create a stage instance.",
            "HTTPException – Creating a stage instance failed.",
            "This function is a coroutine.",
            "Gets the running StageInstance.",
            "New in version 2.0.",
            "The stage instance.",
            "StageInstance",
            "NotFound – The stage instance or channel could not be found.",
            "HTTPException – Getting the stage instance failed.",
            "This function is a coroutine.",
            "Edits the channel.",
            "You must have the manage_channels permission to\nuse this.",
            "Changed in version 2.0: The topic parameter must now be set via create_instance.",
            "Changed in version 2.0: Edits are no longer in-place, the newly edited channel is returned instead.",
            "name (str) – The new channel’s name.",
            "position (int) – The new channel’s position.",
            "sync_permissions (bool) – Whether to sync permissions with the channel’s new or pre-existing\ncategory. Defaults to False.",
            "category (Optional[CategoryChannel]) – The new category for this channel. Can be None to remove the\ncategory.",
            "reason (Optional[str]) – The reason for editing this channel. Shows up on the audit log.",
            "overwrites (Dict[Union[Role, Member, Snowflake], PermissionOverwrite]) – The overwrites to apply to channel permissions. Useful for creating secret channels.",
            "rtc_region (Optional[VoiceRegion]) – The new region for the stage channel’s voice communication.\nA value of None indicates automatic voice region detection.",
            "video_quality_mode (VideoQualityMode) – The camera video quality for the stage channel’s participants.\n\nNew in version 2.0.",
            "The camera video quality for the stage channel’s participants.",
            "New in version 2.0.",
            "The newly edited stage channel. If the edit was only positional\nthen None is returned instead.",
            "Optional[StageChannel]",
            "InvalidArgument – If the permission overwrite information is not in proper form.",
            "Forbidden – You do not have permissions to edit the channel.",
            "HTTPException – Editing the channel failed.",
            "Returns a bool indicating whether you have the permissions to send the object(s).",
            "Indicates whether you have the permissions to send the object(s).",
            "bool",
            "TypeError – An invalid type has been passed.",
            "The category this channel belongs to.",
            "If there is no category then this is None.",
            "Returns a list of roles that have been overridden from\ntheir default values in the roles attribute.",
            "This function is a coroutine.",
            "Connects to voice and creates a VoiceClient to establish\nyour connection to the voice server.",
            "This requires Intents.voice_states.",
            "timeout (float) – The timeout in seconds to wait for the voice endpoint.",
            "reconnect (bool) – Whether the bot should automatically attempt\na reconnect if a part of the handshake fails\nor the gateway goes down.",
            "cls (Type[VoiceProtocol]) – A type that subclasses VoiceProtocol to connect with.\nDefaults to VoiceClient.",
            "A voice client that is fully connected to the voice server.",
            "VoiceProtocol",
            "asyncio.TimeoutError – Could not connect to the voice channel in time.",
            "ClientException – You are already connected to a voice channel.",
            "OpusNotLoaded – The opus library has not been loaded.",
            "This function is a coroutine.",
            "Creates an instant invite from a text or voice channel.",
            "You must have the create_instant_invite permission to\ndo this.",
            "max_age (int) – How long the invite should last in seconds. If it’s 0 then the invite\ndoesn’t expire. Defaults to 0.",
            "max_uses (int) – How many uses the invite could be used for. If it’s 0 then there\nare unlimited uses. Defaults to 0.",
            "temporary (bool) – Denotes that the invite grants temporary membership\n(i.e. they get kicked after they disconnect). Defaults to False.",
            "unique (bool) – Indicates if a unique invite URL should be created. Defaults to True.\nIf this is set to False then it will return a previously created\ninvite.",
            "reason (Optional[str]) – The reason for creating this invite. Shows up on the audit log.",
            "target_type (Optional[InviteTarget]) – The type of target for the voice channel invite, if any.\n\nNew in version 2.0.",
            "The type of target for the voice channel invite, if any.",
            "New in version 2.0.",
            "target_user (Optional[User]) – The user whose stream to display for this invite, required if target_type is TargetType.stream.\nThe user must be streaming in the channel.\n\nNew in version 2.0.",
            "The user whose stream to display for this invite, required if target_type is TargetType.stream.\nThe user must be streaming in the channel.",
            "New in version 2.0.",
            "target_application_id (Optional[int]) – The id of the embedded application for the invite, required if target_type is\nTargetType.embedded_application.\n\nNew in version 2.0.",
            "The id of the embedded application for the invite, required if target_type is\nTargetType.embedded_application.",
            "New in version 2.0.",
            "target_event (Optional[ScheduledEvent]) – The scheduled event object to link to the event.\nShortcut to Invite.set_scheduled_event()\nSee Invite.set_scheduled_event() for more\ninfo on event invite linking.\n\nNew in version 2.0.",
            "The scheduled event object to link to the event.\nShortcut to Invite.set_scheduled_event()",
            "See Invite.set_scheduled_event() for more\ninfo on event invite linking.",
            "New in version 2.0.",
            "The invite that was created.",
            "Invite",
            "HTTPException – Invite creation failed.",
            "NotFound – The channel that was passed is a category or an invalid channel.",
            "Returns the channel’s creation time in UTC.",
            "This function is a coroutine.",
            "Deletes the channel.",
            "You must have manage_channels permission to use this.",
            "reason (Optional[str]) – The reason for deleting this channel.\nShows up on the audit log.",
            "Forbidden – You do not have proper permissions to delete the channel.",
            "NotFound – The channel was not found or was already deleted.",
            "HTTPException – Deleting the channel failed.",
            "None",
            "This function is a coroutine.",
            "Retrieves a single Message from the destination.",
            "id (int) – The message ID to look for.",
            "The message asked for.",
            "Message",
            "NotFound – The specified message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "Returns an AsyncIterator that enables receiving the destination’s message history.",
            "You must have read_message_history permissions to use this.",
            "limit (Optional[int]) – The number of messages to retrieve.\nIf None, retrieves every message in the channel. Note, however,\nthat this would make it a slow operation.",
            "before (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages before this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages after this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "around (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages around this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.\nWhen using this argument, the maximum limit is 101. Note that if the limit is an\neven number, then this will return at most limit + 1 messages.",
            "oldest_first (Optional[bool]) – If set to True, return messages in oldest->newest order. Defaults to True if\nafter is specified, otherwise False.",
            "Message – The message with the message data parsed.",
            "Forbidden – You do not have permissions to get channel message history.",
            "HTTPException – The request to get message history failed.",
            "HistoryIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "All parameters are optional.",
            "This function is a coroutine.",
            "Returns a list of all active instant invites from this channel.",
            "You must have manage_channels to get this information.",
            "The list of invites that are currently active.",
            "List[Invite]",
            "Forbidden – You do not have proper permissions to get the information.",
            "HTTPException – An error occurred while fetching the information.",
            "Returns a URL that allows the client to jump to the channel.",
            "New in version 2.0.",
            "Returns all members that are currently inside this voice channel.",
            "The string that allows you to mention the channel.",
            "This function is a coroutine.",
            "A rich interface to help move a channel relative to other channels.",
            "If exact position movement is required, edit should be used instead.",
            "You must have the manage_channels permission to\ndo this.",
            "Note",
            "Voice channels will always be sorted below text channels.\nThis is a Discord limitation.",
            "New in version 1.7.",
            "beginning (bool) – Whether to move the channel to the beginning of the\nchannel list (or category if given).\nThis is mutually exclusive with end, before, and after.",
            "end (bool) – Whether to move the channel to the end of the\nchannel list (or category if given).\nThis is mutually exclusive with beginning, before, and after.",
            "before (Snowflake) – The channel that should be before our current channel.\nThis is mutually exclusive with beginning, end, and after.",
            "after (Snowflake) – The channel that should be after our current channel.\nThis is mutually exclusive with beginning, end, and before.",
            "offset (int) – The number of channels to offset the move by. For example,\nan offset of 2 with beginning=True would move\nit 2 after the beginning. A positive number moves it below\nwhile a negative number moves it above. Note that this\nnumber is relative and computed after the beginning,\nend, before, and after parameters.",
            "category (Optional[Snowflake]) – The category to move this channel under.\nIf None is given then it moves it out of the category.\nThis parameter is ignored if moving a category channel.",
            "sync_permissions (bool) – Whether to sync the permissions with the category (if given).",
            "reason (str) – The reason for the move.",
            "InvalidArgument – An invalid position was given or a bad mix of arguments was passed.",
            "Forbidden – You do not have permissions to move the channel.",
            "HTTPException – Moving the channel failed.",
            "None",
            "Returns all of the channel’s overwrites.",
            "This is returned as a dictionary where the key contains the target which\ncan be either a Role or a Member and the value is the\noverwrite as a PermissionOverwrite.",
            "The channel’s permission overwrites.",
            "Dict[Union[Role, Member], PermissionOverwrite]",
            "Returns the channel-specific overwrites for a member or a role.",
            "obj (Union[Role, User]) – The role or user denoting\nwhose overwrite to get.",
            "The permission overwrites for this object.",
            "PermissionOverwrite",
            "Handles permission resolution for the Member\nor Role.",
            "This function takes into consideration the following cases:",
            "Guild owner",
            "Guild roles",
            "Channel overrides",
            "Member overrides",
            "If a Role is passed, then it checks the permissions\nsomeone with that role would have, which is essentially:",
            "The default role permissions",
            "The permissions of the role used as a parameter",
            "The default role permission overwrites",
            "The permission overwrites of the role used as a parameter",
            "Changed in version 2.0: The object passed in can now be a role object.",
            "obj (Union[Member, Role]) – The object to resolve permissions for. This could be either\na member or a role. If it’s a role then member overwrites\nare not computed.",
            "The resolved permissions for the member or role.",
            "Permissions",
            "Whether the permissions for this channel are synced with the\ncategory it belongs to.",
            "If there is no category then this is False.",
            "New in version 1.3.",
            "This function is a coroutine.",
            "Retrieves all messages that are currently pinned in the channel.",
            "Note",
            "Due to a limitation with the Discord API, the Message\nobjects returned by this method do not contain complete\nMessage.reactions data.",
            "The messages that are currently pinned.",
            "List[Message]",
            "HTTPException – Retrieving the pinned messages failed.",
            "This function is a coroutine.",
            "Sends a message to the destination with the content given.",
            "The content must be a type that can convert to a string through str(content).\nIf the content is set to None (the default), then the embed parameter must\nbe provided.",
            "To upload a single file, the file parameter should be used with a\nsingle File object. To upload multiple files, the files\nparameter should be used with a list of File objects.\nSpecifying both parameters will lead to an exception.",
            "To upload a single embed, the embed parameter should be used with a\nsingle Embed object. To upload multiple embeds, the embeds\nparameter should be used with a list of Embed objects.\nSpecifying both parameters will lead to an exception.",
            "content (Optional[str]) – The content of the message to send.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "embed (Embed) – The rich embed for the content.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "nonce (Union[str, int]) – The nonce to use for sending this message. If the message was successfully sent,\nthen the message will have a nonce with this value.",
            "enforce_nonce (Optional[bool]) – Whether nonce is enforced to be validated.\n\nNew in version 2.5.",
            "Whether nonce is enforced to be validated.",
            "New in version 2.5.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent. If the deletion fails,\nthen it is silently ignored.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "New in version 1.4.",
            "reference (Union[Message, MessageReference, PartialMessage]) – A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.\n\nNew in version 1.6.",
            "A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.",
            "New in version 1.6.",
            "mention_author (Optional[bool]) – If set, overrides the replied_user attribute of allowed_mentions.\n\nNew in version 1.6.",
            "If set, overrides the replied_user attribute of allowed_mentions.",
            "New in version 1.6.",
            "view (discord.ui.View) – A Discord UI View to add to the message.",
            "embeds (List[Embed]) – A list of embeds to upload. Must be a maximum of 10.\n\nNew in version 2.0.",
            "A list of embeds to upload. Must be a maximum of 10.",
            "New in version 2.0.",
            "stickers (Sequence[Union[GuildSticker, StickerItem]]) – A list of stickers to upload. Must be a maximum of 3.\n\nNew in version 2.0.",
            "A list of stickers to upload. Must be a maximum of 3.",
            "New in version 2.0.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "silent (bool) – Whether to suppress push and desktop notifications for the message.\n\nNew in version 2.4.",
            "Whether to suppress push and desktop notifications for the message.",
            "New in version 2.4.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size,\n    you specified both file and files,\n    or you specified both embed and embeds,\n    or the reference object is not a Message,\n    MessageReference or PartialMessage.",
            "This function is a coroutine.",
            "Sets the channel specific permission overwrites for a target in the\nchannel.",
            "The target parameter should either be a Member or a\nRole that belongs to guild.",
            "The overwrite parameter, if given, must either be None or\nPermissionOverwrite. For convenience, you can pass in\nkeyword arguments denoting Permissions attributes. If this is\ndone, then you cannot mix the keyword arguments with the overwrite\nparameter.",
            "If the overwrite parameter is None, then the permission\noverwrites are deleted.",
            "You must have the manage_roles permission to use this.",
            "Note",
            "This method replaces the old overwrites with the ones given.",
            "Examples",
            "Setting allow and deny:",
            "Deleting overwrites",
            "Using PermissionOverwrite",
            "target (Union[Member, Role]) – The member or role to overwrite permissions for.",
            "overwrite (Optional[PermissionOverwrite]) – The permissions to allow and deny to the target, or None to\ndelete the overwrite.",
            "**permissions – A keyword argument list of permissions to set for ease of use.\nCannot be mixed with overwrite.",
            "reason (Optional[str]) – The reason for doing this action. Shows up on the audit log.",
            "Forbidden – You do not have permissions to edit channel specific permissions.",
            "HTTPException – Editing channel specific permissions failed.",
            "NotFound – The role or member being edited is not part of the guild.",
            "InvalidArgument – The overwrite parameter invalid or the target type was not\n    Role or Member.",
            "This function is a coroutine.",
            "Triggers a typing indicator to the destination.",
            "Typing indicator will go away after 10 seconds, or after a message is sent.",
            "None",
            "Returns a context manager that allows you to type for an indefinite period of time.",
            "This is useful for denoting long computations in your bot.\n:rtype: Typing",
            "Note",
            "This is both a regular context manager and an async context manager.\nThis means that both with and async with work with this.",
            "Example Usage:",
            "Returns a mapping of member IDs who have voice states in this channel.",
            "New in version 1.3.",
            "Note",
            "This function is intentionally low level to replace members\nwhen the member cache is unavailable.",
            "The mapping of member ID to a voice state.",
            "Mapping[int, VoiceState]",
            "Represents a stage instance of a stage channel in a guild.",
            "New in version 2.0.",
            "Checks if two stage instances are equal.",
            "Checks if two stage instances are not equal.",
            "Returns the stage instance’s hash.",
            "The stage instance’s ID.",
            "int",
            "The guild that the stage instance is running in.",
            "Guild",
            "The ID of the channel that the stage instance is running in.",
            "int",
            "The topic of the stage instance.",
            "str",
            "The privacy level of the stage instance.",
            "StagePrivacyLevel",
            "Whether discoverability for the stage instance is disabled.",
            "bool",
            "The scheduled event linked with the stage instance, if any.",
            "Optional[ScheduledEvent]",
            "state (ConnectionState) –",
            "guild (Guild) –",
            "data (StageInstance) –",
            "The channel that stage instance is running in.",
            "This function is a coroutine.",
            "Edits the stage instance.",
            "You must have the manage_channels permission to\nuse this.",
            "topic (str) – The stage instance’s new topic.",
            "privacy_level (StagePrivacyLevel) – The stage instance’s new privacy level.",
            "reason (str) – The reason the stage instance was edited. Shows up on the audit log.",
            "InvalidArgument – If the privacy_level parameter is not the proper type.",
            "Forbidden – You do not have permissions to edit the stage instance.",
            "HTTPException – Editing a stage instance failed.",
            "None",
            "This function is a coroutine.",
            "Deletes the stage instance.",
            "You must have the manage_channels permission to\nuse this.",
            "reason (str) – The reason the stage instance was deleted. Shows up on the audit log.",
            "Forbidden – You do not have permissions to delete the stage instance.",
            "HTTPException – Deleting the stage instance failed.",
            "None"
        ],
        "code": [
            "str",
            "Guild",
            "int",
            "None",
            "str",
            "int",
            "None",
            "int",
            "int",
            "int",
            "None",
            "VoiceRegion",
            "VideoQualityMode",
            "ChannelFlags",
            "int",
            "bool",
            "history()",
            "fetch_message()",
            "last_message_id",
            "None",
            "Message",
            "PartialMessage",
            "int",
            "PartialMessage",
            "Message.delete()",
            "manage_messages",
            "abc.Snowflake",
            "str",
            "check",
            "check",
            "manage_messages",
            "read_message_history",
            "int",
            "Message",
            "bool",
            "Message",
            "abc.Snowflake",
            "datetime.datetime",
            "before",
            "history()",
            "abc.Snowflake",
            "datetime.datetime",
            "after",
            "history()",
            "abc.Snowflake",
            "datetime.datetime",
            "around",
            "history()",
            "bool",
            "oldest_first",
            "history()",
            "bool",
            "True",
            "False",
            "Permissions.manage_messages",
            "True",
            "str",
            "Message",
            "def is_me(m):\n    return m.author == client.user\n\ndeleted = await channel.purge(limit=100, check=is_me)\nawait channel.send(f'Deleted {len(deleted)} message(s)')",
            "manage_webhooks",
            "Webhook",
            "manage_webhooks",
            "reason",
            "str",
            "bytes",
            "edit()",
            "str",
            "Webhook",
            "manage_channels",
            "str",
            "str",
            "abc.GuildChannel",
            "manage_channels",
            "str",
            "StagePrivacyLevel",
            "StagePrivacyLevel.guild_only",
            "str",
            "bool",
            "False",
            "mention_everyone",
            "StageInstance",
            "privacy_level",
            "StageInstance",
            "StageInstance",
            "manage_channels",
            "topic",
            "create_instance",
            "str",
            "int",
            "bool",
            "False",
            "CategoryChannel",
            "None",
            "str",
            "Role",
            "Member",
            "Snowflake",
            "PermissionOverwrite",
            "VoiceRegion",
            "None",
            "VideoQualityMode",
            "None",
            "StageChannel",
            "bool",
            "bool",
            "None",
            "roles",
            "VoiceClient",
            "Intents.voice_states",
            "float",
            "bool",
            "VoiceProtocol",
            "VoiceProtocol",
            "VoiceClient",
            "VoiceProtocol",
            "create_instant_invite",
            "int",
            "0",
            "int",
            "0",
            "bool",
            "False",
            "bool",
            "False",
            "str",
            "InviteTarget",
            "User",
            "int",
            "ScheduledEvent",
            "Invite.set_scheduled_event()",
            "Invite.set_scheduled_event()",
            "Invite",
            "manage_channels",
            "str",
            "Message",
            "int",
            "Message",
            "AsyncIterator",
            "read_message_history",
            "int",
            "None",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "bool",
            "True",
            "True",
            "after",
            "False",
            "Message",
            "counter = 0\nasync for message in channel.history(limit=200):\n    if message.author == client.user:\n        counter += 1",
            "messages = await channel.history(limit=123).flatten()\n# messages is now a list of Message...",
            "manage_channels",
            "Invite",
            "edit",
            "manage_channels",
            "bool",
            "end",
            "before",
            "after",
            "bool",
            "beginning",
            "before",
            "after",
            "Snowflake",
            "beginning",
            "end",
            "after",
            "Snowflake",
            "beginning",
            "end",
            "before",
            "int",
            "2",
            "beginning=True",
            "beginning",
            "end",
            "before",
            "after",
            "Snowflake",
            "None",
            "bool",
            "str",
            "None",
            "Role",
            "Member",
            "PermissionOverwrite",
            "Role",
            "Member",
            "PermissionOverwrite",
            "Role",
            "User",
            "PermissionOverwrite",
            "Member",
            "Role",
            "Role",
            "Member",
            "Role",
            "Permissions",
            "False",
            "Message",
            "Message.reactions",
            "Message",
            "str(content)",
            "None",
            "embed",
            "file",
            "File",
            "files",
            "list",
            "File",
            "embed",
            "Embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "Embed",
            "File",
            "File",
            "str",
            "int",
            "bool",
            "nonce",
            "float",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "Message",
            "MessageReference",
            "PartialMessage",
            "Message",
            "to_reference()",
            "Message",
            "replied_user",
            "allowed_mentions",
            "mention_author",
            "bool",
            "replied_user",
            "allowed_mentions",
            "discord.ui.View",
            "Embed",
            "GuildSticker",
            "StickerItem",
            "bool",
            "bool",
            "Poll",
            "Message",
            "files",
            "file",
            "files",
            "embed",
            "embeds",
            "reference",
            "Message",
            "MessageReference",
            "PartialMessage",
            "target",
            "Member",
            "Role",
            "overwrite",
            "None",
            "PermissionOverwrite",
            "Permissions",
            "overwrite",
            "overwrite",
            "None",
            "manage_roles",
            "await message.channel.set_permissions(message.author, read_messages=True,\n                                                      send_messages=False)",
            "await channel.set_permissions(member, overwrite=None)",
            "PermissionOverwrite",
            "overwrite = discord.PermissionOverwrite()\noverwrite.send_messages = False\noverwrite.read_messages = True\nawait channel.set_permissions(member, overwrite=overwrite)",
            "Member",
            "Role",
            "PermissionOverwrite",
            "None",
            "overwrite",
            "str",
            "Role",
            "Member",
            "None",
            "Typing",
            "with",
            "async with",
            "async with channel.typing():\n    # simulate something heavy\n    await asyncio.sleep(10)\n\nawait channel.send('done!')",
            "members",
            "int",
            "VoiceState",
            "int",
            "Guild",
            "int",
            "str",
            "StagePrivacyLevel",
            "bool",
            "ScheduledEvent",
            "ConnectionState",
            "Guild",
            "StageInstance",
            "manage_channels",
            "str",
            "StagePrivacyLevel",
            "str",
            "privacy_level",
            "manage_channels",
            "str"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Interactions#",
        "content": [
            "Represents a Discord interaction.",
            "An interaction happens when a user does an action that needs to\nbe notified. Current examples are application commands, components, and modals.",
            "New in version 2.0.",
            "The interaction’s ID.",
            "int",
            "The interaction type.",
            "InteractionType",
            "The guild ID the interaction was sent from.",
            "Optional[int]",
            "The channel the interaction was sent from.",
            "Optional[Union[abc.GuildChannel, abc.PrivateChannel, Thread]]",
            "The ID of the channel the interaction was sent from.",
            "Optional[int]",
            "The application ID that the interaction was for.",
            "int",
            "The user or member that sent the interaction. Will be None in PING interactions.",
            "Optional[Union[User, Member]]",
            "The message that sent this interaction.",
            "Optional[Message]",
            "The token to continue the interaction. These are valid\nfor 15 minutes.",
            "str",
            "The raw interaction data.",
            "dict",
            "The user’s locale.",
            "str",
            "The guilds preferred locale, if invoked in a guild.",
            "str",
            "The custom ID for the interaction.",
            "Optional[str]",
            "Entitlements that apply to the invoking user, showing access to premium SKUs.",
            "New in version 2.5.",
            "list[Entitlement]",
            "Contains the entities (users or guilds) that authorized this interaction.",
            "New in version 2.6.",
            "AuthorizingIntegrationOwners",
            "The context in which this command was executed.",
            "New in version 2.6.",
            "Optional[InteractionContextType]",
            "data (Interaction) –",
            "state (ConnectionState) –",
            "Returns the client that sent the interaction.",
            "The guild the interaction was sent from.",
            "Indicates whether the interaction is an application command.",
            "bool",
            "Indicates whether the interaction is a message component.",
            "bool",
            "The channel the\ninteraction was sent from.",
            "Note that due to a Discord limitation, DM channels are not resolved since there is\nno data to complete them. These are PartialMessageable instead.",
            "The resolved permissions of the member in the channel, including overwrites.",
            "In a non-guild context where this doesn’t apply, an empty permissions object is returned.",
            "The resolved permissions of the application in the channel, including overwrites.",
            "Returns an object responsible for handling responding to the interaction.",
            "A response can only be done once. If secondary messages need to be sent, consider using followup\ninstead.",
            "Returns the followup webhook for followup interactions.",
            "This function is a coroutine.",
            "Fetches the original interaction response message associated with the interaction.",
            "If the interaction response was InteractionResponse.send_message() then this would\nreturn the message that was sent using that response. Otherwise, this would return\nthe message that triggered the interaction.",
            "Repeated calls to this will return a cached value.",
            "The original interaction response message.",
            "InteractionMessage",
            "HTTPException – Fetching the original response message failed.",
            "ClientException – The channel for the message could not be resolved.",
            "An alias for original_response().",
            "The original interaction response message.",
            "InteractionMessage",
            "HTTPException – Fetching the original response message failed.",
            "ClientException – The channel for the message could not be resolved.",
            "This function is a coroutine.",
            "Edits the original interaction response message.",
            "This is a lower level interface to InteractionMessage.edit() in case\nyou do not want to fetch the message and save an HTTP request.",
            "This method is also the only way to edit the original message if\nthe message sent was ephemeral.",
            "content (Optional[str]) – The content to edit the message with or None to clear it.",
            "embeds (List[Embed]) – A list of embeds to edit the message with.",
            "embed (Optional[Embed]) – The embed to edit the message with. None suppresses the embeds.\nThis should not be mixed with the embeds parameter.",
            "file (File) – The file to upload. This cannot be mixed with files parameter.",
            "files (List[File]) – A list of files to send with the content. This cannot be mixed with the\nfile parameter.",
            "attachments (List[Attachment]) – A list of attachments to keep in the message. If [] is passed\nthen all attachments are removed.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message.\nSee abc.Messageable.send() for more information.",
            "view (Optional[View]) – The updated view to update this message with. If None is passed then\nthe view is removed.",
            "delete_after (Optional[float]) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just edited. If the deletion fails,\nthen it is silently ignored.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "The newly edited message.",
            "InteractionMessage",
            "HTTPException – Editing the message failed.",
            "Forbidden – Edited a message that is not yours.",
            "TypeError – You specified both embed and embeds or file and files",
            "ValueError – The length of embeds was invalid.",
            "An alias for edit_original_response().",
            "The newly edited message.",
            "InteractionMessage",
            "HTTPException – Editing the message failed.",
            "Forbidden – Edited a message that is not yours.",
            "TypeError – You specified both embed and embeds or file and files",
            "ValueError – The length of embeds was invalid.",
            "This function is a coroutine.",
            "Deletes the original interaction response message.",
            "This is a lower level interface to InteractionMessage.delete() in case\nyou do not want to fetch the message and save an HTTP request.",
            "delay (Optional[float]) – If provided, the number of seconds to wait before deleting the message.\nThe waiting is done in the background and deletion failures are ignored.",
            "HTTPException – Deleting the message failed.",
            "Forbidden – Deleted a message that is not yours.",
            "None",
            "An alias for delete_original_response().",
            "HTTPException – Deleting the message failed.",
            "Forbidden – Deleted a message that is not yours.",
            "This function is a coroutine.",
            "Sends either a response or a message using the followup webhook determined by whether the interaction\nhas been responded to or not.",
            "The response, its type depending on whether it’s an interaction response or a followup.",
            "Union[discord.Interaction, discord.WebhookMessage]",
            "This function is a coroutine.",
            "Either respond to the interaction with an edit_message or edits the existing response, determined by\nwhether the interaction has been responded to or not.",
            "The response, its type depending on whether it’s an interaction response or a followup.",
            "Union[discord.InteractionMessage, discord.WebhookMessage]",
            "Converts this interaction object into a dict.",
            "A dictionary of str interaction keys bound to the respective value.",
            "Dict[str, Any]",
            "Represents a Discord interaction response.",
            "This type can be accessed through Interaction.response.",
            "New in version 2.0.",
            "parent (Interaction) –",
            "Indicates whether an interaction response has been done before.",
            "An interaction can only be responded to once.",
            "bool",
            "This function is a coroutine.",
            "Defers the interaction response.",
            "This is typically used when the interaction is acknowledged\nand a secondary action will be done later.",
            "This can only be used with the following interaction types:",
            "InteractionType.application_command",
            "InteractionType.component",
            "InteractionType.modal_submit",
            "Note",
            "The follow-up response will also be non-ephemeral if the ephemeral\nargument is False, and ephemeral if True.",
            "ephemeral (bool) – Indicates whether the deferred message will eventually be ephemeral.\nThis only applies to InteractionType.application_command interactions,\nor if invisible is False.",
            "invisible (bool) – Indicates whether the deferred type should be ‘invisible’\n(InteractionResponseType.deferred_message_update)\ninstead of ‘thinking’ (InteractionResponseType.deferred_channel_message).\nIn the Discord UI, this is represented as the bot thinking of a response. You must\neventually send a followup message via Interaction.followup to make this thinking state go away.\nThis parameter does not apply to interactions of type InteractionType.application_command.",
            "HTTPException – Deferring the interaction failed.",
            "InteractionResponded – This interaction has already been responded to before.",
            "None",
            "This function is a coroutine.",
            "Pongs the ping interaction.",
            "This should rarely be used.",
            "HTTPException – Ponging the interaction failed.",
            "InteractionResponded – This interaction has already been responded to before.",
            "None",
            "This function is a coroutine.",
            "Responds to this interaction by sending a message.",
            "content (Optional[str]) – The content of the message to send.",
            "embeds (List[Embed]) – A list of embeds to send with the content. Maximum of 10. This cannot\nbe mixed with the embed parameter.",
            "embed (Embed) – The rich embed for the content to send. This cannot be mixed with\nembeds parameter.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "view (discord.ui.View) – The view to send with the message.",
            "ephemeral (bool) – Indicates if the message should only be visible to the user who started the interaction.\nIf a view is sent with an ephemeral message, and it has no timeout set then the timeout\nis set to 15 minutes.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message.\nSee abc.Messageable.send() for more information.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "The interaction object associated with the sent message.",
            "Interaction",
            "HTTPException – Sending the message failed.",
            "TypeError – You specified both embed and embeds.",
            "ValueError – The length of embeds was invalid.",
            "InteractionResponded – This interaction has already been responded to before.",
            "This function is a coroutine.",
            "Responds to this interaction by editing the original message of\na component or modal interaction.",
            "content (Optional[str]) – The new content to replace the message with. None removes the content.",
            "embeds (List[Embed]) – A list of embeds to edit the message with.",
            "embed (Optional[Embed]) – The embed to edit the message with. None suppresses the embeds.\nThis should not be mixed with the embeds parameter.",
            "file (File) – A new file to add to the message. This cannot be mixed with files parameter.",
            "files (List[File]) – A list of new files to add to the message. Must be a maximum of 10. This\ncannot be mixed with the file parameter.",
            "attachments (List[Attachment]) – A list of attachments to keep in the message. If [] is passed\nthen all attachments are removed.",
            "view (Optional[View]) – The updated view to update this message with. If None is passed then\nthe view is removed.",
            "delete_after (Optional[float]) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just edited. If the deletion fails,\nthen it is silently ignored.",
            "suppress (Optional[bool]) – Whether to suppress embeds for the message.",
            "allowed_mentions (Optional[AllowedMentions]) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "HTTPException – Editing the message failed.",
            "TypeError – You specified both embed and embeds.",
            "InteractionResponded – This interaction has already been responded to before.",
            "None",
            "This function is a coroutine.\nResponds to this interaction by sending the autocomplete choices.",
            "choices (List[OptionChoice]) – A list of choices.",
            "HTTPException – Sending the result failed.",
            "InteractionResponded – This interaction has already been responded to before.",
            "This function is a coroutine.\nResponds to this interaction by sending a modal dialog.\nThis cannot be used to respond to another modal dialog submission.",
            "modal (discord.ui.Modal) – The modal dialog to display to the user.",
            "HTTPException – Sending the modal failed.",
            "InteractionResponded – This interaction has already been responded to before.",
            "Interaction",
            "This function is a coroutine.",
            "Responds to this interaction by sending a premium required message.\n:rtype: Interaction",
            "Deprecated since version 2.6: A button with type ButtonType.premium should be used instead.",
            "HTTPException – Sending the message failed.",
            "InteractionResponded – This interaction has already been responded to before.",
            "Represents the original interaction response message.",
            "This allows you to edit or delete the message associated with\nthe interaction response. To retrieve this object see Interaction.original_response().",
            "This inherits from discord.Message with changes to\nedit() and delete() to work.",
            "New in version 2.0.",
            "state (ConnectionState) –",
            "channel (Union[TextChannel, VoiceChannel, StageChannel, Thread, DMChannel, PartialMessageable, GroupChannel]) –",
            "data (Message) –",
            "This function is a coroutine.",
            "Edits the message.",
            "content (Optional[str]) – The content to edit the message with or None to clear it.",
            "embeds (List[Embed]) – A list of embeds to edit the message with.",
            "embed (Optional[Embed]) – The embed to edit the message with. None suppresses the embeds.\nThis should not be mixed with the embeds parameter.",
            "file (File) – The file to upload. This cannot be mixed with files parameter.",
            "files (List[File]) – A list of files to send with the content. This cannot be mixed with the\nfile parameter.",
            "attachments (List[Attachment]) – A list of attachments to keep in the message. If [] is passed\nthen all attachments are removed.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message.\nSee abc.Messageable.send() for more information.",
            "view (Optional[View]) – The updated view to update this message with. If None is passed then\nthe view is removed.",
            "delete_after (Optional[float]) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just edited. If the deletion fails,\nthen it is silently ignored.",
            "suppress (Optional[bool]) – Whether to suppress embeds for the message.",
            "The newly edited message.",
            "InteractionMessage",
            "HTTPException – Editing the message failed.",
            "Forbidden – Edited a message that is not yours.",
            "TypeError – You specified both embed and embeds or file and files",
            "ValueError – The length of embeds was invalid.",
            "This function is a coroutine.",
            "Deletes the message.",
            "delay (Optional[float]) – If provided, the number of seconds to wait before deleting the message.\nThe waiting is done in the background and deletion failures are ignored.",
            "Forbidden – You do not have proper permissions to delete the message.",
            "NotFound – The message was deleted already.",
            "HTTPException – Deleting the message failed.",
            "None",
            "Represents a Discord message interaction.",
            "This is sent on the message object when the message is a response\nto an interaction without an existing message e.g. application command.",
            "New in version 2.0.",
            "Deprecated since version 2.6: See InteractionMetadata.",
            "Note",
            "Responses to message components do not include this property.",
            "The interaction’s ID.",
            "int",
            "The interaction type.",
            "InteractionType",
            "The name of the invoked application command.",
            "str",
            "The user that sent the interaction.",
            "User",
            "The raw interaction data.",
            "dict",
            "data (MessageInteraction) –",
            "state (ConnectionState) –",
            "Represents metadata about an interaction.",
            "This is sent on the message object when the message is related to an interaction",
            "New in version 2.6.",
            "The interaction’s ID.",
            "int",
            "The interaction type.",
            "InteractionType",
            "The user that sent the interaction.",
            "User",
            "The authorizing user or server for the installation(s) relevant to the interaction.",
            "AuthorizingIntegrationOwners",
            "The ID of the original response message. Only present on interaction follow-up messages.",
            "Optional[int]",
            "The ID of the message that triggered the interaction. Only present on interactions of type\nInteractionType.component.",
            "Optional[int]",
            "The metadata of the interaction that opened the model. Only present on interactions of type\nInteractionType.modal_submit.",
            "Optional[InteractionMetadata]",
            "data (InteractionMetadata) –",
            "state (ConnectionState) –",
            "The original response message.\nReturns None if the message is not in cache, or if original_response_message_id is None.",
            "Optional[Message]",
            "The message that triggered the interaction.\nReturns None if the message is not in cache, or if interacted_message_id is None.",
            "Optional[Message]",
            "Contains details on the authorizing user or server for the installation(s) relevant to the interaction.",
            "New in version 2.6.",
            "The ID of the user that authorized the integration.",
            "int | None",
            "The ID of the guild that authorized the integration.\nThis will be 0 if the integration was triggered\nfrom the user in the bot’s DMs.",
            "int | None",
            "The user that authorized the integration.\nReturns None if the user is not in cache, or if user_id is None.",
            "Optional[User]",
            "The guild that authorized the integration.\nReturns None if the guild is not in cache, or if guild_id is 0 or None.",
            "Optional[Guild]",
            "Represents a Discord Bot UI Kit Component.",
            "Currently, the only components supported by Discord are:",
            "ActionRow",
            "Button",
            "SelectMenu",
            "This class is abstract and cannot be instantiated.",
            "New in version 2.0.",
            "The type of component.",
            "ComponentType",
            "Represents a Discord Bot UI Kit Action Row.",
            "This is a component that holds up to 5 children components in a row.",
            "This inherits from Component.",
            "New in version 2.0.",
            "The type of component.",
            "ComponentType",
            "The children components that this holds, if any.",
            "List[Component]",
            "data (Union[ActionRow, ButtonComponent, SelectMenu, InputText]) –",
            "Represents a button from the Discord Bot UI Kit.",
            "This inherits from Component.",
            "Note",
            "The user constructible and usable type to create a button is discord.ui.Button\nnot this one.",
            "New in version 2.0.",
            "The style of the button.",
            "ButtonStyle",
            "The ID of the button that gets received during an interaction.\nIf this button is for a URL, it does not have a custom ID.",
            "Optional[str]",
            "The URL this button sends you to.",
            "Optional[str]",
            "Whether the button is disabled or not.",
            "bool",
            "The label of the button, if any.",
            "Optional[str]",
            "The emoji of the button, if available.",
            "Optional[PartialEmoji]",
            "The ID of the SKU this button refers to.",
            "Optional[int]",
            "data (ButtonComponent) –",
            "Represents a select menu from the Discord Bot UI Kit.",
            "A select menu is functionally the same as a dropdown, however\non mobile it renders a bit differently.",
            "Note",
            "The user constructible and usable type to create a select menu is\ndiscord.ui.Select not this one.",
            "New in version 2.0.",
            "Changed in version 2.3: Added support for ComponentType.user_select, ComponentType.role_select,\nComponentType.mentionable_select, and ComponentType.channel_select.",
            "The select menu’s type.",
            "ComponentType",
            "The ID of the select menu that gets received during an interaction.",
            "Optional[str]",
            "The placeholder text that is shown if nothing is selected, if any.",
            "Optional[str]",
            "The minimum number of items that must be chosen for this select menu.\nDefaults to 1 and must be between 0 and 25.",
            "int",
            "The maximum number of items that must be chosen for this select menu.\nDefaults to 1 and must be between 1 and 25.",
            "int",
            "A list of options that can be selected in this menu.\nWill be an empty list for all component types\nexcept for ComponentType.string_select.",
            "List[SelectOption]",
            "A list of channel types that can be selected.\nWill be an empty list for all component types\nexcept for ComponentType.channel_select.",
            "List[ChannelType]",
            "Whether the select is disabled or not.",
            "bool",
            "data (SelectMenu) –"
        ],
        "code": [
            "int",
            "InteractionType",
            "int",
            "abc.GuildChannel",
            "abc.PrivateChannel",
            "Thread",
            "int",
            "int",
            "User",
            "Member",
            "Message",
            "str",
            "dict",
            "str",
            "str",
            "str",
            "Entitlement",
            "AuthorizingIntegrationOwners",
            "InteractionContextType",
            "Interaction",
            "ConnectionState",
            "bool",
            "bool",
            "PartialMessageable",
            "followup",
            "InteractionResponse.send_message()",
            "original_response()",
            "InteractionMessage.edit()",
            "str",
            "None",
            "Embed",
            "Embed",
            "None",
            "embeds",
            "File",
            "files",
            "File",
            "file",
            "Attachment",
            "[]",
            "AllowedMentions",
            "abc.Messageable.send()",
            "View",
            "None",
            "float",
            "bool",
            "InteractionMessage",
            "embed",
            "embeds",
            "file",
            "files",
            "embeds",
            "edit_original_response()",
            "InteractionMessage",
            "embed",
            "embeds",
            "file",
            "files",
            "embeds",
            "InteractionMessage.delete()",
            "float",
            "delete_original_response()",
            "discord.Interaction",
            "discord.WebhookMessage",
            "discord.InteractionMessage",
            "discord.WebhookMessage",
            "str",
            "str",
            "Interaction.response",
            "Interaction",
            "bool",
            "InteractionType.application_command",
            "InteractionType.component",
            "InteractionType.modal_submit",
            "False",
            "True",
            "bool",
            "InteractionType.application_command",
            "invisible",
            "False",
            "bool",
            "InteractionResponseType.deferred_message_update",
            "InteractionResponseType.deferred_channel_message",
            "Interaction.followup",
            "InteractionType.application_command",
            "None",
            "None",
            "str",
            "Embed",
            "embed",
            "Embed",
            "embeds",
            "bool",
            "discord.ui.View",
            "bool",
            "AllowedMentions",
            "abc.Messageable.send()",
            "float",
            "File",
            "File",
            "Poll",
            "Interaction",
            "embed",
            "embeds",
            "embeds",
            "str",
            "None",
            "Embed",
            "Embed",
            "None",
            "embeds",
            "File",
            "files",
            "File",
            "file",
            "Attachment",
            "[]",
            "View",
            "None",
            "float",
            "bool",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "embed",
            "embeds",
            "OptionChoice",
            "discord.ui.Modal",
            "Interaction",
            "Interaction",
            "ButtonType.premium",
            "Interaction.original_response()",
            "discord.Message",
            "edit()",
            "delete()",
            "ConnectionState",
            "Union",
            "TextChannel",
            "VoiceChannel",
            "StageChannel",
            "Thread",
            "DMChannel",
            "PartialMessageable",
            "GroupChannel",
            "Message",
            "str",
            "None",
            "Embed",
            "Embed",
            "None",
            "embeds",
            "File",
            "files",
            "File",
            "file",
            "Attachment",
            "[]",
            "AllowedMentions",
            "abc.Messageable.send()",
            "View",
            "None",
            "float",
            "bool",
            "InteractionMessage",
            "embed",
            "embeds",
            "file",
            "files",
            "embeds",
            "float",
            "InteractionMetadata",
            "int",
            "InteractionType",
            "str",
            "User",
            "dict",
            "MessageInteraction",
            "ConnectionState",
            "int",
            "InteractionType",
            "User",
            "AuthorizingIntegrationOwners",
            "int",
            "InteractionType.component",
            "int",
            "InteractionType.modal_submit",
            "InteractionMetadata",
            "InteractionMetadata",
            "ConnectionState",
            "None",
            "original_response_message_id",
            "None",
            "Message",
            "None",
            "interacted_message_id",
            "None",
            "Message",
            "int",
            "0",
            "int",
            "None",
            "user_id",
            "None",
            "User",
            "None",
            "guild_id",
            "0",
            "None",
            "Guild",
            "ActionRow",
            "Button",
            "SelectMenu",
            "ComponentType",
            "Component",
            "ComponentType",
            "Component",
            "Union",
            "ActionRow",
            "ButtonComponent",
            "SelectMenu",
            "InputText",
            "Component",
            "discord.ui.Button",
            "ButtonStyle",
            "str",
            "str",
            "bool",
            "str",
            "PartialEmoji",
            "int",
            "ButtonComponent",
            "discord.ui.Select",
            "ComponentType.user_select",
            "ComponentType.role_select",
            "ComponentType.mentionable_select",
            "ComponentType.channel_select",
            "ComponentType",
            "str",
            "str",
            "int",
            "int",
            "ComponentType.string_select",
            "SelectOption",
            "ComponentType.channel_select",
            "ChannelType",
            "bool",
            "SelectMenu"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Emoji#",
        "content": [
            "Represents a custom emoji.",
            "Depending on the way this object was created, some attributes can\nhave a value of None.",
            "Checks if two emoji are the same.",
            "Checks if two emoji are not the same.",
            "Return the emoji’s hash.",
            "Returns an iterator of (field, value) pairs. This allows this class\nto be used as an iterable in list/dict/etc constructions.",
            "Returns the emoji rendered for discord.",
            "The name of the emoji.",
            "str",
            "The emoji’s ID.",
            "int",
            "If colons are required to use this emoji in the client (:PJSalt: vs PJSalt).",
            "bool",
            "Whether an emoji is animated or not.",
            "bool",
            "If this emoji is managed by a Twitch integration.",
            "bool",
            "The guild ID the emoji belongs to.",
            "int",
            "Whether the emoji is available for use.",
            "bool",
            "The user that created the emoji. This can only be retrieved using Guild.fetch_emoji() and\nhaving the manage_emojis permission.",
            "Optional[User]",
            "guild (Guild) –",
            "state (ConnectionState) –",
            "data (Emoji) –",
            "Returns the emoji’s creation time in UTC.",
            "Returns the URL of the emoji.",
            "A list of roles that is allowed to use this emoji.",
            "If roles is empty, the emoji is unrestricted.",
            "The guild this emoji belongs to.",
            "Whether the bot can use this emoji.\n:rtype: bool",
            "New in version 1.3.",
            "This function is a coroutine.",
            "Deletes the custom emoji.",
            "You must have manage_emojis permission to\ndo this.",
            "reason (Optional[str]) – The reason for deleting this emoji. Shows up on the audit log.",
            "Forbidden – You are not allowed to delete emojis.",
            "HTTPException – An error occurred deleting the emoji.",
            "None",
            "This function is a coroutine.",
            "Edits the custom emoji.",
            "You must have manage_emojis permission to\ndo this.",
            "Changed in version 2.0: The newly updated emoji is returned.",
            "name (str) – The new emoji name.",
            "roles (Optional[List[Snowflake]]) – A list of roles that can use this emoji. An empty list can be passed to make it available to everyone.",
            "reason (Optional[str]) – The reason for editing this emoji. Shows up on the audit log.",
            "Forbidden – You are not allowed to edit emojis.",
            "HTTPException – An error occurred editing the emoji.",
            "The newly updated emoji.",
            "Emoji",
            "This function is a coroutine.",
            "Retrieves the content of this asset as a bytes object.",
            "The content of the asset.",
            "bytes",
            "DiscordException – There was no internal connection state.",
            "HTTPException – Downloading the asset failed.",
            "NotFound – The asset was deleted.",
            "This function is a coroutine.",
            "Saves this asset into a file-like object.",
            "fp (Union[io.BufferedIOBase, os.PathLike]) – The file-like object to save this attachment to or the filename\nto use. If a filename is passed then a file is created with that\nfilename and used instead.",
            "seek_begin (bool) – Whether to seek to the beginning of the file after saving is\nsuccessfully done.",
            "The number of bytes written.",
            "int",
            "DiscordException – There was no internal connection state.",
            "HTTPException – Downloading the asset failed.",
            "NotFound – The asset was deleted.",
            "Represents a “partial” emoji.",
            "This model will be given in two scenarios:",
            "“Raw” data events such as on_raw_reaction_add()",
            "Custom emoji that the bot cannot see from e.g. Message.reactions",
            "Checks if two emoji are the same.",
            "Checks if two emoji are not the same.",
            "Return the emoji’s hash.",
            "Returns the emoji rendered for discord.",
            "The custom emoji name, if applicable, or the unicode codepoint\nof the non-custom emoji. This can be None if the emoji\ngot deleted (e.g. removing a reaction with a deleted emoji).",
            "Optional[str]",
            "Whether the emoji is animated or not.",
            "bool",
            "The ID of the custom emoji, if applicable.",
            "Optional[int]",
            "name (str | None) –",
            "animated (bool) –",
            "id (int | None) –",
            "Converts a Discord string representation of an emoji to a PartialEmoji.",
            "The formats accepted are:",
            "a:name:id",
            "<a:name:id>",
            "name:id",
            "<:name:id>",
            "If the format does not match then it is assumed to be a unicode emoji.",
            "New in version 2.0.",
            "value (str) – The string representation of an emoji.",
            "The partial emoji from this string.",
            "PartialEmoji",
            "Checks if this is a custom non-Unicode emoji.",
            "bool",
            "Checks if this is a Unicode emoji.",
            "bool",
            "Returns the emoji’s creation time in UTC, or None if Unicode emoji.",
            "New in version 1.6.",
            "Returns the URL of the emoji, if it is custom.",
            "If this isn’t a custom emoji then an empty string is returned",
            "This function is a coroutine.",
            "Retrieves the content of this asset as a bytes object.",
            "The content of the asset.",
            "bytes",
            "DiscordException – There was no internal connection state.",
            "HTTPException – Downloading the asset failed.",
            "NotFound – The asset was deleted.",
            "This function is a coroutine.",
            "Saves this asset into a file-like object.",
            "fp (Union[io.BufferedIOBase, os.PathLike]) – The file-like object to save this attachment to or the filename\nto use. If a filename is passed then a file is created with that\nfilename and used instead.",
            "seek_begin (bool) – Whether to seek to the beginning of the file after saving is\nsuccessfully done.",
            "The number of bytes written.",
            "int",
            "DiscordException – There was no internal connection state.",
            "HTTPException – Downloading the asset failed.",
            "NotFound – The asset was deleted."
        ],
        "code": [
            "None",
            "(field, value)",
            "str",
            "int",
            "bool",
            "bool",
            "bool",
            "int",
            "bool",
            "Guild.fetch_emoji()",
            "manage_emojis",
            "User",
            "Guild",
            "ConnectionState",
            "Emoji",
            "list",
            "bool",
            "manage_emojis",
            "str",
            "manage_emojis",
            "str",
            "Snowflake",
            "str",
            "Emoji",
            "bytes",
            "bytes",
            "io.BufferedIOBase",
            "os.PathLike",
            "bool",
            "int",
            "on_raw_reaction_add()",
            "Message.reactions",
            "None",
            "str",
            "bool",
            "int",
            "PartialEmoji",
            "a:name:id",
            "<a:name:id>",
            "name:id",
            "<:name:id>",
            "str",
            "PartialEmoji",
            "bool",
            "bool",
            "bytes",
            "bytes",
            "io.BufferedIOBase",
            "os.PathLike",
            "bool",
            "int"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Channels#",
        "content": [
            "Represents a Discord text channel.",
            "Checks if two channels are equal.",
            "Checks if two channels are not equal.",
            "Returns the channel’s hash.",
            "Returns the channel’s name.",
            "The channel name.",
            "str",
            "The guild the channel belongs to.",
            "Guild",
            "The channel ID.",
            "int",
            "The category channel ID this channel belongs to, if applicable.",
            "Optional[int]",
            "The channel’s topic. None if it doesn’t exist.",
            "Optional[str]",
            "The position in the channel list. This is a number that starts at 0. e.g. the\ntop channel is position 0. Can be None if the channel was received in an interaction.",
            "Optional[int]",
            "The last message ID of the message sent to this channel. It may\nnot point to an existing or valid message.",
            "Optional[int]",
            "The number of seconds a member must wait between sending messages\nin this channel. A value of 0 denotes that it is disabled.\nBots and users with manage_channels or\nmanage_messages bypass slowmode.",
            "int",
            "If the channel is marked as “not safe for work”.",
            "Note",
            "To check if the channel or the guild of that channel are marked as NSFW, consider is_nsfw() instead.",
            "bool",
            "The default auto archive duration in minutes for threads created in this channel.",
            "New in version 2.0.",
            "int",
            "Extra features of the channel.",
            "New in version 2.0.",
            "ChannelFlags",
            "The initial slowmode delay to set on newly created threads in this channel.",
            "New in version 2.3.",
            "Optional[int]",
            "state (ConnectionState) –",
            "guild (Guild) –",
            "data (TextChannelPayload) –",
            "Returns an AsyncIterator that enables receiving the destination’s message history.",
            "You must have read_message_history permissions to use this.",
            "limit (Optional[int]) – The number of messages to retrieve.\nIf None, retrieves every message in the channel. Note, however,\nthat this would make it a slow operation.",
            "before (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages before this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages after this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "around (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages around this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.\nWhen using this argument, the maximum limit is 101. Note that if the limit is an\neven number, then this will return at most limit + 1 messages.",
            "oldest_first (Optional[bool]) – If set to True, return messages in oldest->newest order. Defaults to True if\nafter is specified, otherwise False.",
            "Message – The message with the message data parsed.",
            "Forbidden – You do not have permissions to get channel message history.",
            "HTTPException – The request to get message history failed.",
            "HistoryIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "All parameters are optional.",
            "Returns a context manager that allows you to type for an indefinite period of time.",
            "This is useful for denoting long computations in your bot.\n:rtype: Typing",
            "Note",
            "This is both a regular context manager and an async context manager.\nThis means that both with and async with work with this.",
            "Example Usage:",
            "Checks if the channel is a news/announcements channel.",
            "bool",
            "Equivalent to is_news().",
            "This function is a coroutine.",
            "Edits the channel.",
            "You must have the manage_channels permission to\nuse this.",
            "Changed in version 1.3: The overwrites keyword-only parameter was added.",
            "Changed in version 1.4: The type keyword-only parameter was added.",
            "Changed in version 2.0: Edits are no longer in-place, the newly edited channel is returned instead.",
            "name (str) – The new channel name.",
            "topic (str) – The new channel’s topic.",
            "position (int) – The new channel’s position.",
            "nsfw (bool) – To mark the channel as NSFW or not.",
            "sync_permissions (bool) – Whether to sync permissions with the channel’s new or pre-existing\ncategory. Defaults to False.",
            "category (Optional[CategoryChannel]) – The new category for this channel. Can be None to remove the\ncategory.",
            "slowmode_delay (int) – Specifies the slowmode rate limit for user in this channel, in seconds.\nA value of 0 disables slowmode. The maximum value possible is 21600.",
            "type (ChannelType) – Change the type of this text channel. Currently, only conversion between\nChannelType.text and ChannelType.news is supported. This\nis only available to guilds that contain NEWS in Guild.features.",
            "reason (Optional[str]) – The reason for editing this channel. Shows up on the audit log.",
            "overwrites (Dict[Union[Role, Member, Snowflake], PermissionOverwrite]) – The overwrites to apply to channel permissions. Useful for creating secret channels.",
            "default_auto_archive_duration (int) – The new default auto archive duration in minutes for threads created in this channel.\nMust be one of 60, 1440, 4320, or 10080.",
            "default_thread_slowmode_delay (int) – The new default slowmode delay in seconds for threads created in this channel.\n\nNew in version 2.3.",
            "The new default slowmode delay in seconds for threads created in this channel.",
            "New in version 2.3.",
            "The newly edited text channel. If the edit was only positional\nthen None is returned instead.",
            "Optional[TextChannel]",
            "InvalidArgument – If position is less than 0 or greater than the number of channels, or if\n    the permission overwrite information is not in proper form.",
            "Forbidden – You do not have permissions to edit the channel.",
            "HTTPException – Editing the channel failed.",
            "This function is a coroutine.",
            "Creates a thread in this text channel.",
            "To create a public thread, you must have create_public_threads.\nFor a private thread, create_private_threads is needed instead.",
            "New in version 2.0.",
            "name (str) – The name of the thread.",
            "message (Optional[abc.Snowflake]) – A snowflake representing the message to create the thread with.\nIf None is passed then a private thread is created.\nDefaults to None.",
            "auto_archive_duration (int) – The duration in minutes before a thread is automatically archived for inactivity.\nIf not provided, the channel’s default auto archive duration is used.",
            "type (Optional[ChannelType]) – The type of thread to create. If a message is passed then this parameter\nis ignored, as a thread created with a message is always a public thread.\nBy default, this creates a private thread if this is None.",
            "slowmode_delay (Optional[int]) – Specifies the slowmode rate limit for users in this thread, in seconds.\nA value of 0 disables slowmode. The maximum value possible is 21600.",
            "invitable (Optional[bool]) – Whether non-moderators can add other non-moderators to this thread.\nOnly available for private threads, where it defaults to True.",
            "reason (str) – The reason for creating a new thread. Shows up on the audit log.",
            "The created thread",
            "Thread",
            "Forbidden – You do not have permissions to create a thread.",
            "HTTPException – Starting the thread failed.",
            "Returns an AsyncIterator that iterates over all archived threads in the guild.",
            "You must have read_message_history to use this. If iterating over private threads\nthen manage_threads is also required.",
            "New in version 2.0.",
            "limit (Optional[bool]) – The number of threads to retrieve.\nIf None, retrieves every archived thread in the channel. Note, however,\nthat this would make it a slow operation.",
            "before (Optional[Union[abc.Snowflake, datetime.datetime]]) – Retrieve archived channels before the given date or ID.",
            "private (bool) – Whether to retrieve private archived threads.",
            "joined (bool) – Whether to retrieve private archived threads that you’ve joined.\nYou cannot set joined to True and private to False.",
            "Thread – The archived threads.",
            "Forbidden – You do not have permissions to get archived threads.",
            "HTTPException – The request to get the archived threads failed.",
            "ArchivedThreadIterator",
            "Returns a bool indicating whether you have the permissions to send the object(s).",
            "Indicates whether you have the permissions to send the object(s).",
            "bool",
            "TypeError – An invalid type has been passed.",
            "The category this channel belongs to.",
            "If there is no category then this is None.",
            "Returns a list of roles that have been overridden from\ntheir default values in the roles attribute.",
            "This function is a coroutine.",
            "Clones this channel. This creates a channel with the same properties\nas this channel.",
            "You must have the manage_channels permission to\ndo this.",
            "New in version 1.1.",
            "name (Optional[str]) – The name of the new channel. If not provided, defaults to this\nchannel name.",
            "reason (Optional[str]) – The reason for cloning this channel. Shows up on the audit log.",
            "The channel that was created.",
            "abc.GuildChannel",
            "Forbidden – You do not have the proper permissions to create this channel.",
            "HTTPException – Creating the channel failed.",
            "This function is a coroutine.",
            "Creates an instant invite from a text or voice channel.",
            "You must have the create_instant_invite permission to\ndo this.",
            "max_age (int) – How long the invite should last in seconds. If it’s 0 then the invite\ndoesn’t expire. Defaults to 0.",
            "max_uses (int) – How many uses the invite could be used for. If it’s 0 then there\nare unlimited uses. Defaults to 0.",
            "temporary (bool) – Denotes that the invite grants temporary membership\n(i.e. they get kicked after they disconnect). Defaults to False.",
            "unique (bool) – Indicates if a unique invite URL should be created. Defaults to True.\nIf this is set to False then it will return a previously created\ninvite.",
            "reason (Optional[str]) – The reason for creating this invite. Shows up on the audit log.",
            "target_type (Optional[InviteTarget]) – The type of target for the voice channel invite, if any.\n\nNew in version 2.0.",
            "The type of target for the voice channel invite, if any.",
            "New in version 2.0.",
            "target_user (Optional[User]) – The user whose stream to display for this invite, required if target_type is TargetType.stream.\nThe user must be streaming in the channel.\n\nNew in version 2.0.",
            "The user whose stream to display for this invite, required if target_type is TargetType.stream.\nThe user must be streaming in the channel.",
            "New in version 2.0.",
            "target_application_id (Optional[int]) – The id of the embedded application for the invite, required if target_type is\nTargetType.embedded_application.\n\nNew in version 2.0.",
            "The id of the embedded application for the invite, required if target_type is\nTargetType.embedded_application.",
            "New in version 2.0.",
            "target_event (Optional[ScheduledEvent]) – The scheduled event object to link to the event.\nShortcut to Invite.set_scheduled_event()\nSee Invite.set_scheduled_event() for more\ninfo on event invite linking.\n\nNew in version 2.0.",
            "The scheduled event object to link to the event.\nShortcut to Invite.set_scheduled_event()",
            "See Invite.set_scheduled_event() for more\ninfo on event invite linking.",
            "New in version 2.0.",
            "The invite that was created.",
            "Invite",
            "HTTPException – Invite creation failed.",
            "NotFound – The channel that was passed is a category or an invalid channel.",
            "This function is a coroutine.",
            "Creates a webhook for this channel.",
            "Requires manage_webhooks permissions.",
            "Changed in version 1.1: Added the reason keyword-only parameter.",
            "name (str) – The webhook’s name.",
            "avatar (Optional[bytes]) – A bytes-like object representing the webhook’s default avatar.\nThis operates similarly to edit().",
            "reason (Optional[str]) – The reason for creating this webhook. Shows up in the audit logs.",
            "The created webhook.",
            "Webhook",
            "HTTPException – Creating the webhook failed.",
            "Forbidden – You do not have permissions to create a webhook.",
            "Returns the channel’s creation time in UTC.",
            "This function is a coroutine.",
            "Deletes the channel.",
            "You must have manage_channels permission to use this.",
            "reason (Optional[str]) – The reason for deleting this channel.\nShows up on the audit log.",
            "Forbidden – You do not have proper permissions to delete the channel.",
            "NotFound – The channel was not found or was already deleted.",
            "HTTPException – Deleting the channel failed.",
            "None",
            "This function is a coroutine.",
            "Deletes a list of messages. This is similar to Message.delete()\nexcept it bulk deletes multiple messages.",
            "As a special case, if the number of messages is 0, then nothing\nis done. If the number of messages is 1 then single message\ndelete is done. If it’s more than two, then bulk delete is used.",
            "You cannot bulk delete more than 100 messages or messages that\nare older than 14 days old.",
            "You must have the manage_messages permission to\nuse this.",
            "messages (Iterable[abc.Snowflake]) – An iterable of messages denoting which ones to bulk delete.",
            "reason (Optional[str]) – The reason for deleting the messages. Shows up on the audit log.",
            "ClientException – The number of messages to delete was more than 100.",
            "Forbidden – You do not have proper permissions to delete the messages.",
            "NotFound – If single delete, then the message was already deleted.",
            "HTTPException – Deleting the messages failed.",
            "None",
            "This function is a coroutine.",
            "Retrieves a single Message from the destination.",
            "id (int) – The message ID to look for.",
            "The message asked for.",
            "Message",
            "NotFound – The specified message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "Follows a channel using a webhook.",
            "Only news channels can be followed.",
            "Note",
            "The webhook returned will not provide a token to do webhook\nactions, as Discord does not provide it.",
            "New in version 1.3.",
            "destination (TextChannel) – The channel you would like to follow from.",
            "reason (Optional[str]) – The reason for following the channel. Shows up on the destination guild’s audit log.\n\nNew in version 1.4.",
            "The reason for following the channel. Shows up on the destination guild’s audit log.",
            "New in version 1.4.",
            "The created webhook.",
            "Webhook",
            "HTTPException – Following the channel failed.",
            "Forbidden – You do not have the permissions to create a webhook.",
            "Creates a PartialMessage from the message ID.",
            "This is useful if you want to work with a message and only have its ID without\ndoing an unnecessary API call.",
            "New in version 1.6.",
            "message_id (int) – The message ID to create a partial message for.",
            "The partial message.",
            "PartialMessage",
            "Returns a thread with the given ID.",
            "New in version 2.0.",
            "thread_id (int) – The ID to search for.",
            "The returned thread or None if not found.",
            "Optional[Thread]",
            "This function is a coroutine.",
            "Returns a list of all active instant invites from this channel.",
            "You must have manage_channels to get this information.",
            "The list of invites that are currently active.",
            "List[Invite]",
            "Forbidden – You do not have proper permissions to get the information.",
            "HTTPException – An error occurred while fetching the information.",
            "Checks if the channel is NSFW.",
            "bool",
            "Returns a URL that allows the client to jump to the channel.",
            "New in version 2.0.",
            "Fetches the last message from this channel in cache.",
            "The message might not be valid or point to an existing message.",
            "Reliable Fetching",
            "For a slightly more reliable method of fetching the\nlast message, consider using either history()\nor fetch_message() with the last_message_id\nattribute.",
            "The last message in this channel or None if not found.",
            "Optional[Message]",
            "Returns all members that can see this channel.",
            "The string that allows you to mention the channel.",
            "This function is a coroutine.",
            "A rich interface to help move a channel relative to other channels.",
            "If exact position movement is required, edit should be used instead.",
            "You must have the manage_channels permission to\ndo this.",
            "Note",
            "Voice channels will always be sorted below text channels.\nThis is a Discord limitation.",
            "New in version 1.7.",
            "beginning (bool) – Whether to move the channel to the beginning of the\nchannel list (or category if given).\nThis is mutually exclusive with end, before, and after.",
            "end (bool) – Whether to move the channel to the end of the\nchannel list (or category if given).\nThis is mutually exclusive with beginning, before, and after.",
            "before (Snowflake) – The channel that should be before our current channel.\nThis is mutually exclusive with beginning, end, and after.",
            "after (Snowflake) – The channel that should be after our current channel.\nThis is mutually exclusive with beginning, end, and before.",
            "offset (int) – The number of channels to offset the move by. For example,\nan offset of 2 with beginning=True would move\nit 2 after the beginning. A positive number moves it below\nwhile a negative number moves it above. Note that this\nnumber is relative and computed after the beginning,\nend, before, and after parameters.",
            "category (Optional[Snowflake]) – The category to move this channel under.\nIf None is given then it moves it out of the category.\nThis parameter is ignored if moving a category channel.",
            "sync_permissions (bool) – Whether to sync the permissions with the category (if given).",
            "reason (str) – The reason for the move.",
            "InvalidArgument – An invalid position was given or a bad mix of arguments was passed.",
            "Forbidden – You do not have permissions to move the channel.",
            "HTTPException – Moving the channel failed.",
            "None",
            "Returns all of the channel’s overwrites.",
            "This is returned as a dictionary where the key contains the target which\ncan be either a Role or a Member and the value is the\noverwrite as a PermissionOverwrite.",
            "The channel’s permission overwrites.",
            "Dict[Union[Role, Member], PermissionOverwrite]",
            "Returns the channel-specific overwrites for a member or a role.",
            "obj (Union[Role, User]) – The role or user denoting\nwhose overwrite to get.",
            "The permission overwrites for this object.",
            "PermissionOverwrite",
            "Handles permission resolution for the Member\nor Role.",
            "This function takes into consideration the following cases:",
            "Guild owner",
            "Guild roles",
            "Channel overrides",
            "Member overrides",
            "If a Role is passed, then it checks the permissions\nsomeone with that role would have, which is essentially:",
            "The default role permissions",
            "The permissions of the role used as a parameter",
            "The default role permission overwrites",
            "The permission overwrites of the role used as a parameter",
            "Changed in version 2.0: The object passed in can now be a role object.",
            "obj (Union[Member, Role]) – The object to resolve permissions for. This could be either\na member or a role. If it’s a role then member overwrites\nare not computed.",
            "The resolved permissions for the member or role.",
            "Permissions",
            "Whether the permissions for this channel are synced with the\ncategory it belongs to.",
            "If there is no category then this is False.",
            "New in version 1.3.",
            "This function is a coroutine.",
            "Retrieves all messages that are currently pinned in the channel.",
            "Note",
            "Due to a limitation with the Discord API, the Message\nobjects returned by this method do not contain complete\nMessage.reactions data.",
            "The messages that are currently pinned.",
            "List[Message]",
            "HTTPException – Retrieving the pinned messages failed.",
            "This function is a coroutine.",
            "Purges a list of messages that meet the criteria given by the predicate\ncheck. If a check is not provided then all messages are deleted\nwithout discrimination.",
            "You must have the manage_messages permission to\ndelete messages even if they are your own.\nThe read_message_history permission is\nalso needed to retrieve message history.",
            "limit (Optional[int]) – The number of messages to search through. This is not the number\nof messages that will be deleted, though it can be.",
            "check (Callable[[Message], bool]) – The function used to check if a message should be deleted.\nIt must take a Message as its sole parameter.",
            "before (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as before in history().",
            "after (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as after in history().",
            "around (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as around in history().",
            "oldest_first (Optional[bool]) – Same as oldest_first in history().",
            "bulk (bool) – If True, use bulk delete. Setting this to False is useful for mass-deleting\na bot’s own messages without Permissions.manage_messages. When True, will\nfall back to single delete if messages are older than two weeks.",
            "reason (Optional[str]) – The reason for deleting the messages. Shows up on the audit log.",
            "The list of messages that were deleted.",
            "List[Message]",
            "Forbidden – You do not have proper permissions to do the actions required.",
            "HTTPException – Purging the messages failed.",
            "Examples",
            "Deleting bot’s messages",
            "This function is a coroutine.",
            "Sends a message to the destination with the content given.",
            "The content must be a type that can convert to a string through str(content).\nIf the content is set to None (the default), then the embed parameter must\nbe provided.",
            "To upload a single file, the file parameter should be used with a\nsingle File object. To upload multiple files, the files\nparameter should be used with a list of File objects.\nSpecifying both parameters will lead to an exception.",
            "To upload a single embed, the embed parameter should be used with a\nsingle Embed object. To upload multiple embeds, the embeds\nparameter should be used with a list of Embed objects.\nSpecifying both parameters will lead to an exception.",
            "content (Optional[str]) – The content of the message to send.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "embed (Embed) – The rich embed for the content.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "nonce (Union[str, int]) – The nonce to use for sending this message. If the message was successfully sent,\nthen the message will have a nonce with this value.",
            "enforce_nonce (Optional[bool]) – Whether nonce is enforced to be validated.\n\nNew in version 2.5.",
            "Whether nonce is enforced to be validated.",
            "New in version 2.5.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent. If the deletion fails,\nthen it is silently ignored.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "New in version 1.4.",
            "reference (Union[Message, MessageReference, PartialMessage]) – A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.\n\nNew in version 1.6.",
            "A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.",
            "New in version 1.6.",
            "mention_author (Optional[bool]) – If set, overrides the replied_user attribute of allowed_mentions.\n\nNew in version 1.6.",
            "If set, overrides the replied_user attribute of allowed_mentions.",
            "New in version 1.6.",
            "view (discord.ui.View) – A Discord UI View to add to the message.",
            "embeds (List[Embed]) – A list of embeds to upload. Must be a maximum of 10.\n\nNew in version 2.0.",
            "A list of embeds to upload. Must be a maximum of 10.",
            "New in version 2.0.",
            "stickers (Sequence[Union[GuildSticker, StickerItem]]) – A list of stickers to upload. Must be a maximum of 3.\n\nNew in version 2.0.",
            "A list of stickers to upload. Must be a maximum of 3.",
            "New in version 2.0.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "silent (bool) – Whether to suppress push and desktop notifications for the message.\n\nNew in version 2.4.",
            "Whether to suppress push and desktop notifications for the message.",
            "New in version 2.4.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size,\n    you specified both file and files,\n    or you specified both embed and embeds,\n    or the reference object is not a Message,\n    MessageReference or PartialMessage.",
            "This function is a coroutine.",
            "Sets the channel specific permission overwrites for a target in the\nchannel.",
            "The target parameter should either be a Member or a\nRole that belongs to guild.",
            "The overwrite parameter, if given, must either be None or\nPermissionOverwrite. For convenience, you can pass in\nkeyword arguments denoting Permissions attributes. If this is\ndone, then you cannot mix the keyword arguments with the overwrite\nparameter.",
            "If the overwrite parameter is None, then the permission\noverwrites are deleted.",
            "You must have the manage_roles permission to use this.",
            "Note",
            "This method replaces the old overwrites with the ones given.",
            "Examples",
            "Setting allow and deny:",
            "Deleting overwrites",
            "Using PermissionOverwrite",
            "target (Union[Member, Role]) – The member or role to overwrite permissions for.",
            "overwrite (Optional[PermissionOverwrite]) – The permissions to allow and deny to the target, or None to\ndelete the overwrite.",
            "**permissions – A keyword argument list of permissions to set for ease of use.\nCannot be mixed with overwrite.",
            "reason (Optional[str]) – The reason for doing this action. Shows up on the audit log.",
            "Forbidden – You do not have permissions to edit channel specific permissions.",
            "HTTPException – Editing channel specific permissions failed.",
            "NotFound – The role or member being edited is not part of the guild.",
            "InvalidArgument – The overwrite parameter invalid or the target type was not\n    Role or Member.",
            "Returns all the threads that you can see.",
            "New in version 2.0.",
            "This function is a coroutine.",
            "Triggers a typing indicator to the destination.",
            "Typing indicator will go away after 10 seconds, or after a message is sent.",
            "None",
            "The channel’s Discord type.",
            "This function is a coroutine.",
            "Gets the list of webhooks from this channel.",
            "Requires manage_webhooks permissions.",
            "The webhooks for this channel.",
            "List[Webhook]",
            "Forbidden – You don’t have permissions to get the webhooks.",
            "Represents a Discord forum channel.",
            "Checks if two channels are equal.",
            "Checks if two channels are not equal.",
            "Returns the channel’s hash.",
            "Returns the channel’s name.",
            "The channel name.",
            "str",
            "The guild the channel belongs to.",
            "Guild",
            "The channel ID.",
            "int",
            "The category channel ID this channel belongs to, if applicable.",
            "Optional[int]",
            "The channel’s topic. None if it doesn’t exist.",
            "Note",
            "guidelines exists as an alternative to this attribute.",
            "Optional[str]",
            "The position in the channel list. This is a number that starts at 0. e.g. the\ntop channel is position 0. Can be None if the channel was received in an interaction.",
            "Optional[int]",
            "The last message ID of the message sent to this channel. It may\nnot point to an existing or valid message.",
            "Optional[int]",
            "The number of seconds a member must wait between sending messages\nin this channel. A value of 0 denotes that it is disabled.\nBots and users with manage_channels or\nmanage_messages bypass slowmode.",
            "int",
            "If the channel is marked as “not safe for work”.",
            "Note",
            "To check if the channel or the guild of that channel are marked as NSFW, consider is_nsfw() instead.",
            "bool",
            "The default auto archive duration in minutes for threads created in this channel.",
            "New in version 2.0.",
            "int",
            "Extra features of the channel.",
            "New in version 2.0.",
            "ChannelFlags",
            "The set of tags that can be used in a forum channel.",
            "New in version 2.3.",
            "List[ForumTag]",
            "The default sort order type used to order posts in this channel.",
            "New in version 2.3.",
            "Optional[SortOrder]",
            "The initial slowmode delay to set on newly created threads in this channel.",
            "New in version 2.3.",
            "Optional[int]",
            "The default forum reaction emoji.",
            "New in version 2.5.",
            "Optional[str | discord.Emoji]",
            "state (ConnectionState) –",
            "guild (Guild) –",
            "data (ForumChannelPayload) –",
            "The channel’s guidelines. An alias of topic.",
            "Whether a tag is required to be specified when creating a thread in this forum channel.",
            "Tags are specified in applied_tags.",
            "New in version 2.3.",
            "Returns the ForumTag from this forum channel with the\ngiven ID, if any.",
            "New in version 2.3.",
            "id (int) –",
            "ForumTag | None",
            "This function is a coroutine.",
            "Edits the channel.",
            "You must have the manage_channels permission to\nuse this.",
            "name (str) – The new channel name.",
            "topic (str) – The new channel’s topic.",
            "position (int) – The new channel’s position.",
            "nsfw (bool) – To mark the channel as NSFW or not.",
            "sync_permissions (bool) – Whether to sync permissions with the channel’s new or pre-existing\ncategory. Defaults to False.",
            "category (Optional[CategoryChannel]) – The new category for this channel. Can be None to remove the\ncategory.",
            "slowmode_delay (int) – Specifies the slowmode rate limit for user in this channel, in seconds.\nA value of 0 disables slowmode. The maximum value possible is 21600.",
            "reason (Optional[str]) – The reason for editing this channel. Shows up on the audit log.",
            "overwrites (Dict[Union[Role, Member, Snowflake], PermissionOverwrite]) – The overwrites to apply to channel permissions. Useful for creating secret channels.",
            "default_auto_archive_duration (int) – The new default auto archive duration in minutes for threads created in this channel.\nMust be one of 60, 1440, 4320, or 10080.",
            "default_thread_slowmode_delay (int) – The new default slowmode delay in seconds for threads created in this channel.\n\nNew in version 2.3.",
            "The new default slowmode delay in seconds for threads created in this channel.",
            "New in version 2.3.",
            "default_sort_order (Optional[SortOrder]) – The default sort order type to use to order posts in this channel.\n\nNew in version 2.3.",
            "The default sort order type to use to order posts in this channel.",
            "New in version 2.3.",
            "default_reaction_emoji (Optional[discord.Emoji | int | str]) – The default reaction emoji.\nCan be a unicode emoji or a custom emoji in the forms:\nEmoji, snowflake ID, string representation (eg. ‘<a:emoji_name:emoji_id>’).\n\nNew in version 2.5.",
            "The default reaction emoji.\nCan be a unicode emoji or a custom emoji in the forms:\nEmoji, snowflake ID, string representation (eg. ‘<a:emoji_name:emoji_id>’).",
            "New in version 2.5.",
            "available_tags (List[ForumTag]) – The set of tags that can be used in this channel. Must be less than 20.\n\nNew in version 2.3.",
            "The set of tags that can be used in this channel. Must be less than 20.",
            "New in version 2.3.",
            "require_tag (bool) – Whether a tag should be required to be specified when creating a thread in this channel.\n\nNew in version 2.3.",
            "Whether a tag should be required to be specified when creating a thread in this channel.",
            "New in version 2.3.",
            "The newly edited forum channel. If the edit was only positional\nthen None is returned instead.",
            "Optional[ForumChannel]",
            "InvalidArgument – If position is less than 0 or greater than the number of channels, or if\n    the permission overwrite information is not in proper form.",
            "Forbidden – You do not have permissions to edit the channel.",
            "HTTPException – Editing the channel failed.",
            "This function is a coroutine.",
            "Creates a thread in this forum channel.",
            "To create a public thread, you must have create_public_threads.\nFor a private thread, create_private_threads is needed instead.",
            "New in version 2.0.",
            "name (str) – The name of the thread.",
            "content (str) – The content of the message to send.",
            "embed (Embed) – The rich embed for the content.",
            "embeds (List[Embed]) – A list of embeds to upload. Must be a maximum of 10.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "stickers (Sequence[Union[GuildSticker, StickerItem]]) – A list of stickers to upload. Must be a maximum of 3.",
            "delete_message_after (int) – The time to wait before deleting the thread.",
            "nonce (Union[str, int]) – The nonce to use for sending this message. If the message was successfully sent,\nthen the message will have a nonce with this value.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "view (discord.ui.View) – A Discord UI View to add to the message.",
            "applied_tags (List[discord.ForumTag]) – A list of tags to apply to the new thread.",
            "auto_archive_duration (int) – The duration in minutes before a thread is automatically archived for inactivity.\nIf not provided, the channel’s default auto archive duration is used.",
            "slowmode_delay (int) – The number of seconds a member must wait between sending messages\nin the new thread. A value of 0 denotes that it is disabled.\nBots and users with manage_channels or\nmanage_messages bypass slowmode.\nIf not provided, the forum channel’s default slowmode is used.",
            "reason (str) – The reason for creating a new thread. Shows up on the audit log.",
            "The created thread",
            "Thread",
            "Forbidden – You do not have permissions to create a thread.",
            "HTTPException – Starting the thread failed.",
            "Returns an AsyncIterator that iterates over all archived threads in the guild.",
            "You must have read_message_history to use this. If iterating over private threads\nthen manage_threads is also required.",
            "New in version 2.0.",
            "limit (Optional[bool]) – The number of threads to retrieve.\nIf None, retrieves every archived thread in the channel. Note, however,\nthat this would make it a slow operation.",
            "before (Optional[Union[abc.Snowflake, datetime.datetime]]) – Retrieve archived channels before the given date or ID.",
            "private (bool) – Whether to retrieve private archived threads.",
            "joined (bool) – Whether to retrieve private archived threads that you’ve joined.\nYou cannot set joined to True and private to False.",
            "Thread – The archived threads.",
            "Forbidden – You do not have permissions to get archived threads.",
            "HTTPException – The request to get the archived threads failed.",
            "ArchivedThreadIterator",
            "The category this channel belongs to.",
            "If there is no category then this is None.",
            "Returns a list of roles that have been overridden from\ntheir default values in the roles attribute.",
            "This function is a coroutine.",
            "Clones this channel. This creates a channel with the same properties\nas this channel.",
            "You must have the manage_channels permission to\ndo this.",
            "New in version 1.1.",
            "name (Optional[str]) – The name of the new channel. If not provided, defaults to this\nchannel name.",
            "reason (Optional[str]) – The reason for cloning this channel. Shows up on the audit log.",
            "The channel that was created.",
            "abc.GuildChannel",
            "Forbidden – You do not have the proper permissions to create this channel.",
            "HTTPException – Creating the channel failed.",
            "This function is a coroutine.",
            "Creates an instant invite from a text or voice channel.",
            "You must have the create_instant_invite permission to\ndo this.",
            "max_age (int) – How long the invite should last in seconds. If it’s 0 then the invite\ndoesn’t expire. Defaults to 0.",
            "max_uses (int) – How many uses the invite could be used for. If it’s 0 then there\nare unlimited uses. Defaults to 0.",
            "temporary (bool) – Denotes that the invite grants temporary membership\n(i.e. they get kicked after they disconnect). Defaults to False.",
            "unique (bool) – Indicates if a unique invite URL should be created. Defaults to True.\nIf this is set to False then it will return a previously created\ninvite.",
            "reason (Optional[str]) – The reason for creating this invite. Shows up on the audit log.",
            "target_type (Optional[InviteTarget]) – The type of target for the voice channel invite, if any.\n\nNew in version 2.0.",
            "The type of target for the voice channel invite, if any.",
            "New in version 2.0.",
            "target_user (Optional[User]) – The user whose stream to display for this invite, required if target_type is TargetType.stream.\nThe user must be streaming in the channel.\n\nNew in version 2.0.",
            "The user whose stream to display for this invite, required if target_type is TargetType.stream.\nThe user must be streaming in the channel.",
            "New in version 2.0.",
            "target_application_id (Optional[int]) – The id of the embedded application for the invite, required if target_type is\nTargetType.embedded_application.\n\nNew in version 2.0.",
            "The id of the embedded application for the invite, required if target_type is\nTargetType.embedded_application.",
            "New in version 2.0.",
            "target_event (Optional[ScheduledEvent]) – The scheduled event object to link to the event.\nShortcut to Invite.set_scheduled_event()\nSee Invite.set_scheduled_event() for more\ninfo on event invite linking.\n\nNew in version 2.0.",
            "The scheduled event object to link to the event.\nShortcut to Invite.set_scheduled_event()",
            "See Invite.set_scheduled_event() for more\ninfo on event invite linking.",
            "New in version 2.0.",
            "The invite that was created.",
            "Invite",
            "HTTPException – Invite creation failed.",
            "NotFound – The channel that was passed is a category or an invalid channel.",
            "This function is a coroutine.",
            "Creates a webhook for this channel.",
            "Requires manage_webhooks permissions.",
            "Changed in version 1.1: Added the reason keyword-only parameter.",
            "name (str) – The webhook’s name.",
            "avatar (Optional[bytes]) – A bytes-like object representing the webhook’s default avatar.\nThis operates similarly to edit().",
            "reason (Optional[str]) – The reason for creating this webhook. Shows up in the audit logs.",
            "The created webhook.",
            "Webhook",
            "HTTPException – Creating the webhook failed.",
            "Forbidden – You do not have permissions to create a webhook.",
            "Returns the channel’s creation time in UTC.",
            "This function is a coroutine.",
            "Deletes the channel.",
            "You must have manage_channels permission to use this.",
            "reason (Optional[str]) – The reason for deleting this channel.\nShows up on the audit log.",
            "Forbidden – You do not have proper permissions to delete the channel.",
            "NotFound – The channel was not found or was already deleted.",
            "HTTPException – Deleting the channel failed.",
            "None",
            "This function is a coroutine.",
            "Deletes a list of messages. This is similar to Message.delete()\nexcept it bulk deletes multiple messages.",
            "As a special case, if the number of messages is 0, then nothing\nis done. If the number of messages is 1 then single message\ndelete is done. If it’s more than two, then bulk delete is used.",
            "You cannot bulk delete more than 100 messages or messages that\nare older than 14 days old.",
            "You must have the manage_messages permission to\nuse this.",
            "messages (Iterable[abc.Snowflake]) – An iterable of messages denoting which ones to bulk delete.",
            "reason (Optional[str]) – The reason for deleting the messages. Shows up on the audit log.",
            "ClientException – The number of messages to delete was more than 100.",
            "Forbidden – You do not have proper permissions to delete the messages.",
            "NotFound – If single delete, then the message was already deleted.",
            "HTTPException – Deleting the messages failed.",
            "None",
            "Follows a channel using a webhook.",
            "Only news channels can be followed.",
            "Note",
            "The webhook returned will not provide a token to do webhook\nactions, as Discord does not provide it.",
            "New in version 1.3.",
            "destination (TextChannel) – The channel you would like to follow from.",
            "reason (Optional[str]) – The reason for following the channel. Shows up on the destination guild’s audit log.\n\nNew in version 1.4.",
            "The reason for following the channel. Shows up on the destination guild’s audit log.",
            "New in version 1.4.",
            "The created webhook.",
            "Webhook",
            "HTTPException – Following the channel failed.",
            "Forbidden – You do not have the permissions to create a webhook.",
            "Creates a PartialMessage from the message ID.",
            "This is useful if you want to work with a message and only have its ID without\ndoing an unnecessary API call.",
            "New in version 1.6.",
            "message_id (int) – The message ID to create a partial message for.",
            "The partial message.",
            "PartialMessage",
            "Returns a thread with the given ID.",
            "New in version 2.0.",
            "thread_id (int) – The ID to search for.",
            "The returned thread or None if not found.",
            "Optional[Thread]",
            "This function is a coroutine.",
            "Returns a list of all active instant invites from this channel.",
            "You must have manage_channels to get this information.",
            "The list of invites that are currently active.",
            "List[Invite]",
            "Forbidden – You do not have proper permissions to get the information.",
            "HTTPException – An error occurred while fetching the information.",
            "Checks if the channel is NSFW.",
            "bool",
            "Returns a URL that allows the client to jump to the channel.",
            "New in version 2.0.",
            "Fetches the last message from this channel in cache.",
            "The message might not be valid or point to an existing message.",
            "Reliable Fetching",
            "For a slightly more reliable method of fetching the\nlast message, consider using either history()\nor fetch_message() with the last_message_id\nattribute.",
            "The last message in this channel or None if not found.",
            "Optional[Message]",
            "Returns all members that can see this channel.",
            "The string that allows you to mention the channel.",
            "This function is a coroutine.",
            "A rich interface to help move a channel relative to other channels.",
            "If exact position movement is required, edit should be used instead.",
            "You must have the manage_channels permission to\ndo this.",
            "Note",
            "Voice channels will always be sorted below text channels.\nThis is a Discord limitation.",
            "New in version 1.7.",
            "beginning (bool) – Whether to move the channel to the beginning of the\nchannel list (or category if given).\nThis is mutually exclusive with end, before, and after.",
            "end (bool) – Whether to move the channel to the end of the\nchannel list (or category if given).\nThis is mutually exclusive with beginning, before, and after.",
            "before (Snowflake) – The channel that should be before our current channel.\nThis is mutually exclusive with beginning, end, and after.",
            "after (Snowflake) – The channel that should be after our current channel.\nThis is mutually exclusive with beginning, end, and before.",
            "offset (int) – The number of channels to offset the move by. For example,\nan offset of 2 with beginning=True would move\nit 2 after the beginning. A positive number moves it below\nwhile a negative number moves it above. Note that this\nnumber is relative and computed after the beginning,\nend, before, and after parameters.",
            "category (Optional[Snowflake]) – The category to move this channel under.\nIf None is given then it moves it out of the category.\nThis parameter is ignored if moving a category channel.",
            "sync_permissions (bool) – Whether to sync the permissions with the category (if given).",
            "reason (str) – The reason for the move.",
            "InvalidArgument – An invalid position was given or a bad mix of arguments was passed.",
            "Forbidden – You do not have permissions to move the channel.",
            "HTTPException – Moving the channel failed.",
            "None",
            "Returns all of the channel’s overwrites.",
            "This is returned as a dictionary where the key contains the target which\ncan be either a Role or a Member and the value is the\noverwrite as a PermissionOverwrite.",
            "The channel’s permission overwrites.",
            "Dict[Union[Role, Member], PermissionOverwrite]",
            "Returns the channel-specific overwrites for a member or a role.",
            "obj (Union[Role, User]) – The role or user denoting\nwhose overwrite to get.",
            "The permission overwrites for this object.",
            "PermissionOverwrite",
            "Handles permission resolution for the Member\nor Role.",
            "This function takes into consideration the following cases:",
            "Guild owner",
            "Guild roles",
            "Channel overrides",
            "Member overrides",
            "If a Role is passed, then it checks the permissions\nsomeone with that role would have, which is essentially:",
            "The default role permissions",
            "The permissions of the role used as a parameter",
            "The default role permission overwrites",
            "The permission overwrites of the role used as a parameter",
            "Changed in version 2.0: The object passed in can now be a role object.",
            "obj (Union[Member, Role]) – The object to resolve permissions for. This could be either\na member or a role. If it’s a role then member overwrites\nare not computed.",
            "The resolved permissions for the member or role.",
            "Permissions",
            "Whether the permissions for this channel are synced with the\ncategory it belongs to.",
            "If there is no category then this is False.",
            "New in version 1.3.",
            "This function is a coroutine.",
            "Purges a list of messages that meet the criteria given by the predicate\ncheck. If a check is not provided then all messages are deleted\nwithout discrimination.",
            "You must have the manage_messages permission to\ndelete messages even if they are your own.\nThe read_message_history permission is\nalso needed to retrieve message history.",
            "limit (Optional[int]) – The number of messages to search through. This is not the number\nof messages that will be deleted, though it can be.",
            "check (Callable[[Message], bool]) – The function used to check if a message should be deleted.\nIt must take a Message as its sole parameter.",
            "before (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as before in history().",
            "after (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as after in history().",
            "around (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as around in history().",
            "oldest_first (Optional[bool]) – Same as oldest_first in history().",
            "bulk (bool) – If True, use bulk delete. Setting this to False is useful for mass-deleting\na bot’s own messages without Permissions.manage_messages. When True, will\nfall back to single delete if messages are older than two weeks.",
            "reason (Optional[str]) – The reason for deleting the messages. Shows up on the audit log.",
            "The list of messages that were deleted.",
            "List[Message]",
            "Forbidden – You do not have proper permissions to do the actions required.",
            "HTTPException – Purging the messages failed.",
            "Examples",
            "Deleting bot’s messages",
            "This function is a coroutine.",
            "Sets the channel specific permission overwrites for a target in the\nchannel.",
            "The target parameter should either be a Member or a\nRole that belongs to guild.",
            "The overwrite parameter, if given, must either be None or\nPermissionOverwrite. For convenience, you can pass in\nkeyword arguments denoting Permissions attributes. If this is\ndone, then you cannot mix the keyword arguments with the overwrite\nparameter.",
            "If the overwrite parameter is None, then the permission\noverwrites are deleted.",
            "You must have the manage_roles permission to use this.",
            "Note",
            "This method replaces the old overwrites with the ones given.",
            "Examples",
            "Setting allow and deny:",
            "Deleting overwrites",
            "Using PermissionOverwrite",
            "target (Union[Member, Role]) – The member or role to overwrite permissions for.",
            "overwrite (Optional[PermissionOverwrite]) – The permissions to allow and deny to the target, or None to\ndelete the overwrite.",
            "**permissions – A keyword argument list of permissions to set for ease of use.\nCannot be mixed with overwrite.",
            "reason (Optional[str]) – The reason for doing this action. Shows up on the audit log.",
            "Forbidden – You do not have permissions to edit channel specific permissions.",
            "HTTPException – Editing channel specific permissions failed.",
            "NotFound – The role or member being edited is not part of the guild.",
            "InvalidArgument – The overwrite parameter invalid or the target type was not\n    Role or Member.",
            "Returns all the threads that you can see.",
            "New in version 2.0.",
            "The channel’s Discord type.",
            "This function is a coroutine.",
            "Gets the list of webhooks from this channel.",
            "Requires manage_webhooks permissions.",
            "The webhooks for this channel.",
            "List[Webhook]",
            "Forbidden – You don’t have permissions to get the webhooks.",
            "Represents a Discord guild voice channel.",
            "Checks if two channels are equal.",
            "Checks if two channels are not equal.",
            "Returns the channel’s hash.",
            "Returns the channel’s name.",
            "The channel name.",
            "str",
            "The guild the channel belongs to.",
            "Guild",
            "The channel ID.",
            "int",
            "The category channel ID this channel belongs to, if applicable.",
            "Optional[int]",
            "The position in the channel list. This is a number that starts at 0. e.g. the\ntop channel is position 0. Can be None if the channel was received in an interaction.",
            "Optional[int]",
            "The channel’s preferred audio bitrate in bits per second.",
            "int",
            "The channel’s limit for number of members that can be in a voice channel.",
            "int",
            "The region for the voice channel’s voice communication.\nA value of None indicates automatic voice region detection.",
            "New in version 1.7.",
            "Optional[VoiceRegion]",
            "The camera video quality for the voice channel’s participants.",
            "New in version 2.0.",
            "VideoQualityMode",
            "The ID of the last message sent to this channel. It may not always point to an existing or valid message.",
            "New in version 2.0.",
            "Optional[int]",
            "The number of seconds a member must wait between sending messages\nin this channel. A value of 0 denotes that it is disabled.\nBots and users with manage_channels or\nmanage_messages bypass slowmode.",
            "New in version 2.5.",
            "int",
            "The channel’s status, if set.",
            "New in version 2.5.",
            "Optional[str]",
            "Extra features of the channel.",
            "New in version 2.0.",
            "ChannelFlags",
            "state (ConnectionState) –",
            "guild (Guild) –",
            "data (VoiceChannelPayload) –",
            "Checks if the channel is NSFW.",
            "bool",
            "Fetches the last message from this channel in cache.",
            "The message might not be valid or point to an existing message.",
            "Reliable Fetching",
            "For a slightly more reliable method of fetching the\nlast message, consider using either history()\nor fetch_message() with the last_message_id\nattribute.",
            "The last message in this channel or None if not found.",
            "Optional[Message]",
            "Creates a PartialMessage from the message ID.",
            "This is useful if you want to work with a message and only have its ID without\ndoing an unnecessary API call.",
            "New in version 1.6.",
            "message_id (int) – The message ID to create a partial message for.",
            "The partial message.",
            "PartialMessage",
            "This function is a coroutine.",
            "Deletes a list of messages. This is similar to Message.delete()\nexcept it bulk deletes multiple messages.",
            "As a special case, if the number of messages is 0, then nothing\nis done. If the number of messages is 1 then single message\ndelete is done. If it’s more than two, then bulk delete is used.",
            "You cannot bulk delete more than 100 messages or messages that\nare older than 14 days old.",
            "You must have the manage_messages permission to\nuse this.",
            "messages (Iterable[abc.Snowflake]) – An iterable of messages denoting which ones to bulk delete.",
            "reason (Optional[str]) – The reason for deleting the messages. Shows up on the audit log.",
            "ClientException – The number of messages to delete was more than 100.",
            "Forbidden – You do not have proper permissions to delete the messages.",
            "NotFound – If single delete, then the message was already deleted.",
            "HTTPException – Deleting the messages failed.",
            "None",
            "This function is a coroutine.",
            "Purges a list of messages that meet the criteria given by the predicate\ncheck. If a check is not provided then all messages are deleted\nwithout discrimination.",
            "You must have the manage_messages permission to\ndelete messages even if they are your own.\nThe read_message_history permission is\nalso needed to retrieve message history.",
            "limit (Optional[int]) – The number of messages to search through. This is not the number\nof messages that will be deleted, though it can be.",
            "check (Callable[[Message], bool]) – The function used to check if a message should be deleted.\nIt must take a Message as its sole parameter.",
            "before (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as before in history().",
            "after (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as after in history().",
            "around (Optional[Union[abc.Snowflake, datetime.datetime]]) – Same as around in history().",
            "oldest_first (Optional[bool]) – Same as oldest_first in history().",
            "bulk (bool) – If True, use bulk delete. Setting this to False is useful for mass-deleting\na bot’s own messages without Permissions.manage_messages. When True, will\nfall back to single delete if messages are older than two weeks.",
            "reason (Optional[str]) – The reason for deleting the messages. Shows up on the audit log.",
            "The list of messages that were deleted.",
            "List[Message]",
            "Forbidden – You do not have proper permissions to do the actions required.",
            "HTTPException – Purging the messages failed.",
            "Examples",
            "Deleting bot’s messages",
            "This function is a coroutine.",
            "Gets the list of webhooks from this channel.",
            "Requires manage_webhooks permissions.",
            "The webhooks for this channel.",
            "List[Webhook]",
            "Forbidden – You don’t have permissions to get the webhooks.",
            "This function is a coroutine.",
            "Creates a webhook for this channel.",
            "Requires manage_webhooks permissions.",
            "Changed in version 1.1: Added the reason keyword-only parameter.",
            "name (str) – The webhook’s name.",
            "avatar (Optional[bytes]) – A bytes-like object representing the webhook’s default avatar.\nThis operates similarly to edit().",
            "reason (Optional[str]) – The reason for creating this webhook. Shows up in the audit logs.",
            "The created webhook.",
            "Webhook",
            "HTTPException – Creating the webhook failed.",
            "Forbidden – You do not have permissions to create a webhook.",
            "The channel’s Discord type.",
            "This function is a coroutine.",
            "Clones this channel. This creates a channel with the same properties\nas this channel.",
            "You must have the manage_channels permission to\ndo this.",
            "New in version 1.1.",
            "name (Optional[str]) – The name of the new channel. If not provided, defaults to this\nchannel name.",
            "reason (Optional[str]) – The reason for cloning this channel. Shows up on the audit log.",
            "The channel that was created.",
            "abc.GuildChannel",
            "Forbidden – You do not have the proper permissions to create this channel.",
            "HTTPException – Creating the channel failed.",
            "This function is a coroutine.",
            "Edits the channel.",
            "You must have the manage_channels permission to\nuse this.",
            "Changed in version 1.3: The overwrites keyword-only parameter was added.",
            "Changed in version 2.0: Edits are no longer in-place, the newly edited channel is returned instead.",
            "name (str) – The new channel’s name.",
            "bitrate (int) – The new channel’s bitrate.",
            "user_limit (int) – The new channel’s user limit.",
            "position (int) – The new channel’s position.",
            "sync_permissions (bool) – Whether to sync permissions with the channel’s new or pre-existing\ncategory. Defaults to False.",
            "category (Optional[CategoryChannel]) – The new category for this channel. Can be None to remove the\ncategory.",
            "reason (Optional[str]) – The reason for editing this channel. Shows up on the audit log.",
            "overwrites (Dict[Union[Role, Member, Snowflake], PermissionOverwrite]) – The overwrites to apply to channel permissions. Useful for creating secret channels.",
            "rtc_region (Optional[VoiceRegion]) – The new region for the voice channel’s voice communication.\nA value of None indicates automatic voice region detection.\n\nNew in version 1.7.",
            "The new region for the voice channel’s voice communication.\nA value of None indicates automatic voice region detection.",
            "New in version 1.7.",
            "video_quality_mode (VideoQualityMode) – The camera video quality for the voice channel’s participants.\n\nNew in version 2.0.",
            "The camera video quality for the voice channel’s participants.",
            "New in version 2.0.",
            "The newly edited voice channel. If the edit was only positional\nthen None is returned instead.",
            "Optional[VoiceChannel]",
            "InvalidArgument – If the permission overwrite information is not in proper form.",
            "Forbidden – You do not have permissions to edit the channel.",
            "HTTPException – Editing the channel failed.",
            "This function is a coroutine.",
            "A shortcut method that creates an instant activity invite.",
            "You must have the start_embedded_activities permission to\ndo this.",
            "activity (Union[discord.EmbeddedActivity, int]) – The activity to create an invite for which can be an application id as well.",
            "max_age (int) – How long the invite should last in seconds. If it’s 0 then the invite\ndoesn’t expire. Defaults to 0.",
            "max_uses (int) – How many uses the invite could be used for. If it’s 0 then there\nare unlimited uses. Defaults to 0.",
            "temporary (bool) – Denotes that the invite grants temporary membership\n(i.e. they get kicked after they disconnect). Defaults to False.",
            "unique (bool) – Indicates if a unique invite URL should be created. Defaults to True.\nIf this is set to False then it will return a previously created\ninvite.",
            "reason (Optional[str]) – The reason for creating this invite. Shows up on the audit log.",
            "The invite that was created.",
            "Invite",
            "TypeError – If the activity is not a valid activity or application id.",
            "HTTPException – Invite creation failed.",
            "This function is a coroutine.",
            "Sets the status of the voice channel.",
            "You must have the set_voice_channel_status permission to use this.",
            "status (Union[str, None]) – The new status.",
            "reason (Optional[str]) – The reason for setting the status. Shows up on the audit log.",
            "Forbidden – You do not have proper permissions to set the status.",
            "HTTPException – Setting the status failed.",
            "None",
            "Returns a bool indicating whether you have the permissions to send the object(s).",
            "Indicates whether you have the permissions to send the object(s).",
            "bool",
            "TypeError – An invalid type has been passed.",
            "The category this channel belongs to.",
            "If there is no category then this is None.",
            "Returns a list of roles that have been overridden from\ntheir default values in the roles attribute.",
            "This function is a coroutine.",
            "Connects to voice and creates a VoiceClient to establish\nyour connection to the voice server.",
            "This requires Intents.voice_states.",
            "timeout (float) – The timeout in seconds to wait for the voice endpoint.",
            "reconnect (bool) – Whether the bot should automatically attempt\na reconnect if a part of the handshake fails\nor the gateway goes down.",
            "cls (Type[VoiceProtocol]) – A type that subclasses VoiceProtocol to connect with.\nDefaults to VoiceClient.",
            "A voice client that is fully connected to the voice server.",
            "VoiceProtocol",
            "asyncio.TimeoutError – Could not connect to the voice channel in time.",
            "ClientException – You are already connected to a voice channel.",
            "OpusNotLoaded – The opus library has not been loaded.",
            "This function is a coroutine.",
            "Creates an instant invite from a text or voice channel.",
            "You must have the create_instant_invite permission to\ndo this.",
            "max_age (int) – How long the invite should last in seconds. If it’s 0 then the invite\ndoesn’t expire. Defaults to 0.",
            "max_uses (int) – How many uses the invite could be used for. If it’s 0 then there\nare unlimited uses. Defaults to 0.",
            "temporary (bool) – Denotes that the invite grants temporary membership\n(i.e. they get kicked after they disconnect). Defaults to False.",
            "unique (bool) – Indicates if a unique invite URL should be created. Defaults to True.\nIf this is set to False then it will return a previously created\ninvite.",
            "reason (Optional[str]) – The reason for creating this invite. Shows up on the audit log.",
            "target_type (Optional[InviteTarget]) – The type of target for the voice channel invite, if any.\n\nNew in version 2.0.",
            "The type of target for the voice channel invite, if any.",
            "New in version 2.0.",
            "target_user (Optional[User]) – The user whose stream to display for this invite, required if target_type is TargetType.stream.\nThe user must be streaming in the channel.\n\nNew in version 2.0.",
            "The user whose stream to display for this invite, required if target_type is TargetType.stream.\nThe user must be streaming in the channel.",
            "New in version 2.0.",
            "target_application_id (Optional[int]) – The id of the embedded application for the invite, required if target_type is\nTargetType.embedded_application.\n\nNew in version 2.0.",
            "The id of the embedded application for the invite, required if target_type is\nTargetType.embedded_application.",
            "New in version 2.0.",
            "target_event (Optional[ScheduledEvent]) – The scheduled event object to link to the event.\nShortcut to Invite.set_scheduled_event()\nSee Invite.set_scheduled_event() for more\ninfo on event invite linking.\n\nNew in version 2.0.",
            "The scheduled event object to link to the event.\nShortcut to Invite.set_scheduled_event()",
            "See Invite.set_scheduled_event() for more\ninfo on event invite linking.",
            "New in version 2.0.",
            "The invite that was created.",
            "Invite",
            "HTTPException – Invite creation failed.",
            "NotFound – The channel that was passed is a category or an invalid channel.",
            "Returns the channel’s creation time in UTC.",
            "This function is a coroutine.",
            "Deletes the channel.",
            "You must have manage_channels permission to use this.",
            "reason (Optional[str]) – The reason for deleting this channel.\nShows up on the audit log.",
            "Forbidden – You do not have proper permissions to delete the channel.",
            "NotFound – The channel was not found or was already deleted.",
            "HTTPException – Deleting the channel failed.",
            "None",
            "This function is a coroutine.",
            "Retrieves a single Message from the destination.",
            "id (int) – The message ID to look for.",
            "The message asked for.",
            "Message",
            "NotFound – The specified message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "Returns an AsyncIterator that enables receiving the destination’s message history.",
            "You must have read_message_history permissions to use this.",
            "limit (Optional[int]) – The number of messages to retrieve.\nIf None, retrieves every message in the channel. Note, however,\nthat this would make it a slow operation.",
            "before (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages before this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages after this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "around (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages around this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.\nWhen using this argument, the maximum limit is 101. Note that if the limit is an\neven number, then this will return at most limit + 1 messages.",
            "oldest_first (Optional[bool]) – If set to True, return messages in oldest->newest order. Defaults to True if\nafter is specified, otherwise False.",
            "Message – The message with the message data parsed.",
            "Forbidden – You do not have permissions to get channel message history.",
            "HTTPException – The request to get message history failed.",
            "HistoryIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "All parameters are optional.",
            "This function is a coroutine.",
            "Returns a list of all active instant invites from this channel.",
            "You must have manage_channels to get this information.",
            "The list of invites that are currently active.",
            "List[Invite]",
            "Forbidden – You do not have proper permissions to get the information.",
            "HTTPException – An error occurred while fetching the information.",
            "Returns a URL that allows the client to jump to the channel.",
            "New in version 2.0.",
            "Returns all members that are currently inside this voice channel.",
            "The string that allows you to mention the channel.",
            "This function is a coroutine.",
            "A rich interface to help move a channel relative to other channels.",
            "If exact position movement is required, edit should be used instead.",
            "You must have the manage_channels permission to\ndo this.",
            "Note",
            "Voice channels will always be sorted below text channels.\nThis is a Discord limitation.",
            "New in version 1.7.",
            "beginning (bool) – Whether to move the channel to the beginning of the\nchannel list (or category if given).\nThis is mutually exclusive with end, before, and after.",
            "end (bool) – Whether to move the channel to the end of the\nchannel list (or category if given).\nThis is mutually exclusive with beginning, before, and after.",
            "before (Snowflake) – The channel that should be before our current channel.\nThis is mutually exclusive with beginning, end, and after.",
            "after (Snowflake) – The channel that should be after our current channel.\nThis is mutually exclusive with beginning, end, and before.",
            "offset (int) – The number of channels to offset the move by. For example,\nan offset of 2 with beginning=True would move\nit 2 after the beginning. A positive number moves it below\nwhile a negative number moves it above. Note that this\nnumber is relative and computed after the beginning,\nend, before, and after parameters.",
            "category (Optional[Snowflake]) – The category to move this channel under.\nIf None is given then it moves it out of the category.\nThis parameter is ignored if moving a category channel.",
            "sync_permissions (bool) – Whether to sync the permissions with the category (if given).",
            "reason (str) – The reason for the move.",
            "InvalidArgument – An invalid position was given or a bad mix of arguments was passed.",
            "Forbidden – You do not have permissions to move the channel.",
            "HTTPException – Moving the channel failed.",
            "None",
            "Returns all of the channel’s overwrites.",
            "This is returned as a dictionary where the key contains the target which\ncan be either a Role or a Member and the value is the\noverwrite as a PermissionOverwrite.",
            "The channel’s permission overwrites.",
            "Dict[Union[Role, Member], PermissionOverwrite]",
            "Returns the channel-specific overwrites for a member or a role.",
            "obj (Union[Role, User]) – The role or user denoting\nwhose overwrite to get.",
            "The permission overwrites for this object.",
            "PermissionOverwrite",
            "Handles permission resolution for the Member\nor Role.",
            "This function takes into consideration the following cases:",
            "Guild owner",
            "Guild roles",
            "Channel overrides",
            "Member overrides",
            "If a Role is passed, then it checks the permissions\nsomeone with that role would have, which is essentially:",
            "The default role permissions",
            "The permissions of the role used as a parameter",
            "The default role permission overwrites",
            "The permission overwrites of the role used as a parameter",
            "Changed in version 2.0: The object passed in can now be a role object.",
            "obj (Union[Member, Role]) – The object to resolve permissions for. This could be either\na member or a role. If it’s a role then member overwrites\nare not computed.",
            "The resolved permissions for the member or role.",
            "Permissions",
            "Whether the permissions for this channel are synced with the\ncategory it belongs to.",
            "If there is no category then this is False.",
            "New in version 1.3.",
            "This function is a coroutine.",
            "Retrieves all messages that are currently pinned in the channel.",
            "Note",
            "Due to a limitation with the Discord API, the Message\nobjects returned by this method do not contain complete\nMessage.reactions data.",
            "The messages that are currently pinned.",
            "List[Message]",
            "HTTPException – Retrieving the pinned messages failed.",
            "This function is a coroutine.",
            "Sends a message to the destination with the content given.",
            "The content must be a type that can convert to a string through str(content).\nIf the content is set to None (the default), then the embed parameter must\nbe provided.",
            "To upload a single file, the file parameter should be used with a\nsingle File object. To upload multiple files, the files\nparameter should be used with a list of File objects.\nSpecifying both parameters will lead to an exception.",
            "To upload a single embed, the embed parameter should be used with a\nsingle Embed object. To upload multiple embeds, the embeds\nparameter should be used with a list of Embed objects.\nSpecifying both parameters will lead to an exception.",
            "content (Optional[str]) – The content of the message to send.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "embed (Embed) – The rich embed for the content.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "nonce (Union[str, int]) – The nonce to use for sending this message. If the message was successfully sent,\nthen the message will have a nonce with this value.",
            "enforce_nonce (Optional[bool]) – Whether nonce is enforced to be validated.\n\nNew in version 2.5.",
            "Whether nonce is enforced to be validated.",
            "New in version 2.5.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent. If the deletion fails,\nthen it is silently ignored.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "New in version 1.4.",
            "reference (Union[Message, MessageReference, PartialMessage]) – A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.\n\nNew in version 1.6.",
            "A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.",
            "New in version 1.6.",
            "mention_author (Optional[bool]) – If set, overrides the replied_user attribute of allowed_mentions.\n\nNew in version 1.6.",
            "If set, overrides the replied_user attribute of allowed_mentions.",
            "New in version 1.6.",
            "view (discord.ui.View) – A Discord UI View to add to the message.",
            "embeds (List[Embed]) – A list of embeds to upload. Must be a maximum of 10.\n\nNew in version 2.0.",
            "A list of embeds to upload. Must be a maximum of 10.",
            "New in version 2.0.",
            "stickers (Sequence[Union[GuildSticker, StickerItem]]) – A list of stickers to upload. Must be a maximum of 3.\n\nNew in version 2.0.",
            "A list of stickers to upload. Must be a maximum of 3.",
            "New in version 2.0.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "silent (bool) – Whether to suppress push and desktop notifications for the message.\n\nNew in version 2.4.",
            "Whether to suppress push and desktop notifications for the message.",
            "New in version 2.4.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size,\n    you specified both file and files,\n    or you specified both embed and embeds,\n    or the reference object is not a Message,\n    MessageReference or PartialMessage.",
            "This function is a coroutine.",
            "Sets the channel specific permission overwrites for a target in the\nchannel.",
            "The target parameter should either be a Member or a\nRole that belongs to guild.",
            "The overwrite parameter, if given, must either be None or\nPermissionOverwrite. For convenience, you can pass in\nkeyword arguments denoting Permissions attributes. If this is\ndone, then you cannot mix the keyword arguments with the overwrite\nparameter.",
            "If the overwrite parameter is None, then the permission\noverwrites are deleted.",
            "You must have the manage_roles permission to use this.",
            "Note",
            "This method replaces the old overwrites with the ones given.",
            "Examples",
            "Setting allow and deny:",
            "Deleting overwrites",
            "Using PermissionOverwrite",
            "target (Union[Member, Role]) – The member or role to overwrite permissions for.",
            "overwrite (Optional[PermissionOverwrite]) – The permissions to allow and deny to the target, or None to\ndelete the overwrite.",
            "**permissions – A keyword argument list of permissions to set for ease of use.\nCannot be mixed with overwrite.",
            "reason (Optional[str]) – The reason for doing this action. Shows up on the audit log.",
            "Forbidden – You do not have permissions to edit channel specific permissions.",
            "HTTPException – Editing channel specific permissions failed.",
            "NotFound – The role or member being edited is not part of the guild.",
            "InvalidArgument – The overwrite parameter invalid or the target type was not\n    Role or Member.",
            "This function is a coroutine.",
            "Triggers a typing indicator to the destination.",
            "Typing indicator will go away after 10 seconds, or after a message is sent.",
            "None",
            "Returns a context manager that allows you to type for an indefinite period of time.",
            "This is useful for denoting long computations in your bot.\n:rtype: Typing",
            "Note",
            "This is both a regular context manager and an async context manager.\nThis means that both with and async with work with this.",
            "Example Usage:",
            "Returns a mapping of member IDs who have voice states in this channel.",
            "New in version 1.3.",
            "Note",
            "This function is intentionally low level to replace members\nwhen the member cache is unavailable.",
            "The mapping of member ID to a voice state.",
            "Mapping[int, VoiceState]",
            "Represents a Discord channel category.",
            "These are useful to group channels to logical compartments.",
            "Checks if two channels are equal.",
            "Checks if two channels are not equal.",
            "Returns the category’s hash.",
            "Returns the category’s name.",
            "The category name.",
            "str",
            "The guild the category belongs to.",
            "Guild",
            "The category channel ID.",
            "int",
            "The position in the category list. This is a number that starts at 0. e.g. the\ntop category is position 0. Can be None if the channel was received in an interaction.",
            "Optional[int]",
            "If the channel is marked as “not safe for work”.",
            "Note",
            "To check if the channel or the guild of that channel are marked as NSFW, consider is_nsfw() instead.",
            "bool",
            "Extra features of the channel.",
            "New in version 2.0.",
            "ChannelFlags",
            "state (ConnectionState) –",
            "guild (Guild) –",
            "data (CategoryChannelPayload) –",
            "The channel’s Discord type.",
            "Checks if the category is NSFW.",
            "bool",
            "This function is a coroutine.",
            "Clones this channel. This creates a channel with the same properties\nas this channel.",
            "You must have the manage_channels permission to\ndo this.",
            "New in version 1.1.",
            "name (Optional[str]) – The name of the new channel. If not provided, defaults to this\nchannel name.",
            "reason (Optional[str]) – The reason for cloning this channel. Shows up on the audit log.",
            "The channel that was created.",
            "abc.GuildChannel",
            "Forbidden – You do not have the proper permissions to create this channel.",
            "HTTPException – Creating the channel failed.",
            "This function is a coroutine.",
            "Edits the channel.",
            "You must have the manage_channels permission to\nuse this.",
            "Changed in version 1.3: The overwrites keyword-only parameter was added.",
            "Changed in version 2.0: Edits are no longer in-place, the newly edited channel is returned instead.",
            "name (str) – The new category’s name.",
            "position (int) – The new category’s position.",
            "nsfw (bool) – To mark the category as NSFW or not.",
            "reason (Optional[str]) – The reason for editing this category. Shows up on the audit log.",
            "overwrites (Dict[Union[Role, Member, Snowflake], PermissionOverwrite]) – The overwrites to apply to channel permissions. Useful for creating secret channels.",
            "The newly edited category channel. If the edit was only positional\nthen None is returned instead.",
            "Optional[CategoryChannel]",
            "InvalidArgument – If position is less than 0 or greater than the number of categories.",
            "Forbidden – You do not have permissions to edit the category.",
            "HTTPException – Editing the category failed.",
            "This function is a coroutine.",
            "A rich interface to help move a channel relative to other channels.",
            "If exact position movement is required, edit should be used instead.",
            "You must have the manage_channels permission to\ndo this.",
            "Note",
            "Voice channels will always be sorted below text channels.\nThis is a Discord limitation.",
            "New in version 1.7.",
            "beginning (bool) – Whether to move the channel to the beginning of the\nchannel list (or category if given).\nThis is mutually exclusive with end, before, and after.",
            "end (bool) – Whether to move the channel to the end of the\nchannel list (or category if given).\nThis is mutually exclusive with beginning, before, and after.",
            "before (Snowflake) – The channel that should be before our current channel.\nThis is mutually exclusive with beginning, end, and after.",
            "after (Snowflake) – The channel that should be after our current channel.\nThis is mutually exclusive with beginning, end, and before.",
            "offset (int) – The number of channels to offset the move by. For example,\nan offset of 2 with beginning=True would move\nit 2 after the beginning. A positive number moves it below\nwhile a negative number moves it above. Note that this\nnumber is relative and computed after the beginning,\nend, before, and after parameters.",
            "category (Optional[Snowflake]) – The category to move this channel under.\nIf None is given then it moves it out of the category.\nThis parameter is ignored if moving a category channel.",
            "sync_permissions (bool) – Whether to sync the permissions with the category (if given).",
            "reason (str) – The reason for the move.",
            "InvalidArgument – An invalid position was given or a bad mix of arguments was passed.",
            "Forbidden – You do not have permissions to move the channel.",
            "HTTPException – Moving the channel failed.",
            "Returns the channels that are under this category.",
            "These are sorted by the official Discord UI, which places voice channels below the text channels.",
            "Returns the text channels that are under this category.",
            "Returns the voice channels that are under this category.",
            "Returns the stage channels that are under this category.",
            "New in version 1.7.",
            "Returns the forum channels that are under this category.",
            "New in version 2.0.",
            "This function is a coroutine.",
            "A shortcut method to Guild.create_text_channel() to create a TextChannel in the category.",
            "The channel that was just created.",
            "TextChannel",
            "name (str) –",
            "options (Any) –",
            "This function is a coroutine.",
            "A shortcut method to Guild.create_voice_channel() to create a VoiceChannel in the category.",
            "The channel that was just created.",
            "VoiceChannel",
            "name (str) –",
            "options (Any) –",
            "This function is a coroutine.",
            "A shortcut method to Guild.create_stage_channel() to create a StageChannel in the category.",
            "New in version 1.7.",
            "The channel that was just created.",
            "StageChannel",
            "name (str) –",
            "options (Any) –",
            "This function is a coroutine.",
            "A shortcut method to Guild.create_forum_channel() to create a ForumChannel in the category.",
            "New in version 2.0.",
            "The channel that was just created.",
            "ForumChannel",
            "name (str) –",
            "options (Any) –",
            "The category this channel belongs to.",
            "If there is no category then this is None.",
            "Returns a list of roles that have been overridden from\ntheir default values in the roles attribute.",
            "This function is a coroutine.",
            "Creates an instant invite from a text or voice channel.",
            "You must have the create_instant_invite permission to\ndo this.",
            "max_age (int) – How long the invite should last in seconds. If it’s 0 then the invite\ndoesn’t expire. Defaults to 0.",
            "max_uses (int) – How many uses the invite could be used for. If it’s 0 then there\nare unlimited uses. Defaults to 0.",
            "temporary (bool) – Denotes that the invite grants temporary membership\n(i.e. they get kicked after they disconnect). Defaults to False.",
            "unique (bool) – Indicates if a unique invite URL should be created. Defaults to True.\nIf this is set to False then it will return a previously created\ninvite.",
            "reason (Optional[str]) – The reason for creating this invite. Shows up on the audit log.",
            "target_type (Optional[InviteTarget]) – The type of target for the voice channel invite, if any.\n\nNew in version 2.0.",
            "The type of target for the voice channel invite, if any.",
            "New in version 2.0.",
            "target_user (Optional[User]) – The user whose stream to display for this invite, required if target_type is TargetType.stream.\nThe user must be streaming in the channel.\n\nNew in version 2.0.",
            "The user whose stream to display for this invite, required if target_type is TargetType.stream.\nThe user must be streaming in the channel.",
            "New in version 2.0.",
            "target_application_id (Optional[int]) – The id of the embedded application for the invite, required if target_type is\nTargetType.embedded_application.\n\nNew in version 2.0.",
            "The id of the embedded application for the invite, required if target_type is\nTargetType.embedded_application.",
            "New in version 2.0.",
            "target_event (Optional[ScheduledEvent]) – The scheduled event object to link to the event.\nShortcut to Invite.set_scheduled_event()\nSee Invite.set_scheduled_event() for more\ninfo on event invite linking.\n\nNew in version 2.0.",
            "The scheduled event object to link to the event.\nShortcut to Invite.set_scheduled_event()",
            "See Invite.set_scheduled_event() for more\ninfo on event invite linking.",
            "New in version 2.0.",
            "The invite that was created.",
            "Invite",
            "HTTPException – Invite creation failed.",
            "NotFound – The channel that was passed is a category or an invalid channel.",
            "Returns the channel’s creation time in UTC.",
            "This function is a coroutine.",
            "Deletes the channel.",
            "You must have manage_channels permission to use this.",
            "reason (Optional[str]) – The reason for deleting this channel.\nShows up on the audit log.",
            "Forbidden – You do not have proper permissions to delete the channel.",
            "NotFound – The channel was not found or was already deleted.",
            "HTTPException – Deleting the channel failed.",
            "None",
            "This function is a coroutine.",
            "Returns a list of all active instant invites from this channel.",
            "You must have manage_channels to get this information.",
            "The list of invites that are currently active.",
            "List[Invite]",
            "Forbidden – You do not have proper permissions to get the information.",
            "HTTPException – An error occurred while fetching the information.",
            "Returns a URL that allows the client to jump to the channel.",
            "New in version 2.0.",
            "The string that allows you to mention the channel.",
            "Returns all of the channel’s overwrites.",
            "This is returned as a dictionary where the key contains the target which\ncan be either a Role or a Member and the value is the\noverwrite as a PermissionOverwrite.",
            "The channel’s permission overwrites.",
            "Dict[Union[Role, Member], PermissionOverwrite]",
            "Returns the channel-specific overwrites for a member or a role.",
            "obj (Union[Role, User]) – The role or user denoting\nwhose overwrite to get.",
            "The permission overwrites for this object.",
            "PermissionOverwrite",
            "Handles permission resolution for the Member\nor Role.",
            "This function takes into consideration the following cases:",
            "Guild owner",
            "Guild roles",
            "Channel overrides",
            "Member overrides",
            "If a Role is passed, then it checks the permissions\nsomeone with that role would have, which is essentially:",
            "The default role permissions",
            "The permissions of the role used as a parameter",
            "The default role permission overwrites",
            "The permission overwrites of the role used as a parameter",
            "Changed in version 2.0: The object passed in can now be a role object.",
            "obj (Union[Member, Role]) – The object to resolve permissions for. This could be either\na member or a role. If it’s a role then member overwrites\nare not computed.",
            "The resolved permissions for the member or role.",
            "Permissions",
            "Whether the permissions for this channel are synced with the\ncategory it belongs to.",
            "If there is no category then this is False.",
            "New in version 1.3.",
            "This function is a coroutine.",
            "Sets the channel specific permission overwrites for a target in the\nchannel.",
            "The target parameter should either be a Member or a\nRole that belongs to guild.",
            "The overwrite parameter, if given, must either be None or\nPermissionOverwrite. For convenience, you can pass in\nkeyword arguments denoting Permissions attributes. If this is\ndone, then you cannot mix the keyword arguments with the overwrite\nparameter.",
            "If the overwrite parameter is None, then the permission\noverwrites are deleted.",
            "You must have the manage_roles permission to use this.",
            "Note",
            "This method replaces the old overwrites with the ones given.",
            "Examples",
            "Setting allow and deny:",
            "Deleting overwrites",
            "Using PermissionOverwrite",
            "target (Union[Member, Role]) – The member or role to overwrite permissions for.",
            "overwrite (Optional[PermissionOverwrite]) – The permissions to allow and deny to the target, or None to\ndelete the overwrite.",
            "**permissions – A keyword argument list of permissions to set for ease of use.\nCannot be mixed with overwrite.",
            "reason (Optional[str]) – The reason for doing this action. Shows up on the audit log.",
            "Forbidden – You do not have permissions to edit channel specific permissions.",
            "HTTPException – Editing channel specific permissions failed.",
            "NotFound – The role or member being edited is not part of the guild.",
            "InvalidArgument – The overwrite parameter invalid or the target type was not\n    Role or Member.",
            "Represents a Discord direct message channel.",
            "Checks if two channels are equal.",
            "Checks if two channels are not equal.",
            "Returns the channel’s hash.",
            "Returns a string representation of the channel",
            "The user you are participating with in the direct message channel.\nIf this channel is received through the gateway, the recipient information\nmay not be always available.",
            "Optional[User]",
            "The user presenting yourself.",
            "ClientUser",
            "The direct message channel ID.",
            "int",
            "me (ClientUser) –",
            "state (ConnectionState) –",
            "data (DMChannelPayload) –",
            "Returns an AsyncIterator that enables receiving the destination’s message history.",
            "You must have read_message_history permissions to use this.",
            "limit (Optional[int]) – The number of messages to retrieve.\nIf None, retrieves every message in the channel. Note, however,\nthat this would make it a slow operation.",
            "before (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages before this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages after this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "around (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages around this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.\nWhen using this argument, the maximum limit is 101. Note that if the limit is an\neven number, then this will return at most limit + 1 messages.",
            "oldest_first (Optional[bool]) – If set to True, return messages in oldest->newest order. Defaults to True if\nafter is specified, otherwise False.",
            "Message – The message with the message data parsed.",
            "Forbidden – You do not have permissions to get channel message history.",
            "HTTPException – The request to get message history failed.",
            "HistoryIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "All parameters are optional.",
            "Returns a context manager that allows you to type for an indefinite period of time.",
            "This is useful for denoting long computations in your bot.\n:rtype: Typing",
            "Note",
            "This is both a regular context manager and an async context manager.\nThis means that both with and async with work with this.",
            "Example Usage:",
            "The channel’s Discord type.",
            "Returns a URL that allows the client to jump to the channel.",
            "New in version 2.0.",
            "Returns the direct message channel’s creation time in UTC.",
            "Handles permission resolution for a User.",
            "This function is there for compatibility with other channel types.",
            "Actual direct messages do not really have the concept of permissions.",
            "This returns all the Text related permissions set to True except:",
            "send_tts_messages: You cannot send TTS messages in a DM.",
            "manage_messages: You cannot delete others messages in a DM.",
            "obj (User) – The user to check permissions for. This parameter is ignored\nbut kept for compatibility with other permissions_for methods.",
            "The resolved permissions.",
            "Permissions",
            "Creates a PartialMessage from the message ID.",
            "This is useful if you want to work with a message and only have its ID without\ndoing an unnecessary API call.",
            "New in version 1.6.",
            "message_id (int) – The message ID to create a partial message for.",
            "The partial message.",
            "PartialMessage",
            "Returns a bool indicating whether you have the permissions to send the object(s).",
            "Indicates whether you have the permissions to send the object(s).",
            "bool",
            "TypeError – An invalid type has been passed.",
            "This function is a coroutine.",
            "Retrieves a single Message from the destination.",
            "id (int) – The message ID to look for.",
            "The message asked for.",
            "Message",
            "NotFound – The specified message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "This function is a coroutine.",
            "Retrieves all messages that are currently pinned in the channel.",
            "Note",
            "Due to a limitation with the Discord API, the Message\nobjects returned by this method do not contain complete\nMessage.reactions data.",
            "The messages that are currently pinned.",
            "List[Message]",
            "HTTPException – Retrieving the pinned messages failed.",
            "This function is a coroutine.",
            "Sends a message to the destination with the content given.",
            "The content must be a type that can convert to a string through str(content).\nIf the content is set to None (the default), then the embed parameter must\nbe provided.",
            "To upload a single file, the file parameter should be used with a\nsingle File object. To upload multiple files, the files\nparameter should be used with a list of File objects.\nSpecifying both parameters will lead to an exception.",
            "To upload a single embed, the embed parameter should be used with a\nsingle Embed object. To upload multiple embeds, the embeds\nparameter should be used with a list of Embed objects.\nSpecifying both parameters will lead to an exception.",
            "content (Optional[str]) – The content of the message to send.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "embed (Embed) – The rich embed for the content.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "nonce (Union[str, int]) – The nonce to use for sending this message. If the message was successfully sent,\nthen the message will have a nonce with this value.",
            "enforce_nonce (Optional[bool]) – Whether nonce is enforced to be validated.\n\nNew in version 2.5.",
            "Whether nonce is enforced to be validated.",
            "New in version 2.5.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent. If the deletion fails,\nthen it is silently ignored.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "New in version 1.4.",
            "reference (Union[Message, MessageReference, PartialMessage]) – A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.\n\nNew in version 1.6.",
            "A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.",
            "New in version 1.6.",
            "mention_author (Optional[bool]) – If set, overrides the replied_user attribute of allowed_mentions.\n\nNew in version 1.6.",
            "If set, overrides the replied_user attribute of allowed_mentions.",
            "New in version 1.6.",
            "view (discord.ui.View) – A Discord UI View to add to the message.",
            "embeds (List[Embed]) – A list of embeds to upload. Must be a maximum of 10.\n\nNew in version 2.0.",
            "A list of embeds to upload. Must be a maximum of 10.",
            "New in version 2.0.",
            "stickers (Sequence[Union[GuildSticker, StickerItem]]) – A list of stickers to upload. Must be a maximum of 3.\n\nNew in version 2.0.",
            "A list of stickers to upload. Must be a maximum of 3.",
            "New in version 2.0.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "silent (bool) – Whether to suppress push and desktop notifications for the message.\n\nNew in version 2.4.",
            "Whether to suppress push and desktop notifications for the message.",
            "New in version 2.4.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size,\n    you specified both file and files,\n    or you specified both embed and embeds,\n    or the reference object is not a Message,\n    MessageReference or PartialMessage.",
            "This function is a coroutine.",
            "Triggers a typing indicator to the destination.",
            "Typing indicator will go away after 10 seconds, or after a message is sent.",
            "None",
            "Represents a Discord group channel.",
            "Checks if two channels are equal.",
            "Checks if two channels are not equal.",
            "Returns the channel’s hash.",
            "Returns a string representation of the channel",
            "The users you are participating with in the group channel.",
            "List[User]",
            "The user presenting yourself.",
            "ClientUser",
            "The group channel ID.",
            "int",
            "The user that owns the group channel.",
            "Optional[User]",
            "The owner ID that owns the group channel.",
            "New in version 2.0.",
            "int",
            "The group channel’s name if provided.",
            "Optional[str]",
            "me (ClientUser) –",
            "state (ConnectionState) –",
            "data (GroupChannelPayload) –",
            "Returns an AsyncIterator that enables receiving the destination’s message history.",
            "You must have read_message_history permissions to use this.",
            "limit (Optional[int]) – The number of messages to retrieve.\nIf None, retrieves every message in the channel. Note, however,\nthat this would make it a slow operation.",
            "before (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages before this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages after this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "around (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages around this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.\nWhen using this argument, the maximum limit is 101. Note that if the limit is an\neven number, then this will return at most limit + 1 messages.",
            "oldest_first (Optional[bool]) – If set to True, return messages in oldest->newest order. Defaults to True if\nafter is specified, otherwise False.",
            "Message – The message with the message data parsed.",
            "Forbidden – You do not have permissions to get channel message history.",
            "HTTPException – The request to get message history failed.",
            "HistoryIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "All parameters are optional.",
            "Returns a context manager that allows you to type for an indefinite period of time.",
            "This is useful for denoting long computations in your bot.\n:rtype: Typing",
            "Note",
            "This is both a regular context manager and an async context manager.\nThis means that both with and async with work with this.",
            "Example Usage:",
            "The channel’s Discord type.",
            "Returns the channel’s icon asset if available.",
            "Returns the channel’s creation time in UTC.",
            "Returns a URL that allows the client to jump to the channel.",
            "New in version 2.0.",
            "Handles permission resolution for a User.",
            "This function is there for compatibility with other channel types.",
            "Actual direct messages do not really have the concept of permissions.",
            "This returns all the Text related permissions set to True except:",
            "send_tts_messages: You cannot send TTS messages in a DM.",
            "manage_messages: You cannot delete others messages in a DM.",
            "This also checks the kick_members permission if the user is the owner.",
            "obj (Snowflake) – The user to check permissions for.",
            "The resolved permissions for the user.",
            "Permissions",
            "Returns a bool indicating whether you have the permissions to send the object(s).",
            "Indicates whether you have the permissions to send the object(s).",
            "bool",
            "TypeError – An invalid type has been passed.",
            "This function is a coroutine.",
            "Retrieves a single Message from the destination.",
            "id (int) – The message ID to look for.",
            "The message asked for.",
            "Message",
            "NotFound – The specified message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "This function is a coroutine.",
            "Leave the group.",
            "If you are the only one in the group, this deletes it as well.",
            "HTTPException – Leaving the group failed.",
            "None",
            "This function is a coroutine.",
            "Retrieves all messages that are currently pinned in the channel.",
            "Note",
            "Due to a limitation with the Discord API, the Message\nobjects returned by this method do not contain complete\nMessage.reactions data.",
            "The messages that are currently pinned.",
            "List[Message]",
            "HTTPException – Retrieving the pinned messages failed.",
            "This function is a coroutine.",
            "Sends a message to the destination with the content given.",
            "The content must be a type that can convert to a string through str(content).\nIf the content is set to None (the default), then the embed parameter must\nbe provided.",
            "To upload a single file, the file parameter should be used with a\nsingle File object. To upload multiple files, the files\nparameter should be used with a list of File objects.\nSpecifying both parameters will lead to an exception.",
            "To upload a single embed, the embed parameter should be used with a\nsingle Embed object. To upload multiple embeds, the embeds\nparameter should be used with a list of Embed objects.\nSpecifying both parameters will lead to an exception.",
            "content (Optional[str]) – The content of the message to send.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "embed (Embed) – The rich embed for the content.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "nonce (Union[str, int]) – The nonce to use for sending this message. If the message was successfully sent,\nthen the message will have a nonce with this value.",
            "enforce_nonce (Optional[bool]) – Whether nonce is enforced to be validated.\n\nNew in version 2.5.",
            "Whether nonce is enforced to be validated.",
            "New in version 2.5.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent. If the deletion fails,\nthen it is silently ignored.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "New in version 1.4.",
            "reference (Union[Message, MessageReference, PartialMessage]) – A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.\n\nNew in version 1.6.",
            "A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.",
            "New in version 1.6.",
            "mention_author (Optional[bool]) – If set, overrides the replied_user attribute of allowed_mentions.\n\nNew in version 1.6.",
            "If set, overrides the replied_user attribute of allowed_mentions.",
            "New in version 1.6.",
            "view (discord.ui.View) – A Discord UI View to add to the message.",
            "embeds (List[Embed]) – A list of embeds to upload. Must be a maximum of 10.\n\nNew in version 2.0.",
            "A list of embeds to upload. Must be a maximum of 10.",
            "New in version 2.0.",
            "stickers (Sequence[Union[GuildSticker, StickerItem]]) – A list of stickers to upload. Must be a maximum of 3.\n\nNew in version 2.0.",
            "A list of stickers to upload. Must be a maximum of 3.",
            "New in version 2.0.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "silent (bool) – Whether to suppress push and desktop notifications for the message.\n\nNew in version 2.4.",
            "Whether to suppress push and desktop notifications for the message.",
            "New in version 2.4.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size,\n    you specified both file and files,\n    or you specified both embed and embeds,\n    or the reference object is not a Message,\n    MessageReference or PartialMessage.",
            "This function is a coroutine.",
            "Triggers a typing indicator to the destination.",
            "Typing indicator will go away after 10 seconds, or after a message is sent.",
            "None"
        ],
        "code": [
            "str",
            "Guild",
            "int",
            "int",
            "None",
            "str",
            "None",
            "int",
            "int",
            "manage_channels",
            "manage_messages",
            "int",
            "is_nsfw()",
            "bool",
            "int",
            "ChannelFlags",
            "int",
            "AsyncIterator",
            "read_message_history",
            "int",
            "None",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "bool",
            "True",
            "True",
            "after",
            "False",
            "Message",
            "counter = 0\nasync for message in channel.history(limit=200):\n    if message.author == client.user:\n        counter += 1",
            "messages = await channel.history(limit=123).flatten()\n# messages is now a list of Message...",
            "Typing",
            "with",
            "async with",
            "async with channel.typing():\n    # simulate something heavy\n    await asyncio.sleep(10)\n\nawait channel.send('done!')",
            "bool",
            "is_news()",
            "manage_channels",
            "overwrites",
            "type",
            "str",
            "str",
            "int",
            "bool",
            "bool",
            "False",
            "CategoryChannel",
            "None",
            "int",
            "ChannelType",
            "ChannelType.text",
            "ChannelType.news",
            "NEWS",
            "Guild.features",
            "str",
            "Role",
            "Member",
            "Snowflake",
            "PermissionOverwrite",
            "int",
            "60",
            "1440",
            "4320",
            "10080",
            "int",
            "None",
            "TextChannel",
            "create_public_threads",
            "create_private_threads",
            "str",
            "abc.Snowflake",
            "None",
            "None",
            "int",
            "ChannelType",
            "message",
            "None",
            "int",
            "0",
            "21600",
            "bool",
            "str",
            "Thread",
            "AsyncIterator",
            "read_message_history",
            "manage_threads",
            "bool",
            "None",
            "abc.Snowflake",
            "datetime.datetime",
            "bool",
            "bool",
            "joined",
            "True",
            "private",
            "False",
            "Thread",
            "bool",
            "bool",
            "None",
            "roles",
            "manage_channels",
            "str",
            "str",
            "abc.GuildChannel",
            "create_instant_invite",
            "int",
            "0",
            "int",
            "0",
            "bool",
            "False",
            "bool",
            "False",
            "str",
            "InviteTarget",
            "User",
            "int",
            "ScheduledEvent",
            "Invite.set_scheduled_event()",
            "Invite.set_scheduled_event()",
            "Invite",
            "manage_webhooks",
            "reason",
            "str",
            "bytes",
            "edit()",
            "str",
            "Webhook",
            "manage_channels",
            "str",
            "Message.delete()",
            "manage_messages",
            "abc.Snowflake",
            "str",
            "Message",
            "int",
            "Message",
            "TextChannel",
            "str",
            "Webhook",
            "PartialMessage",
            "int",
            "PartialMessage",
            "int",
            "None",
            "Thread",
            "manage_channels",
            "Invite",
            "bool",
            "history()",
            "fetch_message()",
            "last_message_id",
            "None",
            "Message",
            "edit",
            "manage_channels",
            "bool",
            "end",
            "before",
            "after",
            "bool",
            "beginning",
            "before",
            "after",
            "Snowflake",
            "beginning",
            "end",
            "after",
            "Snowflake",
            "beginning",
            "end",
            "before",
            "int",
            "2",
            "beginning=True",
            "beginning",
            "end",
            "before",
            "after",
            "Snowflake",
            "None",
            "bool",
            "str",
            "None",
            "Role",
            "Member",
            "PermissionOverwrite",
            "Role",
            "Member",
            "PermissionOverwrite",
            "Role",
            "User",
            "PermissionOverwrite",
            "Member",
            "Role",
            "Role",
            "Member",
            "Role",
            "Permissions",
            "False",
            "Message",
            "Message.reactions",
            "Message",
            "check",
            "check",
            "manage_messages",
            "read_message_history",
            "int",
            "Message",
            "bool",
            "Message",
            "abc.Snowflake",
            "datetime.datetime",
            "before",
            "history()",
            "abc.Snowflake",
            "datetime.datetime",
            "after",
            "history()",
            "abc.Snowflake",
            "datetime.datetime",
            "around",
            "history()",
            "bool",
            "oldest_first",
            "history()",
            "bool",
            "True",
            "False",
            "Permissions.manage_messages",
            "True",
            "str",
            "Message",
            "def is_me(m):\n    return m.author == client.user\n\ndeleted = await channel.purge(limit=100, check=is_me)\nawait channel.send(f'Deleted {len(deleted)} message(s)')",
            "str(content)",
            "None",
            "embed",
            "file",
            "File",
            "files",
            "list",
            "File",
            "embed",
            "Embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "Embed",
            "File",
            "File",
            "str",
            "int",
            "bool",
            "nonce",
            "float",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "Message",
            "MessageReference",
            "PartialMessage",
            "Message",
            "to_reference()",
            "Message",
            "replied_user",
            "allowed_mentions",
            "mention_author",
            "bool",
            "replied_user",
            "allowed_mentions",
            "discord.ui.View",
            "Embed",
            "GuildSticker",
            "StickerItem",
            "bool",
            "bool",
            "Poll",
            "Message",
            "files",
            "file",
            "files",
            "embed",
            "embeds",
            "reference",
            "Message",
            "MessageReference",
            "PartialMessage",
            "target",
            "Member",
            "Role",
            "overwrite",
            "None",
            "PermissionOverwrite",
            "Permissions",
            "overwrite",
            "overwrite",
            "None",
            "manage_roles",
            "await message.channel.set_permissions(message.author, read_messages=True,\n                                                      send_messages=False)",
            "await channel.set_permissions(member, overwrite=None)",
            "PermissionOverwrite",
            "overwrite = discord.PermissionOverwrite()\noverwrite.send_messages = False\noverwrite.read_messages = True\nawait channel.set_permissions(member, overwrite=overwrite)",
            "Member",
            "Role",
            "PermissionOverwrite",
            "None",
            "overwrite",
            "str",
            "Role",
            "Member",
            "None",
            "manage_webhooks",
            "Webhook",
            "str",
            "Guild",
            "int",
            "int",
            "None",
            "guidelines",
            "str",
            "None",
            "int",
            "int",
            "manage_channels",
            "manage_messages",
            "int",
            "is_nsfw()",
            "bool",
            "int",
            "ChannelFlags",
            "ForumTag",
            "SortOrder",
            "int",
            "str",
            "discord.Emoji",
            "topic",
            "applied_tags",
            "ForumTag",
            "manage_channels",
            "str",
            "str",
            "int",
            "bool",
            "bool",
            "False",
            "CategoryChannel",
            "None",
            "int",
            "str",
            "Role",
            "Member",
            "Snowflake",
            "PermissionOverwrite",
            "int",
            "60",
            "1440",
            "4320",
            "10080",
            "int",
            "SortOrder",
            "discord.Emoji",
            "int",
            "str",
            "Emoji",
            "ForumTag",
            "bool",
            "None",
            "ForumChannel",
            "create_public_threads",
            "create_private_threads",
            "str",
            "str",
            "Embed",
            "Embed",
            "File",
            "File",
            "GuildSticker",
            "StickerItem",
            "int",
            "str",
            "int",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "discord.ui.View",
            "discord.ForumTag",
            "int",
            "int",
            "manage_channels",
            "manage_messages",
            "str",
            "Thread",
            "AsyncIterator",
            "read_message_history",
            "manage_threads",
            "bool",
            "None",
            "abc.Snowflake",
            "datetime.datetime",
            "bool",
            "bool",
            "joined",
            "True",
            "private",
            "False",
            "Thread",
            "None",
            "roles",
            "manage_channels",
            "str",
            "str",
            "abc.GuildChannel",
            "create_instant_invite",
            "int",
            "0",
            "int",
            "0",
            "bool",
            "False",
            "bool",
            "False",
            "str",
            "InviteTarget",
            "User",
            "int",
            "ScheduledEvent",
            "Invite.set_scheduled_event()",
            "Invite.set_scheduled_event()",
            "Invite",
            "manage_webhooks",
            "reason",
            "str",
            "bytes",
            "edit()",
            "str",
            "Webhook",
            "manage_channels",
            "str",
            "Message.delete()",
            "manage_messages",
            "abc.Snowflake",
            "str",
            "TextChannel",
            "str",
            "Webhook",
            "PartialMessage",
            "int",
            "PartialMessage",
            "int",
            "None",
            "Thread",
            "manage_channels",
            "Invite",
            "bool",
            "history()",
            "fetch_message()",
            "last_message_id",
            "None",
            "Message",
            "edit",
            "manage_channels",
            "bool",
            "end",
            "before",
            "after",
            "bool",
            "beginning",
            "before",
            "after",
            "Snowflake",
            "beginning",
            "end",
            "after",
            "Snowflake",
            "beginning",
            "end",
            "before",
            "int",
            "2",
            "beginning=True",
            "beginning",
            "end",
            "before",
            "after",
            "Snowflake",
            "None",
            "bool",
            "str",
            "None",
            "Role",
            "Member",
            "PermissionOverwrite",
            "Role",
            "Member",
            "PermissionOverwrite",
            "Role",
            "User",
            "PermissionOverwrite",
            "Member",
            "Role",
            "Role",
            "Member",
            "Role",
            "Permissions",
            "False",
            "check",
            "check",
            "manage_messages",
            "read_message_history",
            "int",
            "Message",
            "bool",
            "Message",
            "abc.Snowflake",
            "datetime.datetime",
            "before",
            "history()",
            "abc.Snowflake",
            "datetime.datetime",
            "after",
            "history()",
            "abc.Snowflake",
            "datetime.datetime",
            "around",
            "history()",
            "bool",
            "oldest_first",
            "history()",
            "bool",
            "True",
            "False",
            "Permissions.manage_messages",
            "True",
            "str",
            "Message",
            "def is_me(m):\n    return m.author == client.user\n\ndeleted = await channel.purge(limit=100, check=is_me)\nawait channel.send(f'Deleted {len(deleted)} message(s)')",
            "target",
            "Member",
            "Role",
            "overwrite",
            "None",
            "PermissionOverwrite",
            "Permissions",
            "overwrite",
            "overwrite",
            "None",
            "manage_roles",
            "await message.channel.set_permissions(message.author, read_messages=True,\n                                                      send_messages=False)",
            "await channel.set_permissions(member, overwrite=None)",
            "PermissionOverwrite",
            "overwrite = discord.PermissionOverwrite()\noverwrite.send_messages = False\noverwrite.read_messages = True\nawait channel.set_permissions(member, overwrite=overwrite)",
            "Member",
            "Role",
            "PermissionOverwrite",
            "None",
            "overwrite",
            "str",
            "Role",
            "Member",
            "manage_webhooks",
            "Webhook",
            "str",
            "Guild",
            "int",
            "int",
            "None",
            "int",
            "int",
            "int",
            "None",
            "VoiceRegion",
            "VideoQualityMode",
            "int",
            "manage_channels",
            "manage_messages",
            "int",
            "str",
            "ChannelFlags",
            "bool",
            "history()",
            "fetch_message()",
            "last_message_id",
            "None",
            "Message",
            "PartialMessage",
            "int",
            "PartialMessage",
            "Message.delete()",
            "manage_messages",
            "abc.Snowflake",
            "str",
            "check",
            "check",
            "manage_messages",
            "read_message_history",
            "int",
            "Message",
            "bool",
            "Message",
            "abc.Snowflake",
            "datetime.datetime",
            "before",
            "history()",
            "abc.Snowflake",
            "datetime.datetime",
            "after",
            "history()",
            "abc.Snowflake",
            "datetime.datetime",
            "around",
            "history()",
            "bool",
            "oldest_first",
            "history()",
            "bool",
            "True",
            "False",
            "Permissions.manage_messages",
            "True",
            "str",
            "Message",
            "def is_me(m):\n    return m.author == client.user\n\ndeleted = await channel.purge(limit=100, check=is_me)\nawait channel.send(f'Deleted {len(deleted)} message(s)')",
            "manage_webhooks",
            "Webhook",
            "manage_webhooks",
            "reason",
            "str",
            "bytes",
            "edit()",
            "str",
            "Webhook",
            "manage_channels",
            "str",
            "str",
            "abc.GuildChannel",
            "manage_channels",
            "overwrites",
            "str",
            "int",
            "int",
            "int",
            "bool",
            "False",
            "CategoryChannel",
            "None",
            "str",
            "Role",
            "Member",
            "Snowflake",
            "PermissionOverwrite",
            "VoiceRegion",
            "None",
            "VideoQualityMode",
            "None",
            "VoiceChannel",
            "start_embedded_activities",
            "discord.EmbeddedActivity",
            "int",
            "int",
            "0",
            "int",
            "0",
            "bool",
            "False",
            "bool",
            "False",
            "str",
            "Invite",
            "set_voice_channel_status",
            "str",
            "str",
            "bool",
            "bool",
            "None",
            "roles",
            "VoiceClient",
            "Intents.voice_states",
            "float",
            "bool",
            "VoiceProtocol",
            "VoiceProtocol",
            "VoiceClient",
            "VoiceProtocol",
            "create_instant_invite",
            "int",
            "0",
            "int",
            "0",
            "bool",
            "False",
            "bool",
            "False",
            "str",
            "InviteTarget",
            "User",
            "int",
            "ScheduledEvent",
            "Invite.set_scheduled_event()",
            "Invite.set_scheduled_event()",
            "Invite",
            "manage_channels",
            "str",
            "Message",
            "int",
            "Message",
            "AsyncIterator",
            "read_message_history",
            "int",
            "None",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "bool",
            "True",
            "True",
            "after",
            "False",
            "Message",
            "counter = 0\nasync for message in channel.history(limit=200):\n    if message.author == client.user:\n        counter += 1",
            "messages = await channel.history(limit=123).flatten()\n# messages is now a list of Message...",
            "manage_channels",
            "Invite",
            "edit",
            "manage_channels",
            "bool",
            "end",
            "before",
            "after",
            "bool",
            "beginning",
            "before",
            "after",
            "Snowflake",
            "beginning",
            "end",
            "after",
            "Snowflake",
            "beginning",
            "end",
            "before",
            "int",
            "2",
            "beginning=True",
            "beginning",
            "end",
            "before",
            "after",
            "Snowflake",
            "None",
            "bool",
            "str",
            "None",
            "Role",
            "Member",
            "PermissionOverwrite",
            "Role",
            "Member",
            "PermissionOverwrite",
            "Role",
            "User",
            "PermissionOverwrite",
            "Member",
            "Role",
            "Role",
            "Member",
            "Role",
            "Permissions",
            "False",
            "Message",
            "Message.reactions",
            "Message",
            "str(content)",
            "None",
            "embed",
            "file",
            "File",
            "files",
            "list",
            "File",
            "embed",
            "Embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "Embed",
            "File",
            "File",
            "str",
            "int",
            "bool",
            "nonce",
            "float",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "Message",
            "MessageReference",
            "PartialMessage",
            "Message",
            "to_reference()",
            "Message",
            "replied_user",
            "allowed_mentions",
            "mention_author",
            "bool",
            "replied_user",
            "allowed_mentions",
            "discord.ui.View",
            "Embed",
            "GuildSticker",
            "StickerItem",
            "bool",
            "bool",
            "Poll",
            "Message",
            "files",
            "file",
            "files",
            "embed",
            "embeds",
            "reference",
            "Message",
            "MessageReference",
            "PartialMessage",
            "target",
            "Member",
            "Role",
            "overwrite",
            "None",
            "PermissionOverwrite",
            "Permissions",
            "overwrite",
            "overwrite",
            "None",
            "manage_roles",
            "await message.channel.set_permissions(message.author, read_messages=True,\n                                                      send_messages=False)",
            "await channel.set_permissions(member, overwrite=None)",
            "PermissionOverwrite",
            "overwrite = discord.PermissionOverwrite()\noverwrite.send_messages = False\noverwrite.read_messages = True\nawait channel.set_permissions(member, overwrite=overwrite)",
            "Member",
            "Role",
            "PermissionOverwrite",
            "None",
            "overwrite",
            "str",
            "Role",
            "Member",
            "None",
            "Typing",
            "with",
            "async with",
            "async with channel.typing():\n    # simulate something heavy\n    await asyncio.sleep(10)\n\nawait channel.send('done!')",
            "members",
            "int",
            "VoiceState",
            "str",
            "Guild",
            "int",
            "None",
            "int",
            "is_nsfw()",
            "bool",
            "ChannelFlags",
            "bool",
            "manage_channels",
            "str",
            "str",
            "abc.GuildChannel",
            "manage_channels",
            "overwrites",
            "str",
            "int",
            "bool",
            "str",
            "Role",
            "Member",
            "Snowflake",
            "PermissionOverwrite",
            "None",
            "CategoryChannel",
            "edit",
            "manage_channels",
            "bool",
            "end",
            "before",
            "after",
            "bool",
            "beginning",
            "before",
            "after",
            "Snowflake",
            "beginning",
            "end",
            "after",
            "Snowflake",
            "beginning",
            "end",
            "before",
            "int",
            "2",
            "beginning=True",
            "beginning",
            "end",
            "before",
            "after",
            "Snowflake",
            "None",
            "bool",
            "str",
            "Guild.create_text_channel()",
            "TextChannel",
            "TextChannel",
            "str",
            "Any",
            "Guild.create_voice_channel()",
            "VoiceChannel",
            "VoiceChannel",
            "str",
            "Any",
            "Guild.create_stage_channel()",
            "StageChannel",
            "StageChannel",
            "str",
            "Any",
            "Guild.create_forum_channel()",
            "ForumChannel",
            "ForumChannel",
            "str",
            "Any",
            "None",
            "roles",
            "create_instant_invite",
            "int",
            "0",
            "int",
            "0",
            "bool",
            "False",
            "bool",
            "False",
            "str",
            "InviteTarget",
            "User",
            "int",
            "ScheduledEvent",
            "Invite.set_scheduled_event()",
            "Invite.set_scheduled_event()",
            "Invite",
            "manage_channels",
            "str",
            "manage_channels",
            "Invite",
            "Role",
            "Member",
            "PermissionOverwrite",
            "Role",
            "Member",
            "PermissionOverwrite",
            "Role",
            "User",
            "PermissionOverwrite",
            "Member",
            "Role",
            "Role",
            "Member",
            "Role",
            "Permissions",
            "False",
            "target",
            "Member",
            "Role",
            "overwrite",
            "None",
            "PermissionOverwrite",
            "Permissions",
            "overwrite",
            "overwrite",
            "None",
            "manage_roles",
            "await message.channel.set_permissions(message.author, read_messages=True,\n                                                      send_messages=False)",
            "await channel.set_permissions(member, overwrite=None)",
            "PermissionOverwrite",
            "overwrite = discord.PermissionOverwrite()\noverwrite.send_messages = False\noverwrite.read_messages = True\nawait channel.set_permissions(member, overwrite=overwrite)",
            "Member",
            "Role",
            "PermissionOverwrite",
            "None",
            "overwrite",
            "str",
            "Role",
            "Member",
            "User",
            "ClientUser",
            "int",
            "AsyncIterator",
            "read_message_history",
            "int",
            "None",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "bool",
            "True",
            "True",
            "after",
            "False",
            "Message",
            "counter = 0\nasync for message in channel.history(limit=200):\n    if message.author == client.user:\n        counter += 1",
            "messages = await channel.history(limit=123).flatten()\n# messages is now a list of Message...",
            "Typing",
            "with",
            "async with",
            "async with channel.typing():\n    # simulate something heavy\n    await asyncio.sleep(10)\n\nawait channel.send('done!')",
            "User",
            "True",
            "send_tts_messages",
            "manage_messages",
            "User",
            "permissions_for",
            "Permissions",
            "PartialMessage",
            "int",
            "PartialMessage",
            "bool",
            "bool",
            "Message",
            "int",
            "Message",
            "Message",
            "Message.reactions",
            "Message",
            "str(content)",
            "None",
            "embed",
            "file",
            "File",
            "files",
            "list",
            "File",
            "embed",
            "Embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "Embed",
            "File",
            "File",
            "str",
            "int",
            "bool",
            "nonce",
            "float",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "Message",
            "MessageReference",
            "PartialMessage",
            "Message",
            "to_reference()",
            "Message",
            "replied_user",
            "allowed_mentions",
            "mention_author",
            "bool",
            "replied_user",
            "allowed_mentions",
            "discord.ui.View",
            "Embed",
            "GuildSticker",
            "StickerItem",
            "bool",
            "bool",
            "Poll",
            "Message",
            "files",
            "file",
            "files",
            "embed",
            "embeds",
            "reference",
            "Message",
            "MessageReference",
            "PartialMessage",
            "None",
            "User",
            "ClientUser",
            "int",
            "User",
            "int",
            "str",
            "AsyncIterator",
            "read_message_history",
            "int",
            "None",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "bool",
            "True",
            "True",
            "after",
            "False",
            "Message",
            "counter = 0\nasync for message in channel.history(limit=200):\n    if message.author == client.user:\n        counter += 1",
            "messages = await channel.history(limit=123).flatten()\n# messages is now a list of Message...",
            "Typing",
            "with",
            "async with",
            "async with channel.typing():\n    # simulate something heavy\n    await asyncio.sleep(10)\n\nawait channel.send('done!')",
            "User",
            "True",
            "send_tts_messages",
            "manage_messages",
            "Snowflake",
            "Permissions",
            "bool",
            "bool",
            "Message",
            "int",
            "Message",
            "None",
            "Message",
            "Message.reactions",
            "Message",
            "str(content)",
            "None",
            "embed",
            "file",
            "File",
            "files",
            "list",
            "File",
            "embed",
            "Embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "Embed",
            "File",
            "File",
            "str",
            "int",
            "bool",
            "nonce",
            "float",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "Message",
            "MessageReference",
            "PartialMessage",
            "Message",
            "to_reference()",
            "Message",
            "replied_user",
            "allowed_mentions",
            "mention_author",
            "bool",
            "replied_user",
            "allowed_mentions",
            "discord.ui.View",
            "Embed",
            "GuildSticker",
            "StickerItem",
            "bool",
            "bool",
            "Poll",
            "Message",
            "files",
            "file",
            "files",
            "embed",
            "embeds",
            "reference",
            "Message",
            "MessageReference",
            "PartialMessage",
            "None"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Stickers#",
        "content": [
            "Represents a sticker.",
            "New in version 1.6.",
            "Returns the name of the sticker.",
            "Checks if the sticker is equal to another sticker.",
            "Checks if the sticker is not equal to another sticker.",
            "The sticker’s name.",
            "str",
            "The id of the sticker.",
            "int",
            "The description of the sticker.",
            "str",
            "The id of the sticker’s pack.",
            "int",
            "The format for the sticker’s image.",
            "StickerFormatType",
            "The URL for the sticker’s image.",
            "str",
            "state (ConnectionState) –",
            "data (Union[BaseSticker, StandardSticker, GuildSticker]) –",
            "Returns the sticker’s creation time in UTC.",
            "Represents a sticker pack.",
            "New in version 2.0.",
            "Returns the name of the sticker pack.",
            "Checks if the sticker pack is equal to another sticker pack.",
            "Checks if the sticker pack is not equal to another sticker pack.",
            "The name of the sticker pack.",
            "str",
            "The description of the sticker pack.",
            "str",
            "The id of the sticker pack.",
            "int",
            "The stickers of this sticker pack.",
            "List[StandardSticker]",
            "The SKU ID of the sticker pack.",
            "int",
            "The ID of the sticker used for the cover of the sticker pack.",
            "int",
            "The sticker used for the cover of the sticker pack.",
            "StandardSticker",
            "state (ConnectionState) –",
            "data (StickerPack) –",
            "The banner asset of the sticker pack.",
            "Represents a sticker item.",
            "New in version 2.0.",
            "Returns the name of the sticker item.",
            "Checks if the sticker item is equal to another sticker item.",
            "Checks if the sticker item is not equal to another sticker item.",
            "The sticker’s name.",
            "str",
            "The id of the sticker.",
            "int",
            "The format for the sticker’s image.",
            "StickerFormatType",
            "The URL for the sticker’s image.",
            "str",
            "state (ConnectionState) –",
            "data (StickerItem) –",
            "This function is a coroutine.",
            "Attempts to retrieve the full sticker data of the sticker item.",
            "The retrieved sticker.",
            "Union[StandardSticker, GuildSticker]",
            "HTTPException – Retrieving the sticker failed.",
            "Represents a sticker that is found in a standard sticker pack.",
            "New in version 2.0.",
            "Returns the name of the sticker.",
            "Checks if the sticker is equal to another sticker.",
            "Checks if the sticker is not equal to another sticker.",
            "The sticker’s name.",
            "str",
            "The id of the sticker.",
            "int",
            "The description of the sticker.",
            "str",
            "The id of the sticker’s pack.",
            "int",
            "The format for the sticker’s image.",
            "StickerFormatType",
            "A list of tags for the sticker.",
            "List[str]",
            "The sticker’s sort order within its pack.",
            "int",
            "state (ConnectionState) –",
            "data (Union[BaseSticker, StandardSticker, GuildSticker]) –",
            "This function is a coroutine.",
            "Retrieves the sticker pack that this sticker belongs to.",
            "The retrieved sticker pack.",
            "StickerPack",
            "InvalidData – The corresponding sticker pack was not found.",
            "HTTPException – Retrieving the sticker pack failed.",
            "Represents a sticker that belongs to a guild.",
            "New in version 2.0.",
            "Returns the name of the sticker.",
            "Checks if the sticker is equal to another sticker.",
            "Checks if the sticker is not equal to another sticker.",
            "The sticker’s name.",
            "str",
            "The id of the sticker.",
            "int",
            "The description of the sticker.",
            "str",
            "The format for the sticker’s image.",
            "StickerFormatType",
            "Whether this sticker is available for use.",
            "bool",
            "The ID of the guild that this sticker is from.",
            "int",
            "The user that created this sticker. This can only be retrieved using Guild.fetch_sticker() and\nhaving the manage_emojis_and_stickers permission.",
            "Optional[User]",
            "The name of a unicode emoji that represents this sticker.",
            "str",
            "state (ConnectionState) –",
            "data (Union[BaseSticker, StandardSticker, GuildSticker]) –",
            "The guild that this sticker is from.\nCould be None if the bot is not in the guild.",
            "New in version 2.0.",
            "This function is a coroutine.",
            "Edits a GuildSticker for the guild.",
            "name (str) – The sticker’s new name. Must be at least 2 characters.",
            "description (Optional[str]) – The sticker’s new description. Can be None.",
            "emoji (str) – The name of a unicode emoji that represents the sticker’s expression.",
            "reason (str) – The reason for editing this sticker. Shows up on the audit log.",
            "The newly modified sticker.",
            "GuildSticker",
            "Forbidden – You are not allowed to edit stickers.",
            "HTTPException – An error occurred editing the sticker.",
            "This function is a coroutine.",
            "Deletes the custom Sticker from the guild.",
            "You must have manage_emojis_and_stickers permission to\ndo this.",
            "reason (Optional[str]) – The reason for deleting this sticker. Shows up on the audit log.",
            "Forbidden – You are not allowed to delete stickers.",
            "HTTPException – An error occurred deleting the sticker.",
            "None"
        ],
        "code": [
            "str",
            "int",
            "str",
            "int",
            "StickerFormatType",
            "str",
            "ConnectionState",
            "Union",
            "BaseSticker",
            "StandardSticker",
            "GuildSticker",
            "str",
            "str",
            "int",
            "StandardSticker",
            "int",
            "int",
            "StandardSticker",
            "ConnectionState",
            "StickerPack",
            "str",
            "int",
            "StickerFormatType",
            "str",
            "ConnectionState",
            "StickerItem",
            "StandardSticker",
            "GuildSticker",
            "str",
            "int",
            "str",
            "int",
            "StickerFormatType",
            "str",
            "int",
            "ConnectionState",
            "Union",
            "BaseSticker",
            "StandardSticker",
            "GuildSticker",
            "StickerPack",
            "str",
            "int",
            "str",
            "StickerFormatType",
            "bool",
            "int",
            "Guild.fetch_sticker()",
            "manage_emojis_and_stickers",
            "User",
            "str",
            "ConnectionState",
            "Union",
            "BaseSticker",
            "StandardSticker",
            "GuildSticker",
            "None",
            "GuildSticker",
            "str",
            "str",
            "None",
            "str",
            "str",
            "GuildSticker",
            "Sticker",
            "manage_emojis_and_stickers",
            "str"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Events#",
        "content": [
            "Represents the payload for an on_auto_moderation_action_execution()",
            "New in version 2.0.",
            "The action that was executed.",
            "AutoModAction",
            "The ID of the rule that the action belongs to.",
            "int",
            "The category of trigger the rule belongs to.",
            "New in version 2.4.",
            "AutoModTriggerType",
            "The ID of the guild that the action was executed in.",
            "int",
            "The guild that the action was executed in, if cached.",
            "Optional[Guild]",
            "The ID of the user that triggered the action.",
            "int",
            "The member that triggered the action, if cached.",
            "Optional[Member]",
            "The ID of the channel in which the member’s content was posted.",
            "Optional[int]",
            "The channel in which the member’s content was posted, if cached.",
            "Optional[Union[TextChannel, Thread, VoiceChannel, StageChannel]]",
            "The ID of the message that triggered the action. This is only available if the\nmessage was not blocked.",
            "Optional[int]",
            "The message that triggered the action, if cached.",
            "Optional[Message]",
            "The ID of the system auto moderation message that was posted as a result\nof the action.",
            "Optional[int]",
            "The system auto moderation message that was posted as a result of the action,\nif cached.",
            "Optional[Message]",
            "The content of the message that triggered the action.",
            "str",
            "The word or phrase configured that was matched in the content.",
            "str",
            "The substring in the content that was matched.",
            "str",
            "The raw data sent by the gateway.",
            "New in version 2.5.",
            "dict",
            "state (ConnectionState) –",
            "data (AutoModActionExecutionEvent) –",
            "Represents the payload for a on_raw_typing() event.",
            "New in version 2.0.",
            "The channel ID where the typing originated from.",
            "int",
            "The ID of the user that started typing.",
            "int",
            "When the typing started as an aware datetime in UTC.",
            "datetime.datetime",
            "The guild ID where the typing originated from, if applicable.",
            "Optional[int]",
            "The member who started typing. Only available if the member started typing in a guild.",
            "Optional[Member]",
            "The raw data sent by the gateway.",
            "New in version 2.5.",
            "dict",
            "data (TypingEvent) –",
            "Represents the event payload for a on_raw_message_delete() event.",
            "The channel ID where the deletion took place.",
            "int",
            "The guild ID where the deletion took place, if applicable.",
            "Optional[int]",
            "The message ID that got deleted.",
            "int",
            "The cached message, if found in the internal message cache.",
            "Optional[Message]",
            "The raw data sent by the gateway.",
            "New in version 2.5.",
            "dict",
            "data (MessageDeleteEvent) –",
            "Represents the event payload for a on_raw_bulk_message_delete() event.",
            "A set of the message IDs that were deleted.",
            "Set[int]",
            "The channel ID where the message got deleted.",
            "int",
            "The guild ID where the message got deleted, if applicable.",
            "Optional[int]",
            "The cached messages, if found in the internal message cache.",
            "List[Message]",
            "The raw data sent by the gateway.",
            "New in version 2.5.",
            "dict",
            "data (BulkMessageDeleteEvent) –",
            "Represents the payload for a on_raw_message_edit() event.",
            "The message ID that got updated.",
            "int",
            "The channel ID where the update took place.",
            "New in version 1.3.",
            "int",
            "The guild ID where the message got updated, if applicable.",
            "New in version 1.7.",
            "Optional[int]",
            "The raw data sent by the gateway",
            "dict",
            "The cached message, if found in the internal message cache. Represents the message before\nit is modified by the data in RawMessageUpdateEvent.data.",
            "Optional[Message]",
            "data (MessageUpdateEvent) –",
            "Represents the payload for a on_raw_reaction_add() or\non_raw_reaction_remove() event.",
            "The message ID that got or lost a reaction.",
            "int",
            "The user ID who added the reaction or whose reaction was removed.",
            "int",
            "The channel ID where the reaction got added or removed.",
            "int",
            "The guild ID where the reaction got added or removed, if applicable.",
            "Optional[int]",
            "The custom or unicode emoji being used.",
            "PartialEmoji",
            "The member who added the reaction. Only available if the reaction occurs within a guild.",
            "New in version 1.3.",
            "Optional[Member]",
            "The event type that triggered this action. Can be\nREACTION_ADD for reaction addition or\nREACTION_REMOVE for reaction removal.",
            "New in version 1.3.",
            "str",
            "Whether this reaction is a burst (super) reaction.",
            "bool",
            "A list of hex codes this reaction can be. Only available if event_type is REACTION_ADD\nand this emoji has super reactions available.",
            "Optional[list]",
            "Alias for burst_colours.",
            "Optional[list]",
            "The type of reaction added.",
            "ReactionType",
            "The raw data sent by the gateway.",
            "New in version 2.5.",
            "dict",
            "data (ReactionActionEvent) –",
            "emoji (PartialEmoji) –",
            "event_type (str) –",
            "Represents the payload for a on_raw_reaction_clear() event.",
            "The message ID that got its reactions cleared.",
            "int",
            "The channel ID where the reactions got cleared.",
            "int",
            "The guild ID where the reactions got cleared.",
            "Optional[int]",
            "The raw data sent by the gateway.",
            "New in version 2.5.",
            "dict",
            "data (ReactionClearEvent) –",
            "Represents the payload for a on_raw_reaction_clear_emoji() event.",
            "New in version 1.3.",
            "The message ID that got its reactions cleared.",
            "int",
            "The channel ID where the reactions got cleared.",
            "int",
            "The guild ID where the reactions got cleared.",
            "Optional[int]",
            "The custom or unicode emoji being removed.",
            "PartialEmoji",
            "Whether this reaction was a burst (super) reaction.",
            "bool",
            "The available HEX codes of the removed super reaction.",
            "list",
            "Alias for burst_colours.",
            "Optional[list]",
            "The type of reaction removed.",
            "ReactionType",
            "The raw data sent by the gateway.",
            "New in version 2.5.",
            "dict",
            "data (ReactionClearEmojiEvent) –",
            "emoji (PartialEmoji) –",
            "Represents the payload for a on_raw_integration_delete() event.",
            "New in version 2.0.",
            "The ID of the integration that got deleted.",
            "int",
            "The ID of the bot/OAuth2 application for this deleted integration.",
            "Optional[int]",
            "The guild ID where the integration got deleted.",
            "int",
            "The raw data sent by the gateway.",
            "New in version 2.5.",
            "dict",
            "data (IntegrationDeleteEvent) –",
            "Represents the payload for on_raw_thread_delete() event.",
            "New in version 2.0.",
            "The ID of the thread that was deleted.",
            "int",
            "The channel type of the deleted thread.",
            "discord.ChannelType",
            "The ID of the guild the deleted thread belonged to.",
            "int",
            "The ID of the channel the thread belonged to.",
            "int",
            "The thread that was deleted. This may be None if deleted thread is not found in internal cache.",
            "Optional[discord.Thread]",
            "The raw data sent by the gateway.",
            "New in version 2.5.",
            "dict",
            "data (ThreadDeleteEvent) –",
            "Represents the payload for a raw_scheduled_event_user_add() or\nraw_scheduled_event_user_remove() event.",
            "New in version 2.0.",
            "The event ID where the typing originated from.",
            "int",
            "The ID of the user that subscribed/unsubscribed.",
            "int",
            "The guild where the subscription/unsubscription happened.",
            "Optional[Guild]",
            "Can be either USER_ADD or USER_REMOVE depending on\nthe event called.",
            "str",
            "The raw data sent by the gateway.",
            "New in version 2.5.",
            "dict",
            "data (ScheduledEventSubscription) –",
            "event_type (str) –",
            "Represents the payload for an on_raw_member_remove() event.",
            "New in version 2.4.",
            "The user that left the guild.",
            "discord.User",
            "The ID of the guild the user left.",
            "int",
            "The raw data sent by the gateway.",
            "New in version 2.5.",
            "dict",
            "data (MemberRemoveEvent) –",
            "user (User) –",
            "Represents the payload for an on_raw_thread_update() event.",
            "New in version 2.4.",
            "The ID of the updated thread.",
            "int",
            "The channel type of the updated thread.",
            "discord.ChannelType",
            "The ID of the guild the thread belongs to.",
            "int",
            "The ID of the channel the thread belongs to.",
            "int",
            "The raw data sent by the gateway.",
            "dict",
            "The thread, if it could be found in the internal cache.",
            "discord.Thread | None",
            "data (Thread) –",
            "Represents the payload for an on_raw_thread_member_remove() event.",
            "New in version 2.4.",
            "The ID of the thread that was updated.",
            "int",
            "The ID of the guild the thread is in.",
            "int",
            "The approximate number of members in the thread. Maximum of 50.",
            "int",
            "The raw data sent by the gateway.",
            "New in version 2.5.",
            "dict",
            "data (ThreadMembersUpdateEvent) –",
            "Represents the payload for an on_raw_audit_log_entry() event.",
            "New in version 2.5.",
            "The action that was done.",
            "AuditLogAction",
            "The entry ID.",
            "int",
            "The ID of the guild this action came from.",
            "int",
            "The ID of the user who initiated this action.",
            "Optional[int]",
            "The ID of the target that got changed.",
            "Optional[int]",
            "The reason this action was done.",
            "Optional[str]",
            "The changes that were made to the target.",
            "Optional[list]",
            "Extra information that this entry has that might be useful.\nFor most actions, this is None. However, in some cases it\ncontains extra information. See AuditLogAction for\nwhich actions have this field filled out.",
            "Any",
            "The raw data sent by the gateway.",
            "dict",
            "data (AuditLogEntryEvent) –",
            "Represents the payload for an on_raw_voice_channel_status_update() event.",
            "New in version 2.5.",
            "The channel ID where the voice channel status update originated from.",
            "int",
            "The guild ID where the voice channel status update originated from.",
            "int",
            "The new new voice channel status.",
            "Optional[str]",
            "The raw data sent by the gateway.",
            "dict",
            "data (VoiceChannelStatusUpdateEvent) –"
        ],
        "code": [
            "on_auto_moderation_action_execution()",
            "AutoModAction",
            "int",
            "AutoModTriggerType",
            "int",
            "Guild",
            "int",
            "Member",
            "int",
            "TextChannel",
            "Thread",
            "VoiceChannel",
            "StageChannel",
            "int",
            "Message",
            "int",
            "Message",
            "str",
            "str",
            "str",
            "dict",
            "ConnectionState",
            "AutoModActionExecutionEvent",
            "on_raw_typing()",
            "int",
            "int",
            "datetime.datetime",
            "int",
            "Member",
            "dict",
            "TypingEvent",
            "on_raw_message_delete()",
            "int",
            "int",
            "int",
            "Message",
            "dict",
            "MessageDeleteEvent",
            "on_raw_bulk_message_delete()",
            "set",
            "int",
            "int",
            "int",
            "Message",
            "dict",
            "BulkMessageDeleteEvent",
            "on_raw_message_edit()",
            "int",
            "int",
            "int",
            "dict",
            "RawMessageUpdateEvent.data",
            "Message",
            "MessageUpdateEvent",
            "on_raw_reaction_add()",
            "on_raw_reaction_remove()",
            "int",
            "int",
            "int",
            "int",
            "PartialEmoji",
            "Member",
            "REACTION_ADD",
            "REACTION_REMOVE",
            "str",
            "bool",
            "list",
            "burst_colours",
            "list",
            "ReactionType",
            "dict",
            "ReactionActionEvent",
            "PartialEmoji",
            "str",
            "on_raw_reaction_clear()",
            "int",
            "int",
            "int",
            "dict",
            "ReactionClearEvent",
            "on_raw_reaction_clear_emoji()",
            "int",
            "int",
            "int",
            "PartialEmoji",
            "bool",
            "list",
            "burst_colours",
            "list",
            "ReactionType",
            "dict",
            "ReactionClearEmojiEvent",
            "PartialEmoji",
            "on_raw_integration_delete()",
            "int",
            "int",
            "int",
            "dict",
            "IntegrationDeleteEvent",
            "on_raw_thread_delete()",
            "int",
            "discord.ChannelType",
            "int",
            "int",
            "None",
            "discord.Thread",
            "dict",
            "ThreadDeleteEvent",
            "raw_scheduled_event_user_add()",
            "raw_scheduled_event_user_remove()",
            "int",
            "int",
            "Guild",
            "USER_ADD",
            "USER_REMOVE",
            "str",
            "dict",
            "ScheduledEventSubscription",
            "str",
            "on_raw_member_remove()",
            "discord.User",
            "int",
            "dict",
            "MemberRemoveEvent",
            "User",
            "on_raw_thread_update()",
            "int",
            "discord.ChannelType",
            "int",
            "int",
            "dict",
            "discord.Thread",
            "Thread",
            "on_raw_thread_member_remove()",
            "int",
            "int",
            "int",
            "dict",
            "ThreadMembersUpdateEvent",
            "on_raw_audit_log_entry()",
            "AuditLogAction",
            "int",
            "int",
            "int",
            "int",
            "str",
            "list",
            "None",
            "AuditLogAction",
            "dict",
            "AuditLogEntryEvent",
            "on_raw_voice_channel_status_update()",
            "int",
            "int",
            "str",
            "dict",
            "VoiceChannelStatusUpdateEvent"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Webhooks#",
        "content": [
            "Represents a partial guild for webhooks.",
            "These are typically given for channel follower webhooks.",
            "New in version 2.0.",
            "The partial guild’s ID.",
            "int",
            "The partial guild’s name.",
            "str",
            "Returns the guild’s icon asset, if available.",
            "Represents a partial channel for webhooks.",
            "These are typically given for channel follower webhooks.",
            "New in version 2.0.",
            "The partial channel’s ID.",
            "int",
            "The partial channel’s name.",
            "str"
        ],
        "code": [
            "int",
            "str",
            "int",
            "str",
            "Asset",
            "url",
            "key",
            "is_animated()",
            "replace()",
            "with_size()",
            "with_format()",
            "with_static_format()",
            "read()",
            "save()",
            "Spotify",
            "type",
            "created_at",
            "colour",
            "color",
            "name",
            "title",
            "artists",
            "artist",
            "album",
            "album_cover_url",
            "track_id",
            "track_url",
            "start",
            "end",
            "duration",
            "party_id",
            "VoiceState",
            "deaf",
            "mute",
            "self_mute",
            "self_deaf",
            "self_stream",
            "self_video",
            "suppress",
            "requested_to_speak_at",
            "afk",
            "channel",
            "PartialMessageable",
            "id",
            "type",
            "can_send()",
            "fetch_message()",
            "history()",
            "pins()",
            "send()",
            "trigger_typing()",
            "typing()",
            "get_partial_message()",
            "ClientUser",
            "name",
            "id",
            "discriminator",
            "global_name",
            "bot",
            "system",
            "verified",
            "locale",
            "mfa_enabled",
            "edit()",
            "accent_color",
            "accent_colour",
            "avatar",
            "avatar_decoration",
            "banner",
            "color",
            "colour",
            "created_at",
            "default_avatar",
            "display_avatar",
            "display_name",
            "is_migrated",
            "jump_url",
            "mention",
            "mentioned_in()",
            "public_flags",
            "User",
            "name",
            "id",
            "discriminator",
            "global_name",
            "bot",
            "system",
            "history()",
            "typing()",
            "dm_channel",
            "mutual_guilds",
            "create_dm()",
            "create_test_entitlement()",
            "accent_color",
            "accent_colour",
            "avatar",
            "avatar_decoration",
            "banner",
            "can_send()",
            "color",
            "colour",
            "created_at",
            "default_avatar",
            "display_avatar",
            "display_name",
            "entitlements()",
            "fetch_message()",
            "is_migrated",
            "jump_url",
            "mention",
            "mentioned_in()",
            "pins()",
            "public_flags",
            "send()",
            "trigger_typing()",
            "Attachment",
            "id",
            "size",
            "height",
            "width",
            "filename",
            "title",
            "url",
            "proxy_url",
            "content_type",
            "ephemeral",
            "description",
            "duration_secs",
            "waveform",
            "flags",
            "hm",
            "expires_at",
            "issued_at",
            "is_spoiler()",
            "save()",
            "read()",
            "to_file()",
            "Message",
            "tts",
            "type",
            "author",
            "content",
            "nonce",
            "embeds",
            "channel",
            "reference",
            "mention_everyone",
            "mentions",
            "channel_mentions",
            "role_mentions",
            "id",
            "webhook_id",
            "attachments",
            "pinned",
            "flags",
            "reactions",
            "activity",
            "application",
            "stickers",
            "components",
            "guild",
            "interaction",
            "interaction_metadata",
            "thread",
            "poll",
            "call",
            "raw_mentions",
            "raw_channel_mentions",
            "raw_role_mentions",
            "clean_content",
            "created_at",
            "edited_at",
            "jump_url",
            "is_system()",
            "system_content",
            "delete()",
            "edit()",
            "publish()",
            "pin()",
            "unpin()",
            "add_reaction()",
            "remove_reaction()",
            "clear_reaction()",
            "clear_reactions()",
            "create_thread()",
            "reply()",
            "end_poll()",
            "to_reference()",
            "DeletedReferencedMessage",
            "id",
            "channel_id",
            "guild_id",
            "Reaction",
            "emoji",
            "count",
            "me",
            "me_burst",
            "message",
            "burst",
            "users()",
            "burst_colours",
            "burst_colors",
            "count_details",
            "is_custom_emoji()",
            "remove()",
            "clear()",
            "ReactionCountDetails",
            "normal",
            "burst",
            "SKU",
            "id",
            "type",
            "application_id",
            "name",
            "slug",
            "flags",
            "url",
            "Entitlement",
            "id",
            "sku_id",
            "application_id",
            "user_id",
            "type",
            "deleted",
            "starts_at",
            "ends_at",
            "guild_id",
            "consumed",
            "consume()",
            "delete()",
            "Guild",
            "name",
            "emojis",
            "stickers",
            "afk_timeout",
            "afk_channel",
            "id",
            "invites_disabled",
            "owner_id",
            "unavailable",
            "max_presences",
            "max_members",
            "max_video_channel_users",
            "description",
            "mfa_level",
            "verification_level",
            "explicit_content_filter",
            "default_notifications",
            "features",
            "premium_tier",
            "premium_subscription_count",
            "premium_progress_bar_enabled",
            "preferred_locale",
            "nsfw_level",
            "approximate_member_count",
            "approximate_presence_count",
            "fetch_members()",
            "audit_logs()",
            "channels",
            "threads",
            "jump_url",
            "large",
            "voice_channels",
            "stage_channels",
            "forum_channels",
            "me",
            "voice_client",
            "text_channels",
            "categories",
            "by_category()",
            "get_channel_or_thread()",
            "get_channel()",
            "get_thread()",
            "system_channel",
            "system_channel_flags",
            "rules_channel",
            "public_updates_channel",
            "emoji_limit",
            "sticker_limit",
            "bitrate_limit",
            "filesize_limit",
            "members",
            "get_member()",
            "premium_subscribers",
            "roles",
            "get_role()",
            "default_role",
            "premium_subscriber_role",
            "self_role",
            "stage_instances",
            "get_stage_instance()",
            "owner",
            "icon",
            "banner",
            "splash",
            "discovery_splash",
            "member_count",
            "chunked",
            "shard_id",
            "created_at",
            "invites_disabled",
            "get_member_named()",
            "create_text_channel()",
            "create_voice_channel()",
            "create_stage_channel()",
            "create_forum_channel()",
            "create_category()",
            "create_category_channel()",
            "leave()",
            "delete()",
            "set_mfa_required()",
            "edit()",
            "fetch_channels()",
            "active_threads()",
            "search_members()",
            "fetch_member()",
            "fetch_ban()",
            "fetch_channel()",
            "bans()",
            "prune_members()",
            "templates()",
            "webhooks()",
            "estimate_pruned_members()",
            "invites()",
            "create_template()",
            "create_integration()",
            "integrations()",
            "fetch_stickers()",
            "fetch_sticker()",
            "create_sticker()",
            "delete_sticker()",
            "fetch_emojis()",
            "fetch_emoji()",
            "create_custom_emoji()",
            "delete_emoji()",
            "fetch_roles()",
            "create_role()",
            "edit_role_positions()",
            "kick()",
            "ban()",
            "bulk_ban()",
            "unban()",
            "vanity_invite()",
            "widget()",
            "edit_widget()",
            "chunk()",
            "query_members()",
            "change_voice_state()",
            "welcome_screen()",
            "edit_welcome_screen()",
            "fetch_scheduled_events()",
            "fetch_scheduled_event()",
            "get_scheduled_event()",
            "create_scheduled_event()",
            "scheduled_events",
            "fetch_auto_moderation_rules()",
            "fetch_auto_moderation_rule()",
            "create_auto_moderation_rule()",
            "onboarding()",
            "edit_onboarding()",
            "delete_auto_moderation_rule()",
            "create_test_entitlement()",
            "entitlements()",
            "BanEntry",
            "reason",
            "user",
            "Member",
            "joined_at",
            "activities",
            "guild",
            "nick",
            "pending",
            "premium_since",
            "communication_disabled_until",
            "flags",
            "history()",
            "typing()",
            "name",
            "id",
            "discriminator",
            "bot",
            "system",
            "created_at",
            "default_avatar",
            "avatar",
            "dm_channel",
            "create_dm()",
            "mutual_guilds",
            "public_flags",
            "banner",
            "accent_color",
            "accent_colour",
            "raw_status",
            "status",
            "mobile_status",
            "desktop_status",
            "web_status",
            "global_name",
            "is_on_mobile()",
            "colour",
            "color",
            "roles",
            "mention",
            "display_name",
            "display_avatar",
            "guild_avatar",
            "activity",
            "mentioned_in()",
            "top_role",
            "guild_permissions",
            "voice",
            "timed_out",
            "ban()",
            "unban()",
            "kick()",
            "edit()",
            "timeout()",
            "timeout_for()",
            "remove_timeout()",
            "request_to_speak()",
            "move_to()",
            "add_roles()",
            "avatar_decoration",
            "can_send()",
            "create_test_entitlement()",
            "entitlements()",
            "fetch_message()",
            "is_migrated",
            "jump_url",
            "pins()",
            "remove_roles()",
            "send()",
            "trigger_typing()",
            "get_role()",
            "Template",
            "code",
            "uses",
            "name",
            "description",
            "creator",
            "created_at",
            "updated_at",
            "source_guild",
            "is_dirty",
            "create_guild()",
            "sync()",
            "edit()",
            "delete()",
            "url",
            "AutoModRule",
            "id",
            "name",
            "creator_id",
            "event_type",
            "trigger_type",
            "trigger_metadata",
            "actions",
            "enabled",
            "exempt_role_ids",
            "exempt_channel_ids",
            "guild",
            "creator",
            "exempt_roles",
            "exempt_channels",
            "delete()",
            "edit()",
            "AutoModAction",
            "type",
            "metadata",
            "AutoModActionMetadata",
            "channel_id",
            "timeout_duration",
            "custom_message",
            "AutoModTriggerMetadata",
            "keyword_filter",
            "regex_patterns",
            "presets",
            "allow_list",
            "mention_total_limit",
            "PartialInviteGuild",
            "name",
            "id",
            "verification_level",
            "features",
            "description",
            "created_at",
            "icon",
            "banner",
            "splash",
            "PartialInviteChannel",
            "name",
            "id",
            "type",
            "mention",
            "created_at",
            "Invite",
            "max_age",
            "code",
            "guild",
            "revoked",
            "created_at",
            "temporary",
            "uses",
            "max_uses",
            "inviter",
            "approximate_member_count",
            "approximate_presence_count",
            "expires_at",
            "channel",
            "target_type",
            "target_user",
            "target_application",
            "scheduled_event",
            "id",
            "url",
            "delete()",
            "set_scheduled_event()",
            "Role",
            "id",
            "name",
            "guild",
            "hoist",
            "position",
            "managed",
            "mentionable",
            "tags",
            "unicode_emoji",
            "flags",
            "is_default()",
            "is_bot_managed()",
            "is_premium_subscriber()",
            "is_integration()",
            "is_assignable()",
            "permissions",
            "colour",
            "color",
            "created_at",
            "mention",
            "members",
            "icon",
            "edit()",
            "delete()",
            "RoleTags",
            "bot_id",
            "integration_id",
            "is_bot_managed()",
            "is_premium_subscriber()",
            "is_integration()",
            "ScheduledEvent",
            "guild",
            "name",
            "description",
            "start_time",
            "end_time",
            "status",
            "location",
            "subscriber_count",
            "creator_id",
            "creator",
            "privacy_level",
            "created_at",
            "interested",
            "url",
            "cover",
            "edit()",
            "delete()",
            "start()",
            "complete()",
            "cancel()",
            "subscribers()",
            "ScheduledEventLocation",
            "value",
            "type",
            "WelcomeScreen",
            "description",
            "welcome_channels",
            "enabled",
            "guild",
            "edit()",
            "WelcomeScreenChannel",
            "channel",
            "description",
            "emoji",
            "Onboarding",
            "prompts",
            "enabled",
            "mode",
            "default_channels",
            "edit()",
            "add_prompt()",
            "append_prompt()",
            "get_prompt()",
            "delete_prompt()",
            "OnboardingPrompt",
            "id",
            "type",
            "title",
            "options",
            "single_select",
            "required",
            "in_onboarding",
            "PromptOption",
            "id",
            "channels",
            "roles",
            "emoji",
            "title",
            "description",
            "Integration",
            "id",
            "name",
            "guild",
            "type",
            "enabled",
            "account",
            "user",
            "delete()",
            "IntegrationAccount",
            "id",
            "name",
            "BotIntegration",
            "id",
            "name",
            "guild",
            "type",
            "enabled",
            "user",
            "account",
            "application",
            "IntegrationApplication",
            "id",
            "name",
            "icon",
            "description",
            "summary",
            "user",
            "StreamIntegration",
            "id",
            "name",
            "guild",
            "type",
            "enabled",
            "syncing",
            "enable_emoticons",
            "expire_behaviour",
            "expire_grace_period",
            "user",
            "account",
            "synced_at",
            "expire_behavior",
            "role",
            "edit()",
            "sync()",
            "Widget",
            "id",
            "name",
            "channels",
            "members",
            "created_at",
            "json_url",
            "invite_url",
            "fetch_invite()",
            "WidgetChannel",
            "id",
            "name",
            "position",
            "mention",
            "created_at",
            "WidgetMember",
            "id",
            "name",
            "discriminator",
            "bot",
            "status",
            "nick",
            "avatar",
            "activity",
            "deafened",
            "muted",
            "suppress",
            "connected_channel",
            "display_name",
            "accent_color",
            "accent_colour",
            "avatar_decoration",
            "banner",
            "color",
            "colour",
            "created_at",
            "default_avatar",
            "display_avatar",
            "is_migrated",
            "jump_url",
            "mention",
            "mentioned_in()",
            "public_flags",
            "Thread",
            "name",
            "guild",
            "id",
            "parent_id",
            "owner_id",
            "last_message_id",
            "slowmode_delay",
            "message_count",
            "member_count",
            "me",
            "archived",
            "locked",
            "invitable",
            "auto_archive_duration",
            "archive_timestamp",
            "created_at",
            "flags",
            "total_message_sent",
            "history()",
            "typing()",
            "type",
            "parent",
            "owner",
            "mention",
            "jump_url",
            "members",
            "applied_tags",
            "last_message",
            "category",
            "category_id",
            "starting_message",
            "is_pinned()",
            "is_private()",
            "is_news()",
            "is_nsfw()",
            "permissions_for()",
            "delete_messages()",
            "purge()",
            "edit()",
            "archive()",
            "unarchive()",
            "join()",
            "leave()",
            "add_user()",
            "remove_user()",
            "fetch_members()",
            "delete()",
            "get_partial_message()",
            "can_send()",
            "fetch_message()",
            "pins()",
            "send()",
            "trigger_typing()",
            "ThreadMember",
            "id",
            "thread_id",
            "joined_at",
            "thread",
            "StageChannel",
            "name",
            "guild",
            "id",
            "topic",
            "category_id",
            "position",
            "bitrate",
            "user_limit",
            "rtc_region",
            "video_quality_mode",
            "flags",
            "last_message_id",
            "requesting_to_speak",
            "speakers",
            "listeners",
            "is_nsfw()",
            "last_message",
            "get_partial_message()",
            "delete_messages()",
            "purge()",
            "webhooks()",
            "create_webhook()",
            "moderators",
            "type",
            "clone()",
            "instance",
            "create_instance()",
            "fetch_instance()",
            "edit()",
            "can_send()",
            "category",
            "changed_roles",
            "connect()",
            "create_invite()",
            "created_at",
            "delete()",
            "fetch_message()",
            "history()",
            "invites()",
            "jump_url",
            "members",
            "mention",
            "move()",
            "overwrites",
            "overwrites_for()",
            "permissions_for()",
            "permissions_synced",
            "pins()",
            "send()",
            "set_permissions()",
            "trigger_typing()",
            "typing()",
            "voice_states",
            "StageInstance",
            "id",
            "guild",
            "channel_id",
            "topic",
            "privacy_level",
            "discoverable_disabled",
            "scheduled_event",
            "channel",
            "edit()",
            "delete()",
            "Interaction",
            "id",
            "type",
            "guild_id",
            "channel",
            "channel_id",
            "application_id",
            "user",
            "message",
            "token",
            "data",
            "locale",
            "guild_locale",
            "custom_id",
            "entitlements",
            "authorizing_integration_owners",
            "context",
            "client",
            "guild",
            "is_command()",
            "is_component()",
            "cached_channel",
            "permissions",
            "app_permissions",
            "response",
            "followup",
            "original_response()",
            "original_message()",
            "edit_original_response()",
            "edit_original_message()",
            "delete_original_response()",
            "delete_original_message()",
            "respond()",
            "edit()",
            "to_dict()",
            "InteractionResponse",
            "is_done()",
            "defer()",
            "pong()",
            "send_message()",
            "edit_message()",
            "send_autocomplete_result()",
            "send_modal()",
            "premium_required()",
            "InteractionMessage",
            "edit()",
            "delete()",
            "MessageInteraction",
            "id",
            "type",
            "name",
            "user",
            "data",
            "InteractionMetadata",
            "id",
            "type",
            "user",
            "authorizing_integration_owners",
            "original_response_message_id",
            "interacted_message_id",
            "triggering_interaction_metadata",
            "original_response_message",
            "interacted_message",
            "AuthorizingIntegrationOwners",
            "user_id",
            "guild_id",
            "user",
            "guild",
            "Component",
            "type",
            "ActionRow",
            "type",
            "children",
            "Button",
            "style",
            "custom_id",
            "url",
            "disabled",
            "label",
            "emoji",
            "sku_id",
            "SelectMenu",
            "type",
            "custom_id",
            "placeholder",
            "min_values",
            "max_values",
            "options",
            "channel_types",
            "disabled",
            "Emoji",
            "name",
            "id",
            "require_colons",
            "animated",
            "managed",
            "guild_id",
            "available",
            "user",
            "created_at",
            "url",
            "roles",
            "guild",
            "is_usable()",
            "delete()",
            "edit()",
            "read()",
            "save()",
            "PartialEmoji",
            "name",
            "animated",
            "id",
            "from_str()",
            "is_custom_emoji()",
            "is_unicode_emoji()",
            "created_at",
            "url",
            "read()",
            "save()",
            "TextChannel",
            "name",
            "guild",
            "id",
            "category_id",
            "topic",
            "position",
            "last_message_id",
            "slowmode_delay",
            "nsfw",
            "default_auto_archive_duration",
            "flags",
            "default_thread_slowmode_delay",
            "history()",
            "typing()",
            "is_news()",
            "news",
            "edit()",
            "create_thread()",
            "archived_threads()",
            "can_send()",
            "category",
            "changed_roles",
            "clone()",
            "create_invite()",
            "create_webhook()",
            "created_at",
            "delete()",
            "delete_messages()",
            "fetch_message()",
            "follow()",
            "get_partial_message()",
            "get_thread()",
            "invites()",
            "is_nsfw()",
            "jump_url",
            "last_message",
            "members",
            "mention",
            "move()",
            "overwrites",
            "overwrites_for()",
            "permissions_for()",
            "permissions_synced",
            "pins()",
            "purge()",
            "send()",
            "set_permissions()",
            "threads",
            "trigger_typing()",
            "type",
            "webhooks()",
            "ForumChannel",
            "name",
            "guild",
            "id",
            "category_id",
            "topic",
            "position",
            "last_message_id",
            "slowmode_delay",
            "nsfw",
            "default_auto_archive_duration",
            "flags",
            "available_tags",
            "default_sort_order",
            "default_thread_slowmode_delay",
            "default_reaction_emoji",
            "guidelines",
            "requires_tag",
            "get_tag()",
            "edit()",
            "create_thread()",
            "archived_threads()",
            "category",
            "changed_roles",
            "clone()",
            "create_invite()",
            "create_webhook()",
            "created_at",
            "delete()",
            "delete_messages()",
            "follow()",
            "get_partial_message()",
            "get_thread()",
            "invites()",
            "is_nsfw()",
            "jump_url",
            "last_message",
            "members",
            "mention",
            "move()",
            "overwrites",
            "overwrites_for()",
            "permissions_for()",
            "permissions_synced",
            "purge()",
            "set_permissions()",
            "threads",
            "type",
            "webhooks()",
            "VoiceChannel",
            "name",
            "guild",
            "id",
            "category_id",
            "position",
            "bitrate",
            "user_limit",
            "rtc_region",
            "video_quality_mode",
            "last_message_id",
            "slowmode_delay",
            "status",
            "flags",
            "is_nsfw()",
            "last_message",
            "get_partial_message()",
            "delete_messages()",
            "purge()",
            "webhooks()",
            "create_webhook()",
            "type",
            "clone()",
            "edit()",
            "create_activity_invite()",
            "set_status()",
            "can_send()",
            "category",
            "changed_roles",
            "connect()",
            "create_invite()",
            "created_at",
            "delete()",
            "fetch_message()",
            "history()",
            "invites()",
            "jump_url",
            "members",
            "mention",
            "move()",
            "overwrites",
            "overwrites_for()",
            "permissions_for()",
            "permissions_synced",
            "pins()",
            "send()",
            "set_permissions()",
            "trigger_typing()",
            "typing()",
            "voice_states",
            "CategoryChannel",
            "name",
            "guild",
            "id",
            "position",
            "nsfw",
            "flags",
            "type",
            "is_nsfw()",
            "clone()",
            "edit()",
            "move()",
            "channels",
            "text_channels",
            "voice_channels",
            "stage_channels",
            "forum_channels",
            "create_text_channel()",
            "create_voice_channel()",
            "create_stage_channel()",
            "create_forum_channel()",
            "category",
            "changed_roles",
            "create_invite()",
            "created_at",
            "delete()",
            "invites()",
            "jump_url",
            "mention",
            "overwrites",
            "overwrites_for()",
            "permissions_for()",
            "permissions_synced",
            "set_permissions()",
            "DMChannel",
            "recipient",
            "me",
            "id",
            "history()",
            "typing()",
            "type",
            "jump_url",
            "created_at",
            "permissions_for()",
            "get_partial_message()",
            "can_send()",
            "fetch_message()",
            "pins()",
            "send()",
            "trigger_typing()",
            "GroupChannel",
            "recipients",
            "me",
            "id",
            "owner",
            "owner_id",
            "name",
            "history()",
            "typing()",
            "type",
            "icon",
            "created_at",
            "jump_url",
            "permissions_for()",
            "can_send()",
            "fetch_message()",
            "leave()",
            "pins()",
            "send()",
            "trigger_typing()",
            "Sticker",
            "name",
            "id",
            "description",
            "pack_id",
            "format",
            "url",
            "created_at",
            "StickerPack",
            "name",
            "description",
            "id",
            "stickers",
            "sku_id",
            "cover_sticker_id",
            "cover_sticker",
            "banner",
            "StickerItem",
            "name",
            "id",
            "format",
            "url",
            "fetch()",
            "StandardSticker",
            "name",
            "id",
            "description",
            "pack_id",
            "format",
            "tags",
            "sort_value",
            "pack()",
            "GuildSticker",
            "name",
            "id",
            "description",
            "format",
            "available",
            "guild_id",
            "user",
            "emoji",
            "guild",
            "edit()",
            "delete()",
            "AutoModActionExecutionEvent",
            "action",
            "rule_id",
            "rule_trigger_type",
            "guild_id",
            "guild",
            "user_id",
            "member",
            "channel_id",
            "channel",
            "message_id",
            "message",
            "alert_system_message_id",
            "alert_system_message",
            "content",
            "matched_keyword",
            "matched_content",
            "data",
            "RawTypingEvent",
            "channel_id",
            "user_id",
            "when",
            "guild_id",
            "member",
            "data",
            "RawMessageDeleteEvent",
            "channel_id",
            "guild_id",
            "message_id",
            "cached_message",
            "data",
            "RawBulkMessageDeleteEvent",
            "message_ids",
            "channel_id",
            "guild_id",
            "cached_messages",
            "data",
            "RawMessageUpdateEvent",
            "message_id",
            "channel_id",
            "guild_id",
            "data",
            "cached_message",
            "RawReactionActionEvent",
            "message_id",
            "user_id",
            "channel_id",
            "guild_id",
            "emoji",
            "member",
            "event_type",
            "burst",
            "burst_colours",
            "burst_colors",
            "type",
            "data",
            "RawReactionClearEvent",
            "message_id",
            "channel_id",
            "guild_id",
            "data",
            "RawReactionClearEmojiEvent",
            "message_id",
            "channel_id",
            "guild_id",
            "emoji",
            "burst",
            "burst_colours",
            "burst_colors",
            "type",
            "data",
            "RawIntegrationDeleteEvent",
            "integration_id",
            "application_id",
            "guild_id",
            "data",
            "RawThreadDeleteEvent",
            "thread_id",
            "thread_type",
            "guild_id",
            "parent_id",
            "thread",
            "data",
            "RawScheduledEventSubscription",
            "event_id",
            "user_id",
            "guild",
            "event_type",
            "data",
            "RawMemberRemoveEvent",
            "user",
            "guild_id",
            "data",
            "RawThreadUpdateEvent",
            "thread_id",
            "thread_type",
            "guild_id",
            "parent_id",
            "data",
            "thread",
            "RawThreadMembersUpdateEvent",
            "thread_id",
            "guild_id",
            "member_count",
            "data",
            "RawAuditLogEntryEvent",
            "action_type",
            "id",
            "guild_id",
            "user_id",
            "target_id",
            "reason",
            "changes",
            "extra",
            "data",
            "RawVoiceChannelStatusUpdateEvent",
            "id",
            "guild_id",
            "status",
            "data",
            "PartialWebhookGuild",
            "id",
            "name",
            "icon",
            "PartialWebhookChannel",
            "id",
            "name"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/models.html"
    },
    {
        "title": "Version Related Info#",
        "content": [
            "There are two main ways to query version information about the library. For guarantees, check Version Guarantees.",
            "A named tuple that is similar to sys.version_info.",
            "Just like sys.version_info the valid values for releaselevel are\n‘alpha’, ‘beta’, ‘candidate’ and ‘final’.",
            "A string representation of the version. e.g. '1.0.0rc1'. This is based\noff of PEP 440."
        ],
        "code": [
            "sys.version_info",
            "sys.version_info",
            "releaselevel",
            "'1.0.0rc1'",
            "version_info",
            "__version__"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/version_info.html"
    },
    {
        "title": "Application Info#",
        "content": [
            "Represents the application info for the bot provided by Discord.",
            "The application ID.",
            "int",
            "The application name.",
            "str",
            "The application owner.",
            "User",
            "The application’s team.",
            "New in version 1.3.",
            "Optional[Team]",
            "The application description.",
            "str",
            "Whether the bot can be invited by anyone or if it is locked\nto the application owner.",
            "bool",
            "Whether the bot requires the completion of the full OAuth2 code\ngrant flow to join.",
            "bool",
            "A list of RPC origin URLs, if RPC is enabled.",
            "Optional[List[str]]",
            "If this application is a game sold on Discord,\nthis field will be the summary field for the store page of its primary SKU.",
            "New in version 1.3.",
            "str",
            "The hex encoded key for verification in interactions and the\nGameSDK’s GetTicket.",
            "New in version 1.3.",
            "str",
            "If this application is a game sold on Discord,\nthis field will be the guild to which it has been linked to.",
            "New in version 1.3.",
            "Optional[int]",
            "If this application is a game sold on Discord,\nthis field will be the id of the “Game SKU” that is created,\nif it exists.",
            "New in version 1.3.",
            "Optional[int]",
            "If this application is a game sold on Discord,\nthis field will be the URL slug that links to the store page.",
            "New in version 1.3.",
            "Optional[str]",
            "The application’s terms of service URL, if set.",
            "New in version 2.0.",
            "Optional[str]",
            "The application’s privacy policy URL, if set.",
            "New in version 2.0.",
            "Optional[str]",
            "state (ConnectionState) –",
            "data (AppInfo) –",
            "Retrieves the application’s icon asset, if any.",
            "Retrieves the cover image on a store embed, if any.",
            "This is only available if the application is a game sold on Discord.",
            "If this application is a game sold on Discord,\nthis field will be the guild to which it has been linked.",
            "New in version 1.3.",
            "Represents a partial AppInfo given by create_invite()",
            "New in version 2.0.",
            "The application ID.",
            "int",
            "The application name.",
            "str",
            "The application description.",
            "str",
            "A list of RPC origin URLs, if RPC is enabled.",
            "Optional[List[str]]",
            "If this application is a game sold on Discord,\nthis field will be the summary field for the store page of its primary SKU.",
            "str",
            "The hex encoded key for verification in interactions and the\nGameSDK’s GetTicket.",
            "str",
            "The application’s terms of service URL, if set.",
            "Optional[str]",
            "The application’s privacy policy URL, if set.",
            "Optional[str]",
            "state (ConnectionState) –",
            "data (PartialAppInfo) –",
            "Retrieves the application’s icon asset, if any.",
            "Represents an application team for a bot provided by Discord.",
            "The team ID.",
            "int",
            "The team name.",
            "str",
            "The team’s owner ID.",
            "int",
            "A list of the members in the team.",
            "New in version 1.3.",
            "List[TeamMember]",
            "state (ConnectionState) –",
            "data (Team) –",
            "Retrieves the team’s icon asset, if any.",
            "The team’s owner.",
            "Represents a team member in a team.",
            "Checks if two team members are equal.",
            "Checks if two team members are not equal.",
            "Return the team member’s hash.",
            "Returns the team member’s name with discriminator or global_name.",
            "New in version 1.3.",
            "The team member’s username.",
            "str",
            "The team member’s unique ID.",
            "int",
            "The team member’s discriminator. This is given when the username has conflicts.",
            "Note",
            "If the user has migrated to the new username system, this will always be “0”.",
            "str",
            "The team member’s global name.",
            "New in version 2.5.",
            "str",
            "The avatar hash the team member has. Could be None.",
            "Optional[str]",
            "Specifies if the user is a bot account.",
            "bool",
            "The team that the member is from.",
            "Team",
            "The membership state of the member (e.g. invited or accepted)",
            "TeamMembershipState",
            "team (Team) –",
            "state (ConnectionState) –",
            "data (TeamMember) –"
        ],
        "code": [
            "int",
            "str",
            "User",
            "Team",
            "str",
            "bool",
            "bool",
            "str",
            "str",
            "str",
            "int",
            "int",
            "str",
            "str",
            "str",
            "ConnectionState",
            "AppInfo",
            "create_invite()",
            "int",
            "str",
            "str",
            "str",
            "str",
            "str",
            "str",
            "str",
            "ConnectionState",
            "PartialAppInfo",
            "int",
            "str",
            "int",
            "TeamMember",
            "ConnectionState",
            "Team",
            "str",
            "int",
            "str",
            "str",
            "None",
            "str",
            "bool",
            "Team",
            "TeamMembershipState",
            "Team",
            "ConnectionState",
            "TeamMember",
            "AppInfo",
            "id",
            "name",
            "owner",
            "team",
            "description",
            "bot_public",
            "bot_require_code_grant",
            "rpc_origins",
            "summary",
            "verify_key",
            "guild_id",
            "primary_sku_id",
            "slug",
            "terms_of_service_url",
            "privacy_policy_url",
            "icon",
            "cover_image",
            "guild",
            "PartialAppInfo",
            "id",
            "name",
            "description",
            "rpc_origins",
            "summary",
            "verify_key",
            "terms_of_service_url",
            "privacy_policy_url",
            "icon",
            "Team",
            "id",
            "name",
            "owner_id",
            "members",
            "icon",
            "owner",
            "TeamMember",
            "name",
            "id",
            "discriminator",
            "global_name",
            "avatar",
            "bot",
            "team",
            "membership_state"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/application_info.html"
    },
    {
        "title": "Enumerations#",
        "content": [
            "The API provides some enumerations for certain types of strings to avoid the API\nfrom being stringly typed in case the strings change in the future.",
            "All enumerations are subclasses of an internal class which mimics the behaviour\nof enum.Enum.",
            "Specifies the input type of an option.",
            "New in version 2.0.",
            "A slash subcommand.",
            "A slash command group.",
            "A string.",
            "An integer between -2⁵³ and 2⁵³.",
            "Note",
            "IDs, such as 881224361015672863, are often too big for this input type.",
            "A boolean.",
            "A user from the current channel. This will be converted to an instance of User in private channels, else Member",
            "A channel from the current guild.",
            "A role from the current guild.",
            "A mentionable (user or role).",
            "A floating-point number between -2⁵³ and 2⁵³.",
            "Note",
            "IDs, such as 881224361015672863, are often too big for this input type.",
            "An attachment.",
            "Specifies the type of channel.",
            "A text channel.",
            "A voice channel.",
            "A private text channel. Also called a direct message.",
            "A private group text channel.",
            "A category channel.",
            "A guild news channel.",
            "A guild stage voice channel.",
            "New in version 1.7.",
            "A news thread.",
            "New in version 2.0.",
            "A public thread.",
            "New in version 2.0.",
            "A private thread.",
            "New in version 2.0.",
            "A guild directory entry, used in hub guilds, currently in experiment.",
            "New in version 2.0.",
            "User can only write in threads, similar functionality to a forum.",
            "New in version 2.0.",
            "Specifies the type of Message. This is used to denote if a message\nis to be interpreted as a system message or a regular message.",
            "Checks if two messages are equal.",
            "Checks if two messages are not equal.",
            "The default message type. This is the same as regular messages.",
            "The system message when a user is added to a group private\nmessage or a thread.",
            "The system message when a user is removed from a group private\nmessage or a thread.",
            "The system message denoting call state, e.g. missed call, started call,\netc.",
            "The system message denoting that a channel’s name has been changed.",
            "The system message denoting that a channel’s icon has been changed.",
            "The system message denoting that a pinned message has been added to a channel.",
            "The system message denoting that a new member has joined a Guild.",
            "The system message denoting that a member has “nitro boosted” a guild.",
            "The system message denoting that a member has “nitro boosted” a guild\nand it achieved level 1.",
            "The system message denoting that a member has “nitro boosted” a guild\nand it achieved level 2.",
            "The system message denoting that a member has “nitro boosted” a guild\nand it achieved level 3.",
            "The system message denoting that an announcement channel has been followed.",
            "New in version 1.3.",
            "The system message denoting that a member is streaming in the guild.",
            "New in version 1.7.",
            "The system message denoting that the guild is no longer eligible for Server\nDiscovery.",
            "New in version 1.7.",
            "The system message denoting that the guild has become eligible again for Server\nDiscovery.",
            "New in version 1.7.",
            "The system message denoting that the guild has failed to meet the Server\nDiscovery requirements for one week.",
            "New in version 1.7.",
            "The system message denoting that the guild has failed to meet the Server\nDiscovery requirements for 3 weeks in a row.",
            "New in version 1.7.",
            "The system message denoting that a thread has been created. This is only\nsent if the thread has been created from an older message. The period of time\nrequired for a message to be considered old cannot be relied upon and is up to\nDiscord.",
            "New in version 2.0.",
            "The system message denoting that the author is replying to a message.",
            "New in version 2.0.",
            "The system message denoting that an application (or “slash”) command was executed.",
            "New in version 2.0.",
            "The system message sent as a reminder to invite people to the guild.",
            "New in version 2.0.",
            "The system message denoting the message in the thread that is the one that started the\nthread’s conversation topic.",
            "New in version 2.0.",
            "The system message denoting that an context menu command was executed.",
            "New in version 2.0.",
            "The system message denoting an action by automod.",
            "New in version 2.3.",
            "The system message denoting a role-subscription purchase.",
            "New in version 2.4.",
            "The system message denoting an interaction premium upsell.",
            "New in version 2.4.",
            "The system message denoting that a stage event has started.",
            "New in version 2.4.",
            "The system message denoting that a stage event has ended.",
            "New in version 2.4.",
            "The system message denoting that a stage event has a new speaker.",
            "New in version 2.4.",
            "The system message denoting that someone in a stage event is raising their hand.",
            "New in version 2.4.",
            "The system message denoting that a stage event has a new topic.",
            "New in version 2.4.",
            "The system message denoting that a member has subscribed to a guild application.",
            "New in version 2.4.",
            "Represents Discord User flags.",
            "The user is a Discord Employee.",
            "The user is a Discord Partner.",
            "The user is a HypeSquad Events member.",
            "The user is a Bug Hunter.",
            "The user has SMS recovery for Multi Factor Authentication enabled.",
            "The user has dismissed the Discord Nitro promotion.",
            "The user is a HypeSquad Bravery member.",
            "The user is a HypeSquad Brilliance member.",
            "The user is a HypeSquad Balance member.",
            "The user is an Early Supporter.",
            "The user is a Team User.",
            "Relates to partner/verification applications.",
            "The user is a system user (i.e. represents Discord officially).",
            "The user has an unread system message.",
            "The user is a Bug Hunter Level 2.",
            "The user was deleted for being underage.",
            "The user is a Verified Bot.",
            "The user is an Early Verified Bot Developer.",
            "The user is a Moderator Programs Alumni.",
            "The bot has set an interactions endpoint url.",
            "The user is disabled for being a spammer.",
            "The user is an Active Developer.",
            "Specifies the type of Activity. This is used to check how to\ninterpret the activity itself.",
            "An unknown activity type. This should generally not happen.",
            "A “Playing” activity type.",
            "A “Streaming” activity type.",
            "A “Listening” activity type.",
            "A “Watching” activity type.",
            "A custom activity type.",
            "A competing activity type.",
            "New in version 1.5.",
            "Specifies the type of Interaction.",
            "New in version 2.0.",
            "Represents Discord pinging to see if the interaction response server is alive.",
            "Represents a slash command interaction.",
            "Represents a component-based interaction, i.e. using the Discord Bot UI Kit.",
            "Represents a autocomplete interaction for slash commands.",
            "Represents a modal-based interaction.",
            "Specifies the response type for the interaction.",
            "New in version 2.0.",
            "Pongs the interaction when given a ping.",
            "See also InteractionResponse.pong()",
            "Respond to the interaction with a message.",
            "See also InteractionResponse.send_message()",
            "Responds to the interaction with a message at a later time.",
            "See also InteractionResponse.defer()",
            "Acknowledges the component interaction with a promise that\nthe message will update later (though there is no need to actually update the message).",
            "See also InteractionResponse.defer()",
            "Responds to the interaction by editing the message.",
            "See also InteractionResponse.edit_message()",
            "Responds to the interaction by sending the autocomplete choices.",
            "See also InteractionResponse.send_autocomplete_result()",
            "Responds to the interaction by sending a modal dialog.",
            "See also InteractionResponse.send_modal()",
            "Represents the component type of a component.",
            "New in version 2.0.",
            "Represents the group component which holds different components in a row.",
            "Represents a button component.",
            "Represents a string select component.",
            "Deprecated since version 2.3: Use ComponentType.string_select instead.",
            "Represents a string select component.",
            "Represents an input_text component.",
            "Represents a user select component.",
            "Represents a role select component.",
            "Represents a mentionable select component.",
            "Represents a channel select component.",
            "Represents the style of the button component.",
            "New in version 2.0.",
            "Represents a blurple button for the primary action.",
            "Represents a grey button for the secondary action.",
            "Represents a green button for a successful action.",
            "Represents a red button for a dangerous action.",
            "Represents a link button.",
            "Represents a premium button.",
            "An alias for primary.",
            "An alias for secondary.",
            "An alias for secondary.",
            "An alias for success.",
            "An alias for danger.",
            "An alias for link.",
            "Represents the style of the input text component.",
            "New in version 2.0.",
            "Represents a single-line input text field.",
            "Represents a multi-line input text field.",
            "An alias for short.",
            "An alias for long.",
            "An alias for long.",
            "Specifies the region a voice server belongs to.",
            "The Amsterdam region.",
            "The Brazil region.",
            "The Dubai region.",
            "New in version 1.3.",
            "The EU Central region.",
            "The EU West region.",
            "The Europe region.",
            "New in version 1.3.",
            "The Frankfurt region.",
            "The Hong Kong region.",
            "The India region.",
            "New in version 1.2.",
            "The Japan region.",
            "The London region.",
            "The Russia region.",
            "The Singapore region.",
            "The South Africa region.",
            "The South Korea region.",
            "The Sydney region.",
            "The US Central region.",
            "The US East region.",
            "The US South region.",
            "The US West region.",
            "The Amsterdam region for VIP guilds.",
            "The US East region for VIP guilds.",
            "The US West region for VIP guilds.",
            "Specifies a Guild's verification level, which is the criteria in\nwhich a member must meet before being able to send messages to the guild.",
            "New in version 2.0.",
            "Checks if two verification levels are equal.",
            "Checks if two verification levels are not equal.",
            "Checks if a verification level is higher than another.",
            "Checks if a verification level is lower than another.",
            "Checks if a verification level is higher or equal to another.",
            "Checks if a verification level is lower or equal to another.",
            "No criteria set.",
            "Member must have a verified email on their Discord account.",
            "Member must have a verified email and be registered on Discord for more\nthan five minutes.",
            "Member must have a verified email, be registered on Discord for more\nthan five minutes, and be a member of the guild itself for more than\nten minutes.",
            "Member must have a verified phone on their Discord account.",
            "Specifies whether a Guild has notifications on for all messages or mentions only by default.",
            "New in version 2.0.",
            "Checks if two notification levels are equal.",
            "Checks if two notification levels are not equal.",
            "Checks if a notification level is higher than another.",
            "Checks if a notification level is lower than another.",
            "Checks if a notification level is higher or equal to another.",
            "Checks if a notification level is lower or equal to another.",
            "Members receive notifications for every message regardless of them being mentioned.",
            "Members receive notifications for messages they are mentioned in.",
            "Specifies a Guild's explicit content filter, which is the machine\nlearning algorithms that Discord uses to detect if an image contains\npornography or otherwise explicit content.",
            "New in version 2.0.",
            "Checks if two content filter levels are equal.",
            "Checks if two content filter levels are not equal.",
            "Checks if a content filter level is higher than another.",
            "Checks if a content filter level is lower than another.",
            "Checks if a content filter level is higher or equal to another.",
            "Checks if a content filter level is lower or equal to another.",
            "The guild does not have the content filter enabled.",
            "The guild has the content filter enabled for members without a role.",
            "The guild has the content filter enabled for every member.",
            "Specifies a Member ‘s status.",
            "The member is online.",
            "The member is offline.",
            "The member is idle.",
            "The member is “Do Not Disturb”.",
            "An alias for dnd.",
            "The member is “invisible”. In reality, this is only used in sending\na presence a la Client.change_presence(). When you receive a\nuser’s presence this will be offline instead.",
            "The member is streaming.",
            "Represents the type of action being done for a AuditLogEntry,\nwhich is retrievable via Guild.audit_logs().",
            "The guild has updated. Things that trigger this include:",
            "Changing the guild vanity URL",
            "Changing the guild invite splash",
            "Changing the guild AFK channel or timeout",
            "Changing the guild voice server region",
            "Changing the guild icon, banner, or discovery splash",
            "Changing the guild moderation settings",
            "Changing things related to the guild widget",
            "When this is the action, the type of target is\nthe Guild.",
            "Possible attributes for AuditLogDiff:",
            "afk_channel",
            "system_channel",
            "afk_timeout",
            "default_message_notifications",
            "explicit_content_filter",
            "mfa_level",
            "name",
            "owner",
            "splash",
            "discovery_splash",
            "icon",
            "banner",
            "vanity_url_code",
            "A new channel was created.",
            "When this is the action, the type of target is\neither a abc.GuildChannel or Object with an ID.",
            "A more filled out object in the Object case can be found\nby using after.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "type",
            "overwrites",
            "A channel was updated. Things that trigger this include:",
            "The channel name or topic was changed",
            "The channel bitrate was changed",
            "When this is the action, the type of target is\nthe abc.GuildChannel or Object with an ID.",
            "A more filled out object in the Object case can be found\nby using after or before.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "type",
            "position",
            "overwrites",
            "topic",
            "bitrate",
            "rtc_region",
            "video_quality_mode",
            "default_auto_archive_duration",
            "A channel was deleted.",
            "When this is the action, the type of target is\nan Object with an ID.",
            "A more filled out object can be found by using the\nbefore object.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "type",
            "overwrites",
            "A channel permission overwrite was created.",
            "When this is the action, the type of target is\nthe abc.GuildChannel or Object with an ID.",
            "When this is the action, the type of extra is\neither a Role or Member. If the object is not found\nthen it is a Object with an ID being filled, a name, and a\ntype attribute set to either 'role' or 'member' to help\ndictate what type of ID it is.",
            "Possible attributes for AuditLogDiff:",
            "deny",
            "allow",
            "id",
            "type",
            "A channel permission overwrite was changed, this is typically\nwhen the permission values change.",
            "See overwrite_create for more information on how the\ntarget and extra fields\nare set.",
            "Possible attributes for AuditLogDiff:",
            "deny",
            "allow",
            "id",
            "type",
            "A channel permission overwrite was deleted.",
            "See overwrite_create for more information on how the\ntarget and extra fields\nare set.",
            "Possible attributes for AuditLogDiff:",
            "deny",
            "allow",
            "id",
            "type",
            "A member was kicked.",
            "When this is the action, the type of target is\nthe User who got kicked.",
            "When this is the action, changes is empty.",
            "A member prune was triggered.",
            "When this is the action, the type of target is\nset to None.",
            "When this is the action, the type of extra is\nset to an unspecified proxy object with two attributes:",
            "delete_members_days: An integer specifying how far the prune was.",
            "members_removed: An integer specifying how many members were removed.",
            "When this is the action, changes is empty.",
            "A member was banned.",
            "When this is the action, the type of target is\nthe User who got banned.",
            "When this is the action, changes is empty.",
            "A member was unbanned.",
            "When this is the action, the type of target is\nthe User who got unbanned.",
            "When this is the action, changes is empty.",
            "A member has updated. This triggers in the following situations:",
            "A nickname was changed",
            "They were server muted or deafened (or it was undone)",
            "When this is the action, the type of target is\nthe Member or User who got updated.",
            "Possible attributes for AuditLogDiff:",
            "nick",
            "mute",
            "deaf",
            "A member’s role has been updated. This triggers when a member\neither gains a role or loses a role.",
            "When this is the action, the type of target is\nthe Member or User who got the role.",
            "Possible attributes for AuditLogDiff:",
            "roles",
            "A member’s voice channel has been updated. This triggers when a\nmember is moved to a different voice channel.",
            "When this is the action, the type of extra is\nset to an unspecified proxy object with two attributes:",
            "channel: A TextChannel or Object with the channel ID where the members were moved.",
            "count: An integer specifying how many members were moved.",
            "New in version 1.3.",
            "A member’s voice state has changed. This triggers when a\nmember is force disconnected from voice.",
            "When this is the action, the type of extra is\nset to an unspecified proxy object with one attribute:",
            "count: An integer specifying how many members were disconnected.",
            "New in version 1.3.",
            "A bot was added to the guild.",
            "When this is the action, the type of target is\nthe Member or User which was added to the guild.",
            "New in version 1.3.",
            "A new role was created.",
            "When this is the action, the type of target is\nthe Role or a Object with the ID.",
            "Possible attributes for AuditLogDiff:",
            "colour",
            "mentionable",
            "hoist",
            "name",
            "permissions",
            "A role was updated. This triggers in the following situations:",
            "The name has changed",
            "The permissions have changed",
            "The colour has changed",
            "Its hoist/mentionable state has changed",
            "When this is the action, the type of target is\nthe Role or a Object with the ID.",
            "Possible attributes for AuditLogDiff:",
            "colour",
            "mentionable",
            "hoist",
            "name",
            "permissions",
            "A role was deleted.",
            "When this is the action, the type of target is\nthe Role or a Object with the ID.",
            "Possible attributes for AuditLogDiff:",
            "colour",
            "mentionable",
            "hoist",
            "name",
            "permissions",
            "An invite was created.",
            "When this is the action, the type of target is\nthe Invite that was created.",
            "Possible attributes for AuditLogDiff:",
            "max_age",
            "code",
            "temporary",
            "inviter",
            "channel",
            "uses",
            "max_uses",
            "An invite was updated.",
            "When this is the action, the type of target is\nthe Invite that was updated.",
            "An invite was deleted.",
            "When this is the action, the type of target is\nthe Invite that was deleted.",
            "Possible attributes for AuditLogDiff:",
            "max_age",
            "code",
            "temporary",
            "inviter",
            "channel",
            "uses",
            "max_uses",
            "A webhook was created.",
            "When this is the action, the type of target is\nthe Object with the webhook ID.",
            "Possible attributes for AuditLogDiff:",
            "channel",
            "name",
            "type (always set to 1 if so)",
            "A webhook was updated. This trigger in the following situations:",
            "The webhook name changed",
            "The webhook channel changed",
            "When this is the action, the type of target is\nthe Object with the webhook ID.",
            "Possible attributes for AuditLogDiff:",
            "channel",
            "name",
            "avatar",
            "A webhook was deleted.",
            "When this is the action, the type of target is\nthe Object with the webhook ID.",
            "Possible attributes for AuditLogDiff:",
            "channel",
            "name",
            "type (always set to 1 if so)",
            "An emoji was created.",
            "When this is the action, the type of target is\nthe Emoji or Object with the emoji ID.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "An emoji was updated. This triggers when the name has changed.",
            "When this is the action, the type of target is\nthe Emoji or Object with the emoji ID.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "An emoji was deleted.",
            "When this is the action, the type of target is\nthe Object with the emoji ID.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "A message was deleted by a moderator. Note that this\nonly triggers if the message was deleted by someone other than the author.",
            "When this is the action, the type of target is\nthe Member or User who had their message deleted.",
            "When this is the action, the type of extra is\nset to an unspecified proxy object with two attributes:",
            "count: An integer specifying how many messages were deleted.",
            "channel: A TextChannel or Object with the channel ID where the message got deleted.",
            "Messages were bulk deleted by a moderator.",
            "When this is the action, the type of target is\nthe TextChannel or Object with the ID of the channel that was purged.",
            "When this is the action, the type of extra is\nset to an unspecified proxy object with one attribute:",
            "count: An integer specifying how many messages were deleted.",
            "New in version 1.3.",
            "A message was pinned in a channel.",
            "When this is the action, the type of target is\nthe Member or User who had their message pinned.",
            "When this is the action, the type of extra is\nset to an unspecified proxy object with two attributes:",
            "channel: A TextChannel or Object with the channel ID where the message was pinned.",
            "message_id: the ID of the message which was pinned.",
            "New in version 1.3.",
            "A message was unpinned in a channel.",
            "When this is the action, the type of target is\nthe Member or User who had their message unpinned.",
            "When this is the action, the type of extra is\nset to an unspecified proxy object with two attributes:",
            "channel: A TextChannel or Object with the channel ID where the message was unpinned.",
            "message_id: the ID of the message which was unpinned.",
            "New in version 1.3.",
            "A guild integration was created.",
            "When this is the action, the type of target is\nthe Object with the integration ID of the integration which was created.",
            "New in version 1.3.",
            "A guild integration was updated.",
            "When this is the action, the type of target is\nthe Object with the integration ID of the integration which was updated.",
            "New in version 1.3.",
            "A guild integration was deleted.",
            "When this is the action, the type of target is\nthe Object with the integration ID of the integration which was deleted.",
            "New in version 1.3.",
            "A stage instance was started.",
            "When this is the action, the type of target is\nthe StageInstance or Object with the ID of the stage\ninstance which was created.",
            "Possible attributes for AuditLogDiff:",
            "topic",
            "privacy_level",
            "New in version 2.0.",
            "A stage instance was updated.",
            "When this is the action, the type of target is\nthe StageInstance or Object with the ID of the stage\ninstance which was updated.",
            "Possible attributes for AuditLogDiff:",
            "topic",
            "privacy_level",
            "New in version 2.0.",
            "A stage instance was ended.",
            "New in version 2.0.",
            "A sticker was created.",
            "When this is the action, the type of target is\nthe GuildSticker or Object with the ID of the sticker\nwhich was updated.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "emoji",
            "type",
            "format_type",
            "description",
            "available",
            "New in version 2.0.",
            "A sticker was updated.",
            "When this is the action, the type of target is\nthe GuildSticker or Object with the ID of the sticker\nwhich was updated.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "emoji",
            "type",
            "format_type",
            "description",
            "available",
            "New in version 2.0.",
            "A sticker was deleted.",
            "When this is the action, the type of target is\nthe GuildSticker or Object with the ID of the sticker\nwhich was updated.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "emoji",
            "type",
            "format_type",
            "description",
            "available",
            "New in version 2.0.",
            "A scheduled event was created.",
            "When this is the action, the type of target is\nthe ScheduledEvent or Object with the ID of the thread which\nwas deleted.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "description",
            "channel",
            "privacy_level",
            "location",
            "status",
            "type",
            "New in version 2.0.",
            "A scheduled event was updated.",
            "When this is the action, the type of target is\nthe ScheduledEvent or Object with the ID of the thread which\nwas deleted.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "description",
            "channel",
            "privacy_level",
            "location",
            "status",
            "type",
            "New in version 2.0.",
            "A scheduled event was deleted.",
            "When this is the action, the type of target is\nthe ScheduledEvent or Object with the ID of the thread which\nwas deleted.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "description",
            "channel",
            "privacy_level",
            "location",
            "status",
            "type",
            "New in version 2.0.",
            "A thread was created.",
            "When this is the action, the type of target is\nthe Thread or Object with the ID of the thread which\nwas created.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "archived",
            "locked",
            "auto_archive_duration",
            "invitable",
            "New in version 2.0.",
            "A thread was updated.",
            "When this is the action, the type of target is\nthe Thread or Object with the ID of the thread which\nwas updated.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "archived",
            "locked",
            "auto_archive_duration",
            "invitable",
            "New in version 2.0.",
            "A thread was deleted.",
            "When this is the action, the type of target is\nthe Thread or Object with the ID of the thread which\nwas deleted.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "archived",
            "locked",
            "auto_archive_duration",
            "invitable",
            "New in version 2.0.",
            "An application command’s permissions were updated.",
            "When this is the action, the type of target is\nan Object with the ID of the command that\nhad it’s permissions edited.",
            "Possible attributes for AuditLogDiff:",
            "command_id",
            "New in version 2.0.",
            "A guild auto moderation rule was created.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "enabled",
            "trigger_type",
            "event_type",
            "trigger_metadata",
            "actions",
            "exempt_roles",
            "exempt_channels",
            "New in version 2.5.",
            "A guild auto moderation rule was updated.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "enabled",
            "trigger_type",
            "trigger_metadata",
            "actions",
            "exempt_roles",
            "exempt_channels",
            "New in version 2.5.",
            "A guild auto moderation rule was deleted.",
            "Possible attributes for AuditLogDiff:",
            "name",
            "enabled",
            "trigger_type",
            "event_type",
            "trigger_metadata",
            "actions",
            "exempt_roles",
            "exempt_channels",
            "New in version 2.5.",
            "A message was blocked by auto moderation.",
            "New in version 2.5.",
            "A message was flagged by auto moderation.",
            "New in version 2.5.",
            "A member was timed out by auto moderation.",
            "New in version 2.5.",
            "A creator monetization request was created.",
            "New in version 2.5.",
            "The creator monetization terms were accepted.",
            "New in version 2.5.",
            "A voice channel status was updated.",
            "When this is the action, the type of target is\nthe VoiceChannel or Object with the ID of the voice\nchannel which was updated.",
            "Possible attributes for AuditLogDiff:",
            "status",
            "New in version 2.5.",
            "A voice channel status was deleted.",
            "When this is the action, the type of target is\nthe VoiceChannel or Object with the ID of the voice\nchannel which was updated.",
            "Possible attributes for AuditLogDiff:",
            "status",
            "New in version 2.5.",
            "Represents the category that the AuditLogAction belongs to.",
            "This can be retrieved via AuditLogEntry.category.",
            "The action is the creation of something.",
            "The action is the deletion of something.",
            "The action is the update of something.",
            "Represents the membership state of a team member retrieved through Client.application_info().",
            "New in version 1.3.",
            "Represents an invited member.",
            "Represents a member currently in the team.",
            "Represents the type of webhook that can be received.",
            "New in version 1.3.",
            "Represents a webhook that can post messages to channels with a token.",
            "Represents a webhook that is internally managed by Discord, used for following channels.",
            "Represents a webhook that is used for interactions or applications.",
            "New in version 2.0.",
            "Represents the behaviour the Integration should perform\nwhen a user’s subscription has finished.",
            "There is an alias for this called ExpireBehavior.",
            "New in version 1.4.",
            "This will remove the StreamIntegration.role from the user\nwhen their subscription is finished.",
            "This will kick the user when their subscription is finished.",
            "Represents the default avatar of a Discord User",
            "Represents the default avatar with the color blurple.\nSee also Colour.blurple",
            "Represents the default avatar with the color grey.\nSee also Colour.greyple",
            "An alias for grey.",
            "Represents the default avatar with the color green.\nSee also Colour.green",
            "Represents the default avatar with the color orange.\nSee also Colour.orange",
            "Represents the default avatar with the color red.\nSee also Colour.red",
            "Represents the type of sticker.",
            "New in version 2.0.",
            "Represents a standard sticker that all Nitro users can use.",
            "Represents a custom sticker created in a guild.",
            "Represents the type of sticker images.",
            "New in version 1.6.",
            "Represents a sticker with a png image.",
            "Represents a sticker with an apng image.",
            "Represents a sticker with a lottie image.",
            "Represents a sticker with a gif image.",
            "New in version 2.4.",
            "Represents the invite type for voice channel invites.",
            "New in version 2.0.",
            "The invite doesn’t target anyone or anything.",
            "A stream invite that targets a user.",
            "A invite that targets an embedded application.",
            "Note that your bot won’t be verified if you provide users access to this",
            "Represents the camera video quality mode for voice channel participants.",
            "New in version 2.0.",
            "Represents auto camera video quality.",
            "Represents full camera video quality.",
            "Represents a stage instance’s privacy level.\nStage event privacy levels can only have 1 possible value at the moment so\nthis shouldn’t really be used.",
            "New in version 2.0.",
            "The stage instance can only be joined by members of the guild.",
            "Alias for closed",
            "Represents the NSFW level of a guild.",
            "New in version 2.0.",
            "Checks if two NSFW levels are equal.",
            "Checks if two NSFW levels are not equal.",
            "Checks if a NSFW level is higher than another.",
            "Checks if a NSFW level is lower than another.",
            "Checks if a NSFW level is higher or equal to another.",
            "Checks if a NSFW level is lower or equal to another.",
            "The guild has not been categorised yet.",
            "The guild contains NSFW content.",
            "The guild does not contain any NSFW content.",
            "The guild may contain NSFW content.",
            "Represents an embedded activity application.",
            "Some might be boost-only or gated.",
            "Warning",
            "Discord said that they won’t verify bots who gives access to embedded activities.",
            "Read more here: https://discord.com/channels/613425648685547541/697236247739105340/901153332075315321.",
            "New in version 2.0.",
            "Represents the embedded application Ask Away.",
            "New in version 2.4.",
            "Represents the embedded application Awkword.",
            "Warning",
            "This activity has been removed.",
            "Development version of awkword.",
            "Warning",
            "This activity has been removed.",
            "Represents the embedded application Bash Out.",
            "New in version 2.4.",
            "Represents the embedded application Betrayal.io.",
            "Represents the embedded application Blazing 8s.",
            "New in version 2.4.",
            "Development version of blazing_8s.",
            "New in version 2.4.",
            "QA version of blazing_8s.",
            "New in version 2.4.",
            "Staging version of blazing_8s.",
            "New in version 2.4.",
            "Represents the embedded application Bobble League.",
            "New in version 2.4.",
            "Represents the embedded application Checkers in the Park.",
            "Development version of checkers_in_the_park.",
            "QA version of checkers_in_the_park.",
            "Staging version of checkers_in_the_park.",
            "Represents the embedded application Chess in the Park.",
            "Development version of chess_in_the_park.",
            "QA version of chess_in_the_park.",
            "Staging version of chess_in_the_park.",
            "Represents the embedded application Decoders Development.",
            "Warning",
            "This activity has been removed.",
            "Represents the embedded application Doodle Crew.",
            "Warning",
            "This activity has been removed.",
            "Development version of doodle_crew.",
            "Warning",
            "This activity has been removed.",
            "Represents the embedded application Fishington.io.",
            "Represents the embedded application Gartic Phone.",
            "New in version 2.5.",
            "Represents the embedded application Jamspace.",
            "New in version 2.5.",
            "Represents the embedded application Know What I Meme.",
            "New in version 2.4.",
            "Represents the embedded application Land.io.",
            "New in version 2.4.",
            "Represents the embedded application Letter League.",
            "Development version of letter_league.",
            "New in version 2.4.",
            "Represents the embedded application Poker Night.",
            "Development version of poker_night.",
            "New in version 2.4.",
            "QA version of poker_night.",
            "Staging version of poker_night.",
            "Represents the embedded application Putt Party.",
            "New in version 2.4.",
            "Development version of putt_party.",
            "New in version 2.4.",
            "QA version of putt_party.",
            "New in version 2.4.",
            "Staging version of putt_party.",
            "New in version 2.4.",
            "Represents the embedded application Putts.",
            "Warning",
            "This activity has been removed.",
            "Represents the embedded application Sketch Heads.",
            "New in version 2.4.",
            "Development version of sketch_heads.",
            "New in version 2.4.",
            "Represents the embedded application Sketchy Artist.",
            "Warning",
            "This activity has been removed.",
            "Development version of sketchy_artist.",
            "Warning",
            "This activity has been removed.",
            "Represents the embedded application Spell Cast.",
            "Staging version of spell_cast.",
            "New in version 2.4.",
            "Same as youtube_together with remote feature which allows guild admins to limit the playlist access.",
            "Development version of watch_together.",
            "Represents the embedded application word snacks.",
            "Development version of word_snacks.",
            "Represents the embedded application Youtube Together.",
            "Represents the status of a scheduled event.",
            "New in version 2.0.",
            "The scheduled event hasn’t started or been canceled yet.",
            "The scheduled event is in progress.",
            "The scheduled event is over.",
            "The scheduled event has been canceled before it can start.",
            "Alias to canceled.",
            "Represents a scheduled event location type (otherwise known as the entity type on the API).",
            "New in version 2.0.",
            "Represents a scheduled event that is happening in a StageChannel.",
            "Represents a scheduled event that is happening in a VoiceChannel.",
            "Represents a generic location as a str.",
            "Represents the privacy level of a scheduled event.\nScheduled event privacy levels can only have 1 possible value at the moment so\nthis shouldn’t really be used.",
            "Represents a scheduled event that is only available to members inside the guild.",
            "Represents an application role connection metadata type.",
            "Each metadata type offers a comparison operation that allows guilds to\nconfigure role requirements based on metadata values stored by the bot.\nBots specify a metadata value for each user and guilds specify the\nrequired guild's configured value within the guild role settings.",
            "New in version 2.4.",
            "The metadata value (integer) is less than or equal to the guild’s configured value (integer).",
            "The metadata value (integer) is greater than or equal to the guild’s configured value (integer).",
            "The metadata value (integer) is equal to the guild’s configured value (integer).",
            "The metadata value (integer) is not equal to the guild’s configured value (integer).",
            "The metadata value (datetime) is less than or equal to the guild’s configured value\n(integer; the number of days before the current date).",
            "The metadata value (datetime) is greater than or equal to the guild’s configured value\n(integer; the number of days before the current date).",
            "The metadata value (integer) is equal to the guild’s configured value (integer; 1).",
            "The metadata value (integer) is not equal to the guild’s configured value (integer; 1).",
            "Represents an AutoMod trigger type.",
            "New in version 2.0.",
            "Represents a keyword rule trigger, which are customizable by a guild.",
            "Possible attributes for AutoModTriggerMetadata:",
            "keyword_filter",
            "regex_patterns",
            "allow_list",
            "Represents a preset keyword rule trigger.",
            "Possible attributes for AutoModTriggerMetadata:",
            "presets",
            "allow_list",
            "Represents the spam rule trigger.",
            "There are no possible attributes for AutoModTriggerMetadata.",
            "Represents a mention spam keyword rule trigger.",
            "Possible attributes for AutoModTriggerMetadata:",
            "mention_total_limit",
            "New in version 2.4.",
            "Represents a harmful link rule trigger.",
            "Deprecated since version 2.4: Removed by Discord and merged into spam.",
            "Represents an AutoMod event type.",
            "New in version 2.0.",
            "Represents a message send AutoMod event.",
            "Represents the type of action AutoMod is performing.",
            "New in version 2.0.",
            "Represents a block message action.",
            "Represents a send alert message action.",
            "Represents a timeout action.",
            "Represents an AutoMod keyword preset type.",
            "New in version 2.0.",
            "Represents the profanity keyword preset rule.",
            "Represents the sexual content keyword preset rule.",
            "Represents the slurs keyword preset rule.",
            "Represents how each prompt’s options are displayed.",
            "New in version 2.5.",
            "The options will appear in a grid form, showing the name and description.",
            "The options will appear in a dropdown (similar to select menus), but without the description displayed. This is enforced if there are more than 12 options in the prompt.",
            "Represents the current mode of the guild’s onboarding flow.",
            "New in version 2.5.",
            "Only default channels are counted towards the Onboarding requirements.",
            "Both default channels and questions (``OnboardingPrompt``s) will count towards the Onboarding requirements.",
            "Represents a Reaction’s type.",
            "New in version 2.5.",
            "Represents a normal reaction.",
            "Represents a super reaction.",
            "Represents an SKU’s type.",
            "New in version 2.5.",
            "A one-time purchase that is permanent and is not subject to either renewal\nor consumption, such as lifetime access to an app’s premium features.",
            "A one-time, non-renewable purchase that provides access, such as a temporary\npower-up or boost in a game.",
            "Represents a recurring subscription.",
            "A system-generated group for each subscription SKU created. These types of SKUs are currently unused.",
            "Represents an entitlement’s type.",
            "New in version 2.5.",
            "Entitlement was purchased by the user.",
            "Entitlement is for a Discord Nitro subscription.",
            "Entitlement was gifted by the developer.",
            "Entitlement was purchased by a developer in the application’s test mode.",
            "Entitlement was granted when the SKU was free.",
            "Entitlement was gifted by another user.",
            "Entitlement was claimed by a user for free as a Nitro subscriber.",
            "Entitlement was purchased as an app subscription.",
            "Represents an entitlement’s ownership type.",
            "New in version 2.5.",
            "Entitlement is owned by a guild.",
            "Entitlement is owned by a user.",
            "Represents a poll’s layout type.",
            "New in version 2.6.",
            "Represents the default layout.",
            "The integration type for an application.",
            "New in version 2.6.",
            "The integration is added to a guild.",
            "The integration is added to a user account.",
            "The context where an interaction occurs.",
            "New in version 2.6.",
            "The interaction is in a guild.",
            "The interaction is in the bot’s own DM channel with the user.",
            "The interaction is in a private DM or group DM channel."
        ],
        "code": [
            "enum.Enum",
            "User",
            "Member",
            "Message",
            "Activity",
            "Interaction",
            "InteractionResponse.pong()",
            "InteractionResponse.send_message()",
            "InteractionResponse.defer()",
            "InteractionResponse.defer()",
            "InteractionResponse.edit_message()",
            "InteractionResponse.send_autocomplete_result()",
            "InteractionResponse.send_modal()",
            "ComponentType.string_select",
            "primary",
            "secondary",
            "secondary",
            "success",
            "danger",
            "link",
            "short",
            "long",
            "long",
            "Guild",
            "Guild",
            "Guild",
            "Member",
            "dnd",
            "Client.change_presence()",
            "offline",
            "AuditLogEntry",
            "Guild.audit_logs()",
            "target",
            "Guild",
            "AuditLogDiff",
            "afk_channel",
            "system_channel",
            "afk_timeout",
            "default_message_notifications",
            "explicit_content_filter",
            "mfa_level",
            "name",
            "owner",
            "splash",
            "discovery_splash",
            "icon",
            "banner",
            "vanity_url_code",
            "target",
            "abc.GuildChannel",
            "Object",
            "Object",
            "after",
            "AuditLogDiff",
            "name",
            "type",
            "overwrites",
            "target",
            "abc.GuildChannel",
            "Object",
            "Object",
            "after",
            "before",
            "AuditLogDiff",
            "name",
            "type",
            "position",
            "overwrites",
            "topic",
            "bitrate",
            "rtc_region",
            "video_quality_mode",
            "default_auto_archive_duration",
            "target",
            "Object",
            "before",
            "AuditLogDiff",
            "name",
            "type",
            "overwrites",
            "target",
            "abc.GuildChannel",
            "Object",
            "extra",
            "Role",
            "Member",
            "Object",
            "type",
            "'role'",
            "'member'",
            "AuditLogDiff",
            "deny",
            "allow",
            "id",
            "type",
            "overwrite_create",
            "target",
            "extra",
            "AuditLogDiff",
            "deny",
            "allow",
            "id",
            "type",
            "overwrite_create",
            "target",
            "extra",
            "AuditLogDiff",
            "deny",
            "allow",
            "id",
            "type",
            "target",
            "User",
            "changes",
            "target",
            "None",
            "extra",
            "delete_members_days",
            "members_removed",
            "changes",
            "target",
            "User",
            "changes",
            "target",
            "User",
            "changes",
            "target",
            "Member",
            "User",
            "AuditLogDiff",
            "nick",
            "mute",
            "deaf",
            "target",
            "Member",
            "User",
            "AuditLogDiff",
            "roles",
            "extra",
            "channel",
            "TextChannel",
            "Object",
            "count",
            "extra",
            "count",
            "target",
            "Member",
            "User",
            "target",
            "Role",
            "Object",
            "AuditLogDiff",
            "colour",
            "mentionable",
            "hoist",
            "name",
            "permissions",
            "target",
            "Role",
            "Object",
            "AuditLogDiff",
            "colour",
            "mentionable",
            "hoist",
            "name",
            "permissions",
            "target",
            "Role",
            "Object",
            "AuditLogDiff",
            "colour",
            "mentionable",
            "hoist",
            "name",
            "permissions",
            "target",
            "Invite",
            "AuditLogDiff",
            "max_age",
            "code",
            "temporary",
            "inviter",
            "channel",
            "uses",
            "max_uses",
            "target",
            "Invite",
            "target",
            "Invite",
            "AuditLogDiff",
            "max_age",
            "code",
            "temporary",
            "inviter",
            "channel",
            "uses",
            "max_uses",
            "target",
            "Object",
            "AuditLogDiff",
            "channel",
            "name",
            "type",
            "1",
            "target",
            "Object",
            "AuditLogDiff",
            "channel",
            "name",
            "avatar",
            "target",
            "Object",
            "AuditLogDiff",
            "channel",
            "name",
            "type",
            "1",
            "target",
            "Emoji",
            "Object",
            "AuditLogDiff",
            "name",
            "target",
            "Emoji",
            "Object",
            "AuditLogDiff",
            "name",
            "target",
            "Object",
            "AuditLogDiff",
            "name",
            "target",
            "Member",
            "User",
            "extra",
            "count",
            "channel",
            "TextChannel",
            "Object",
            "target",
            "TextChannel",
            "Object",
            "extra",
            "count",
            "target",
            "Member",
            "User",
            "extra",
            "channel",
            "TextChannel",
            "Object",
            "message_id",
            "target",
            "Member",
            "User",
            "extra",
            "channel",
            "TextChannel",
            "Object",
            "message_id",
            "target",
            "Object",
            "target",
            "Object",
            "target",
            "Object",
            "target",
            "StageInstance",
            "Object",
            "AuditLogDiff",
            "topic",
            "privacy_level",
            "target",
            "StageInstance",
            "Object",
            "AuditLogDiff",
            "topic",
            "privacy_level",
            "target",
            "GuildSticker",
            "Object",
            "AuditLogDiff",
            "name",
            "emoji",
            "type",
            "format_type",
            "description",
            "available",
            "target",
            "GuildSticker",
            "Object",
            "AuditLogDiff",
            "name",
            "emoji",
            "type",
            "format_type",
            "description",
            "available",
            "target",
            "GuildSticker",
            "Object",
            "AuditLogDiff",
            "name",
            "emoji",
            "type",
            "format_type",
            "description",
            "available",
            "target",
            "ScheduledEvent",
            "Object",
            "AuditLogDiff",
            "name",
            "description",
            "channel",
            "privacy_level",
            "location",
            "status",
            "type",
            "target",
            "ScheduledEvent",
            "Object",
            "AuditLogDiff",
            "name",
            "description",
            "channel",
            "privacy_level",
            "location",
            "status",
            "type",
            "target",
            "ScheduledEvent",
            "Object",
            "AuditLogDiff",
            "name",
            "description",
            "channel",
            "privacy_level",
            "location",
            "status",
            "type",
            "target",
            "Thread",
            "Object",
            "AuditLogDiff",
            "name",
            "archived",
            "locked",
            "auto_archive_duration",
            "invitable",
            "target",
            "Thread",
            "Object",
            "AuditLogDiff",
            "name",
            "archived",
            "locked",
            "auto_archive_duration",
            "invitable",
            "target",
            "Thread",
            "Object",
            "AuditLogDiff",
            "name",
            "archived",
            "locked",
            "auto_archive_duration",
            "invitable",
            "target",
            "Object",
            "AuditLogDiff",
            "command_id",
            "AuditLogDiff",
            "name",
            "enabled",
            "trigger_type",
            "event_type",
            "trigger_metadata",
            "actions",
            "exempt_roles",
            "exempt_channels",
            "AuditLogDiff",
            "name",
            "enabled",
            "trigger_type",
            "trigger_metadata",
            "actions",
            "exempt_roles",
            "exempt_channels",
            "AuditLogDiff",
            "name",
            "enabled",
            "trigger_type",
            "event_type",
            "trigger_metadata",
            "actions",
            "exempt_roles",
            "exempt_channels",
            "target",
            "VoiceChannel",
            "Object",
            "AuditLogDiff",
            "status",
            "target",
            "VoiceChannel",
            "Object",
            "AuditLogDiff",
            "status",
            "AuditLogAction",
            "AuditLogEntry.category",
            "Client.application_info()",
            "Integration",
            "ExpireBehavior",
            "StreamIntegration.role",
            "User",
            "Colour.blurple",
            "Colour.greyple",
            "grey",
            "Colour.green",
            "Colour.orange",
            "Colour.red",
            "closed",
            "awkword",
            "blazing_8s",
            "blazing_8s",
            "blazing_8s",
            "checkers_in_the_park",
            "checkers_in_the_park",
            "checkers_in_the_park",
            "chess_in_the_park",
            "chess_in_the_park",
            "chess_in_the_park",
            "doodle_crew",
            "letter_league",
            "poker_night",
            "poker_night",
            "poker_night",
            "putt_party",
            "putt_party",
            "putt_party",
            "sketch_heads",
            "sketchy_artist",
            "spell_cast",
            "youtube_together",
            "watch_together",
            "word_snacks",
            "canceled",
            "StageChannel",
            "VoiceChannel",
            "str",
            "metadata value",
            "guild's configured value",
            "integer",
            "integer",
            "integer",
            "integer",
            "integer",
            "integer",
            "integer",
            "integer",
            "datetime",
            "integer",
            "datetime",
            "integer",
            "integer",
            "integer",
            "integer",
            "integer",
            "AutoModTriggerMetadata",
            "keyword_filter",
            "regex_patterns",
            "allow_list",
            "AutoModTriggerMetadata",
            "presets",
            "allow_list",
            "AutoModTriggerMetadata",
            "AutoModTriggerMetadata",
            "mention_total_limit",
            "spam",
            "SlashCommandOptionType",
            "sub_command",
            "sub_command_group",
            "string",
            "integer",
            "boolean",
            "user",
            "channel",
            "role",
            "mentionable",
            "number",
            "attachment",
            "ChannelType",
            "text",
            "voice",
            "private",
            "group",
            "category",
            "news",
            "stage_voice",
            "news_thread",
            "public_thread",
            "private_thread",
            "directory",
            "forum",
            "MessageType",
            "default",
            "recipient_add",
            "recipient_remove",
            "call",
            "channel_name_change",
            "channel_icon_change",
            "pins_add",
            "new_member",
            "premium_guild_subscription",
            "premium_guild_tier_1",
            "premium_guild_tier_2",
            "premium_guild_tier_3",
            "channel_follow_add",
            "guild_stream",
            "guild_discovery_disqualified",
            "guild_discovery_requalified",
            "guild_discovery_grace_period_initial_warning",
            "guild_discovery_grace_period_final_warning",
            "thread_created",
            "reply",
            "application_command",
            "guild_invite_reminder",
            "thread_starter_message",
            "context_menu_command",
            "auto_moderation_action",
            "role_subscription_purchase",
            "interaction_premium_upsell",
            "stage_start",
            "stage_end",
            "stage_speaker",
            "stage_raise_hand",
            "stage_topic",
            "guild_application_premium_subscription",
            "UserFlags",
            "staff",
            "partner",
            "hypesquad",
            "bug_hunter",
            "mfa_sms",
            "premium_promo_dismissed",
            "hypesquad_bravery",
            "hypesquad_brilliance",
            "hypesquad_balance",
            "early_supporter",
            "team_user",
            "partner_or_verification_application",
            "system",
            "has_unread_urgent_messages",
            "bug_hunter_level_2",
            "underage_deleted",
            "verified_bot",
            "verified_bot_developer",
            "discord_certified_moderator",
            "bot_http_interactions",
            "spammer",
            "active_developer",
            "ActivityType",
            "unknown",
            "playing",
            "streaming",
            "listening",
            "watching",
            "custom",
            "competing",
            "InteractionType",
            "ping",
            "application_command",
            "component",
            "auto_complete",
            "modal_submit",
            "InteractionResponseType",
            "pong",
            "channel_message",
            "deferred_channel_message",
            "deferred_message_update",
            "message_update",
            "auto_complete_result",
            "modal",
            "ComponentType",
            "action_row",
            "button",
            "select",
            "string_select",
            "input_text",
            "user_select",
            "role_select",
            "mentionable_select",
            "channel_select",
            "ButtonStyle",
            "primary",
            "secondary",
            "success",
            "danger",
            "link",
            "premium",
            "blurple",
            "grey",
            "gray",
            "green",
            "red",
            "url",
            "InputTextStyle",
            "short",
            "long",
            "singleline",
            "multiline",
            "paragraph",
            "VoiceRegion",
            "amsterdam",
            "brazil",
            "dubai",
            "eu_central",
            "eu_west",
            "europe",
            "frankfurt",
            "hongkong",
            "india",
            "japan",
            "london",
            "russia",
            "singapore",
            "southafrica",
            "south_korea",
            "sydney",
            "us_central",
            "us_east",
            "us_south",
            "us_west",
            "vip_amsterdam",
            "vip_us_east",
            "vip_us_west",
            "VerificationLevel",
            "none",
            "low",
            "medium",
            "high",
            "highest",
            "NotificationLevel",
            "all_messages",
            "only_mentions",
            "ContentFilter",
            "disabled",
            "no_role",
            "all_members",
            "Status",
            "online",
            "offline",
            "idle",
            "dnd",
            "do_not_disturb",
            "invisible",
            "streaming",
            "AuditLogAction",
            "guild_update",
            "channel_create",
            "channel_update",
            "channel_delete",
            "overwrite_create",
            "overwrite_update",
            "overwrite_delete",
            "kick",
            "member_prune",
            "ban",
            "unban",
            "member_update",
            "member_role_update",
            "member_move",
            "member_disconnect",
            "bot_add",
            "role_create",
            "role_update",
            "role_delete",
            "invite_create",
            "invite_update",
            "invite_delete",
            "webhook_create",
            "webhook_update",
            "webhook_delete",
            "emoji_create",
            "emoji_update",
            "emoji_delete",
            "message_delete",
            "message_bulk_delete",
            "message_pin",
            "message_unpin",
            "integration_create",
            "integration_update",
            "integration_delete",
            "stage_instance_create",
            "stage_instance_update",
            "stage_instance_delete",
            "sticker_create",
            "sticker_update",
            "sticker_delete",
            "scheduled_event_create",
            "scheduled_event_update",
            "scheduled_event_delete",
            "thread_create",
            "thread_update",
            "thread_delete",
            "application_command_permission_update",
            "auto_moderation_rule_create",
            "auto_moderation_rule_update",
            "auto_moderation_rule_delete",
            "auto_moderation_block_message",
            "auto_moderation_flag_to_channel",
            "auto_moderation_user_communication_disabled",
            "creator_monetization_request_created",
            "creator_monetization_terms_accepted",
            "voice_channel_status_update",
            "voice_channel_status_delete",
            "AuditLogActionCategory",
            "create",
            "delete",
            "update",
            "TeamMembershipState",
            "invited",
            "accepted",
            "WebhookType",
            "incoming",
            "channel_follower",
            "application",
            "ExpireBehaviour",
            "remove_role",
            "kick",
            "DefaultAvatar",
            "blurple",
            "grey",
            "gray",
            "green",
            "orange",
            "red",
            "StickerType",
            "standard",
            "guild",
            "StickerFormatType",
            "png",
            "apng",
            "lottie",
            "gif",
            "InviteTarget",
            "unknown",
            "stream",
            "embedded_application",
            "VideoQualityMode",
            "auto",
            "full",
            "StagePrivacyLevel",
            "closed",
            "guild_only",
            "NSFWLevel",
            "default",
            "explicit",
            "safe",
            "age_restricted",
            "EmbeddedActivity",
            "ask_away",
            "awkword",
            "awkword_dev",
            "bash_out",
            "betrayal",
            "blazing_8s",
            "blazing_8s_dev",
            "blazing_8s_qa",
            "blazing_8s_staging",
            "bobble_league",
            "checkers_in_the_park",
            "checkers_in_the_park_dev",
            "checkers_in_the_park_qa",
            "checkers_in_the_park_staging",
            "chess_in_the_park",
            "chess_in_the_park_dev",
            "chess_in_the_park_qa",
            "chess_in_the_park_staging",
            "decoders_dev",
            "doodle_crew",
            "doodle_crew_dev",
            "fishington",
            "gartic_phone",
            "jamspace",
            "know_what_i_meme",
            "land",
            "letter_league",
            "letter_league_dev",
            "poker_night",
            "poker_night_dev",
            "poker_night_qa",
            "poker_night_staging",
            "putt_party",
            "putt_party_dev",
            "putt_party_qa",
            "putt_party_staging",
            "putts",
            "sketch_heads",
            "sketch_heads_dev",
            "sketchy_artist",
            "sketchy_artist_dev",
            "spell_cast",
            "spell_cast_staging",
            "watch_together",
            "watch_together_dev",
            "word_snacks",
            "word_snacks_dev",
            "youtube_together",
            "ScheduledEventStatus",
            "scheduled",
            "active",
            "completed",
            "canceled",
            "cancelled",
            "ScheduledEventLocationType",
            "stage_instance",
            "voice",
            "external",
            "ScheduledEventPrivacyLevel",
            "guild_only",
            "ApplicationRoleConnectionMetadataType",
            "integer_less_than_or_equal",
            "integer_greater_than_or_equal",
            "integer_equal",
            "integer_not_equal",
            "datetime_less_than_or_equal",
            "datetime_greater_than_or_equal",
            "boolean_equal",
            "boolean_not_equal",
            "AutoModTriggerType",
            "keyword",
            "keyword_preset",
            "spam",
            "mention_spam",
            "harmful_link",
            "AutoModEventType",
            "message_send",
            "AutoModActionType",
            "block_message",
            "send_alert_message",
            "timeout",
            "AutoModKeywordPresetType",
            "profanity",
            "sexual_content",
            "slurs",
            "PromptType",
            "multiple_choice",
            "dropdown",
            "OnboardingMode",
            "default",
            "advanced",
            "ReactionType",
            "normal",
            "burst",
            "SKUType",
            "durable",
            "consumable",
            "subscription",
            "subscription_group",
            "EntitlementType",
            "purchase",
            "premium_subscription",
            "developer_gift",
            "test_mode_purchase",
            "free_purchase",
            "user_gift",
            "premium_purchase",
            "application_subscription",
            "EntitlementOwnerType",
            "guild",
            "user",
            "PollLayoutType",
            "default",
            "IntegrationType",
            "guild_install",
            "user_install",
            "InteractionContextType",
            "guild",
            "bot_dm",
            "private_channel"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/enums.html"
    },
    {
        "title": "Audit Log Data#",
        "content": [
            "Working with Guild.audit_logs() is a complicated process with a lot of machinery\ninvolved. The library attempts to make it easy to use and friendly. In order to accomplish\nthis goal, it must make use of a couple of data classes that aid in this goal.",
            "Represents an Audit Log entry.",
            "You retrieve these via Guild.audit_logs().",
            "Checks if two entries are equal.",
            "Checks if two entries are not equal.",
            "Returns the entry’s hash.",
            "Changed in version 1.7: Audit log entries are now comparable and hashable.",
            "The action that was done.",
            "AuditLogAction",
            "The user who initiated this action. Usually a Member, unless gone\nthen it’s a User.",
            "Optional[abc.User]",
            "The entry ID.",
            "int",
            "The target that got changed. The exact type of this depends on\nthe action being done.",
            "Any",
            "The reason this action was done.",
            "Optional[str]",
            "Extra information that this entry has that might be useful.\nFor most actions, this is None. However, in some cases it\ncontains extra information. See AuditLogAction for\nwhich actions have this field filled out.",
            "Any",
            "Returns the entry’s creation time in UTC.",
            "The category of the action, if applicable.",
            "The list of changes this entry has.",
            "The target’s prior state.",
            "The target’s subsequent state.",
            "An audit log change set.",
            "The old value. The attribute has the type of AuditLogDiff.",
            "Depending on the AuditLogActionCategory retrieved by\ncategory, the data retrieved by this\nattribute differs:",
            "Category",
            "Description",
            "create",
            "All attributes are set to None.",
            "delete",
            "All attributes are set the value before deletion.",
            "update",
            "All attributes are set the value before updating.",
            "None",
            "No attributes are set.",
            "The new value. The attribute has the type of AuditLogDiff.",
            "Depending on the AuditLogActionCategory retrieved by\ncategory, the data retrieved by this\nattribute differs:",
            "Category",
            "Description",
            "create",
            "All attributes are set to the created value",
            "delete",
            "All attributes are set to None",
            "update",
            "All attributes are set the value after updating.",
            "None",
            "No attributes are set.",
            "Represents an audit log “change” object. A change object has dynamic\nattributes that depend on the type of action being done. Certain actions\nmap to certain attributes being set.",
            "Note that accessing an attribute that does not match the specified action\nwill lead to an attribute error.",
            "To get a list of attributes that have been set, you can iterate over\nthem. To see a list of all possible attributes that could be set based\non the action being done, check the documentation for AuditLogAction,\notherwise check the documentation below for all attributes that are possible.",
            "Returns an iterator over (attribute, value) tuple of this diff.",
            "A name of something.",
            "str",
            "A guild’s icon. See also Guild.icon.",
            "Asset",
            "The guild’s invite splash. See also Guild.splash.",
            "Asset",
            "The guild’s discovery splash. See also Guild.discovery_splash.",
            "Asset",
            "The guild’s banner. See also Guild.banner.",
            "Asset",
            "The guild’s owner. See also Guild.owner",
            "Union[Member, User]",
            "The guild’s AFK channel.",
            "If this could not be found, then it falls back to a Object\nwith the ID being set.",
            "See Guild.afk_channel.",
            "Union[VoiceChannel, Object]",
            "The guild’s system channel.",
            "If this could not be found, then it falls back to a Object\nwith the ID being set.",
            "See Guild.system_channel.",
            "Union[TextChannel, Object]",
            "The guild’s rules channel.",
            "If this could not be found then it falls back to a Object\nwith the ID being set.",
            "See Guild.rules_channel.",
            "Union[TextChannel, Object]",
            "The guild’s public updates channel.",
            "If this could not be found then it falls back to a Object\nwith the ID being set.",
            "See Guild.public_updates_channel.",
            "Union[TextChannel, Object]",
            "The guild’s AFK timeout. See Guild.afk_timeout.",
            "int",
            "The guild’s MFA level. See Guild.mfa_level.",
            "int",
            "The guild’s widget has been enabled or disabled.",
            "bool",
            "The widget’s channel.",
            "If this could not be found then it falls back to a Object\nwith the ID being set.",
            "Union[TextChannel, Object]",
            "The guild’s verification level.",
            "See also Guild.verification_level.",
            "VerificationLevel",
            "The guild’s default notification level.",
            "See also Guild.default_notifications.",
            "NotificationLevel",
            "The guild’s content filter.",
            "See also Guild.explicit_content_filter.",
            "ContentFilter",
            "The guild’s default message notification setting.",
            "int",
            "The guild’s vanity URL.",
            "See also Guild.vanity_invite() and Guild.edit().",
            "str",
            "The position of a Role or abc.GuildChannel.",
            "int",
            "The type of channel or sticker.",
            "Union[ChannelType, StickerType]",
            "The topic of a TextChannel or StageChannel.",
            "See also TextChannel.topic or StageChannel.topic.",
            "str",
            "The bitrate of a VoiceChannel.",
            "See also VoiceChannel.bitrate.",
            "int",
            "A list of permission overwrite tuples that represents a target and a\nPermissionOverwrite for said target.",
            "The first element is the object being targeted, which can either\nbe a Member or User or Role. If this object\nis not found then it is a Object with an ID being filled and\na type attribute set to either 'role' or 'member' to help\ndecide what type of ID it is.",
            "List[Tuple[target, PermissionOverwrite]]",
            "The privacy level of the stage instance or scheduled event.",
            "Union[StagePrivacyLevel, ScheduledEventPrivacyLevel]",
            "A list of roles being added or removed from a member.",
            "If a role is not found then it is a Object with the ID and name being\nfilled in.",
            "List[Union[Role, Object]]",
            "The nickname of a member.",
            "See also Member.nick",
            "Optional[str]",
            "Whether the member is being server deafened.",
            "See also VoiceState.deaf.",
            "bool",
            "Whether the member is being server muted.",
            "See also VoiceState.mute.",
            "bool",
            "The permissions of a role.",
            "See also Role.permissions.",
            "Permissions",
            "The colour of a role.",
            "See also Role.colour",
            "Colour",
            "Whether the role is being hoisted or not.",
            "See also Role.hoist",
            "bool",
            "Whether the role is mentionable or not.",
            "See also Role.mentionable",
            "bool",
            "The invite’s code.",
            "See also Invite.code",
            "str",
            "A guild channel.",
            "If the channel is not found then it is a Object with the ID\nbeing set. In some cases the channel name is also set.",
            "Union[abc.GuildChannel, Object]",
            "The user who created the invite.",
            "See also Invite.inviter.",
            "Optional[User]",
            "The invite’s max uses.",
            "See also Invite.max_uses.",
            "int",
            "The invite’s current uses.",
            "See also Invite.uses.",
            "int",
            "The invite’s max age in seconds.",
            "See also Invite.max_age.",
            "int",
            "If the invite is a temporary invite.",
            "See also Invite.temporary.",
            "bool",
            "The permissions being allowed or denied.",
            "Permissions",
            "The ID of the object being changed.",
            "int",
            "The avatar of a member.",
            "See also User.avatar.",
            "Asset",
            "The number of seconds members have to wait before\nsending another message in the channel.",
            "See also TextChannel.slowmode_delay.",
            "int",
            "The region for the voice channel’s voice communication.\nA value of None indicates automatic voice region detection.",
            "See also VoiceChannel.rtc_region.",
            "VoiceRegion",
            "The camera video quality for the voice channel’s participants.",
            "See also VoiceChannel.video_quality_mode.",
            "VideoQualityMode",
            "The format type of a sticker being changed.",
            "See also GuildSticker.format",
            "StickerFormatType",
            "The name of the emoji that represents a sticker being changed.",
            "See also GuildSticker.emoji",
            "str",
            "The description of a sticker being changed.",
            "See also GuildSticker.description",
            "str",
            "The availability of a sticker being changed.",
            "See also GuildSticker.available",
            "bool",
            "The thread is now archived.",
            "bool",
            "The thread is being locked or unlocked.",
            "bool",
            "The thread’s auto archive duration being changed.",
            "See also Thread.auto_archive_duration",
            "int",
            "The default auto archive duration for newly created threads being changed.",
            "int",
            "Non-moderators can now add other non-moderators to this thread.",
            "bool",
            "This command’s permissions were updated.",
            "int",
            "The voice channel status of a VoiceChannel.",
            "See also VoiceChannel.status.",
            "str"
        ],
        "code": [
            "Guild.audit_logs()",
            "Guild.audit_logs()",
            "AuditLogAction",
            "Member",
            "User",
            "abc.User",
            "int",
            "str",
            "None",
            "AuditLogAction",
            "AuditLogDiff",
            "AuditLogActionCategory",
            "category",
            "create",
            "None",
            "delete",
            "update",
            "None",
            "AuditLogDiff",
            "AuditLogActionCategory",
            "category",
            "create",
            "delete",
            "None",
            "update",
            "None",
            "AuditLogAction",
            "str",
            "Guild.icon",
            "Asset",
            "Guild.splash",
            "Asset",
            "Guild.discovery_splash",
            "Asset",
            "Guild.banner",
            "Asset",
            "Guild.owner",
            "Member",
            "User",
            "Object",
            "Guild.afk_channel",
            "VoiceChannel",
            "Object",
            "Object",
            "Guild.system_channel",
            "TextChannel",
            "Object",
            "Object",
            "Guild.rules_channel",
            "TextChannel",
            "Object",
            "Object",
            "Guild.public_updates_channel",
            "TextChannel",
            "Object",
            "Guild.afk_timeout",
            "int",
            "Guild.mfa_level",
            "int",
            "bool",
            "Object",
            "TextChannel",
            "Object",
            "Guild.verification_level",
            "VerificationLevel",
            "Guild.default_notifications",
            "NotificationLevel",
            "Guild.explicit_content_filter",
            "ContentFilter",
            "int",
            "Guild.vanity_invite()",
            "Guild.edit()",
            "str",
            "Role",
            "abc.GuildChannel",
            "int",
            "ChannelType",
            "StickerType",
            "TextChannel",
            "StageChannel",
            "TextChannel.topic",
            "StageChannel.topic",
            "str",
            "VoiceChannel",
            "VoiceChannel.bitrate",
            "int",
            "PermissionOverwrite",
            "Member",
            "User",
            "Role",
            "Object",
            "type",
            "'role'",
            "'member'",
            "PermissionOverwrite",
            "StagePrivacyLevel",
            "ScheduledEventPrivacyLevel",
            "Object",
            "Role",
            "Object",
            "Member.nick",
            "str",
            "VoiceState.deaf",
            "bool",
            "VoiceState.mute",
            "bool",
            "Role.permissions",
            "Permissions",
            "Role.colour",
            "Colour",
            "Role.hoist",
            "bool",
            "Role.mentionable",
            "bool",
            "Invite.code",
            "str",
            "Object",
            "abc.GuildChannel",
            "Object",
            "Invite.inviter",
            "User",
            "Invite.max_uses",
            "int",
            "Invite.uses",
            "int",
            "Invite.max_age",
            "int",
            "Invite.temporary",
            "bool",
            "Permissions",
            "int",
            "User.avatar",
            "Asset",
            "TextChannel.slowmode_delay",
            "int",
            "None",
            "VoiceChannel.rtc_region",
            "VoiceRegion",
            "VoiceChannel.video_quality_mode",
            "VideoQualityMode",
            "GuildSticker.format",
            "StickerFormatType",
            "GuildSticker.emoji",
            "str",
            "GuildSticker.description",
            "str",
            "GuildSticker.available",
            "bool",
            "bool",
            "bool",
            "Thread.auto_archive_duration",
            "int",
            "int",
            "bool",
            "int",
            "VoiceChannel",
            "VoiceChannel.status",
            "str",
            "AuditLogEntry",
            "action",
            "user",
            "id",
            "target",
            "reason",
            "extra",
            "created_at",
            "category",
            "changes",
            "before",
            "after",
            "AuditLogChanges",
            "before",
            "after",
            "AuditLogDiff",
            "name",
            "icon",
            "splash",
            "discovery_splash",
            "banner",
            "owner",
            "afk_channel",
            "system_channel",
            "rules_channel",
            "public_updates_channel",
            "afk_timeout",
            "mfa_level",
            "widget_enabled",
            "widget_channel",
            "verification_level",
            "default_notifications",
            "explicit_content_filter",
            "default_message_notifications",
            "vanity_url_code",
            "position",
            "type",
            "topic",
            "bitrate",
            "overwrites",
            "privacy_level",
            "roles",
            "nick",
            "deaf",
            "mute",
            "permissions",
            "colour",
            "color",
            "hoist",
            "mentionable",
            "code",
            "channel",
            "inviter",
            "max_uses",
            "uses",
            "max_age",
            "temporary",
            "allow",
            "deny",
            "id",
            "avatar",
            "slowmode_delay",
            "rtc_region",
            "video_quality_mode",
            "format_type",
            "emoji",
            "description",
            "available",
            "archived",
            "locked",
            "auto_archive_duration",
            "default_auto_archive_duration",
            "invitable",
            "command_id",
            "status"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/audit_logs.html"
    },
    {
        "title": "API Reference#",
        "content": [
            "The reference manual that follows details the API of Pycord’s bridge command extension module.",
            "Note",
            "Using the prefixed command version (which uses the ext.commands extension) of bridge\ncommands in guilds requires Intents.message_context to be enabled."
        ],
        "code": [
            "ext.commands",
            "Intents.message_context"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "Bots#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "Bot#",
        "content": [
            "Represents a discord bot, with support for cross-compatibility between command types.",
            "This class is a subclass of ext.commands.Bot and as a result\nanything that you can do with a ext.commands.Bot you can do with\nthis bot.",
            "New in version 2.0.",
            "command_prefix (str | Iterable[str] | Callable[[Bot | AutoShardedBot, Message], str | Iterable[str] | Coroutine[Any, Any, str | Iterable[str]]]) –",
            "help_command (HelpCommand | None) –",
            "Takes a BridgeCommand and adds both a slash and traditional (prefix-based) version of the command\nto the bot.",
            "command (BridgeCommand) –",
            "A shortcut decorator that invokes bridge_command() and adds it to\nthe internal command list via add_bridge_command().",
            "A decorator that converts the provided method into an BridgeCommand, adds both a slash and\ntraditional (prefix-based) version of the command to the bot, and returns the BridgeCommand.",
            "Callable[…, BridgeCommand]",
            "A decorator that is used to wrap a function as a bridge command group.",
            "kwargs (Optional[Dict[str, Any]]) – Keyword arguments that are directly passed to the respective command constructors. (SlashCommandGroup and ext.commands.Group)"
        ],
        "code": [
            "ext.commands.Bot",
            "ext.commands.Bot",
            "BridgeCommand",
            "BridgeCommand",
            "bridge_command()",
            "add_bridge_command()",
            "BridgeCommand",
            "BridgeCommand",
            "BridgeCommand",
            "str",
            "SlashCommandGroup",
            "ext.commands.Group"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "AutoShardedBot#",
        "content": [
            "This is similar to Bot except that it is inherited from\next.commands.AutoShardedBot instead.",
            "New in version 2.0.",
            "command_prefix (str | Iterable[str] | Callable[[Bot | AutoShardedBot, Message], str | Iterable[str] | Coroutine[Any, Any, str | Iterable[str]]]) –",
            "help_command (HelpCommand | None) –"
        ],
        "code": [
            "Bot",
            "ext.commands.AutoShardedBot"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "Event Reference#",
        "content": [
            "These events function similar to the regular events, except they\nare custom to the bridge extension module.",
            "An error handler that is called when an error is raised\ninside a command either through user input error, check\nfailure, or an error in your own code.",
            "ctx (Context) – The invocation context.",
            "error (CommandError derived) – The error that was raised.",
            "An event that is called when a command is found and is about to be invoked.",
            "This event is called regardless of whether the command itself succeeds via\nerror or completes.",
            "ctx (Context) – The invocation context.",
            "An event that is called when a command has completed its invocation.",
            "This event is called only if the command succeeded, i.e. all checks have\npassed and users input them correctly.",
            "ctx (Context) – The invocation context."
        ],
        "code": [
            "Context",
            "CommandError",
            "Context",
            "Context"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "Commands#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "BridgeCommand#",
        "content": [
            "Compatibility class between prefixed-based commands and slash commands.",
            "callback (Callable[[BridgeContext, …], Awaitable[Any]]) – The callback to invoke when the command is executed. The first argument will be a BridgeContext,\nand any additional arguments will be passed to the callback. This callback must be a coroutine.",
            "parent (Optional[BridgeCommandGroup]:) – Parent of the BridgeCommand.",
            "kwargs (Optional[Dict[str, Any]]) – Keyword arguments that are directly passed to the respective command constructors. (SlashCommand and ext.commands.Command)",
            "The slash command version of this bridge command.",
            "BridgeSlashCommand",
            "The prefix-based version of this bridge command.",
            "BridgeExtCommand",
            "Returns name_localizations from slash_variant\nYou can edit/set name_localizations directly with\n.. code-block:: python3",
            "bridge_command.name_localizations[“en-UK”] = …  # or any other locale\n# or\nbridge_command.name_localizations = {“en-UK”: …, “fr-FR”: …}",
            "Returns description_localizations from slash_variant\nYou can edit/set description_localizations directly with\n.. code-block:: python3",
            "bridge_command.description_localizations[“en-UK”] = …  # or any other locale\n# or\nbridge_command.description_localizations = {“en-UK”: …, “fr-FR”: …}",
            "Adds the command to a bot. This method is inherited by BridgeCommandGroup.",
            "bot (Union[Bot, AutoShardedBot]) – The bot to add the command to.",
            "None",
            "A decorator that registers a coroutine as a local error handler.",
            "This error handler is limited to the command it is defined to.\nHowever, higher scope handlers (per-cog and global) are still\ninvoked afterwards as a catch-all. This handler also functions as\nthe handler for both the prefixed and slash versions of the command.",
            "This error handler takes two parameters, a BridgeContext and\na DiscordException.",
            "coro (coroutine) – The coroutine to register as the local error handler.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "A decorator that registers a coroutine as a pre-invoke hook.",
            "This hook is called directly before the command is called, making\nit useful for any sort of set up required. This hook is called\nfor both the prefixed and slash versions of the command.",
            "This pre-invoke hook takes a sole parameter, a BridgeContext.",
            "coro (coroutine) – The coroutine to register as the pre-invoke hook.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "A decorator that registers a coroutine as a post-invoke hook.",
            "This hook is called directly after the command is called, making it\nuseful for any sort of clean up required. This hook is called for\nboth the prefixed and slash versions of the command.",
            "This post-invoke hook takes a sole parameter, a BridgeContext.",
            "coro (coroutine) – The coroutine to register as the post-invoke hook.",
            "TypeError – The coroutine passed is not actually a coroutine."
        ],
        "code": [
            "BridgeContext",
            "BridgeContext",
            "BridgeCommandGroup",
            "str",
            "SlashCommand",
            "ext.commands.Command",
            "BridgeSlashCommand",
            "BridgeExtCommand",
            "slash_variant",
            "slash_variant",
            "BridgeCommandGroup",
            "Bot",
            "AutoShardedBot",
            "None",
            "BridgeContext",
            "DiscordException",
            "BridgeContext",
            "BridgeContext"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "BridgeCommandGroup#",
        "content": [
            "Compatibility class between prefixed-based commands and slash commands.",
            "callback (Callable[[BridgeContext, …], Awaitable[Any]]) – The callback to invoke when the command is executed. The first argument will be a BridgeContext,\nand any additional arguments will be passed to the callback. This callback must be a coroutine.",
            "kwargs (Optional[Dict[str, Any]]) – Keyword arguments that are directly passed to the respective command constructors. (SlashCommand and ext.commands.Command)",
            "The slash command version of this command group.",
            "SlashCommandGroup",
            "The prefix-based version of this command group.",
            "ext.commands.Group",
            "List of bridge commands in this group",
            "List[BridgeCommand]",
            "If map_to() is used, the mapped slash command.",
            "Optional[SlashCommand]",
            "An iterator that recursively walks through all the bridge group’s subcommands.",
            "BridgeCommand – A bridge command of this bridge group.",
            "A decorator to register a function as a subcommand.",
            "kwargs (Optional[Dict[str, Any]]) – Keyword arguments that are directly passed to the respective command constructors. (SlashCommand and ext.commands.Command)"
        ],
        "code": [
            "BridgeContext",
            "BridgeContext",
            "str",
            "SlashCommand",
            "ext.commands.Command",
            "SlashCommandGroup",
            "ext.commands.Group",
            "BridgeCommand",
            "map_to()",
            "SlashCommand",
            "BridgeCommand",
            "str",
            "SlashCommand",
            "ext.commands.Command"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "Decorators#",
        "content": [
            "A decorator that is used to wrap a function as a bridge command.",
            "kwargs (Optional[Dict[str, Any]]) – Keyword arguments that are directly passed to the respective command constructors. (SlashCommand and ext.commands.Command)",
            "A decorator that is used to wrap a function as a bridge command group.",
            "kwargs (Optional[Dict[str, Any]]) – Keyword arguments that are directly passed to the respective command constructors (SlashCommandGroup and ext.commands.Group).",
            "To be used with bridge command groups, map the main command to a slash subcommand.",
            "name (str) – The new name of the mapped command.",
            "description (Optional[str]) – The new description of the mapped command.",
            "Example",
            "Prefixed commands will not be affected, but slash commands will appear as:",
            "Intended to work with ApplicationCommand and BridgeCommand, adds a check()\nthat locks the command to only run in guilds, and also registers the command as guild only client-side (on discord).",
            "Basically a utility function that wraps both discord.ext.commands.guild_only() and discord.commands.guild_only().",
            "Intended to work with ApplicationCommand and BridgeCommand, adds a check()\nthat locks the command to only run in nsfw contexts, and also registers the command as nsfw client-side (on discord).",
            "Basically a utility function that wraps both discord.ext.commands.is_nsfw() and discord.commands.is_nsfw().",
            "Warning",
            "In DMs, the prefixed-based command will always run as the user’s privacy settings cannot be checked directly.",
            "Intended to work with SlashCommand and BridgeCommand, adds a\ncheck() that locks the command to be run by people with certain\npermissions inside guilds, and also registers the command as locked behind said permissions.",
            "Basically a utility function that wraps both discord.ext.commands.has_permissions()\nand discord.commands.default_permissions().",
            "**perms (Dict[str, bool]) – An argument list of permissions to check for."
        ],
        "code": [
            "str",
            "SlashCommand",
            "ext.commands.Command",
            "str",
            "SlashCommandGroup",
            "ext.commands.Group",
            "str",
            "str",
            "@bot.bridge_group()\n@bridge.map_to(\"show\")\nasync def config(ctx: BridgeContext):\n    ...\n\n@config.command()\nasync def toggle(ctx: BridgeContext):\n    ...",
            "/config show\n/config toggle",
            "ApplicationCommand",
            "BridgeCommand",
            "check()",
            "discord.ext.commands.guild_only()",
            "discord.commands.guild_only()",
            "ApplicationCommand",
            "BridgeCommand",
            "check()",
            "discord.ext.commands.is_nsfw()",
            "discord.commands.is_nsfw()",
            "SlashCommand",
            "BridgeCommand",
            "check()",
            "discord.ext.commands.has_permissions()",
            "discord.commands.default_permissions()",
            "str",
            "bool"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "Command Subclasses#",
        "content": [
            "A subclass of ext.commands.Command that is used for bridge commands.",
            "A subclass of ext.commands.Group that is used for bridge commands.",
            "A subclass of SlashCommand that is used for bridge commands.",
            "A subclass of SlashCommandGroup that is used for bridge commands."
        ],
        "code": [
            "ext.commands.Command",
            "ext.commands.Group",
            "SlashCommand",
            "SlashCommandGroup"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "Context#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "BridgeContext#",
        "content": [
            "The base context class for compatibility commands. This class is an abstract base class (also known as an\nabc), which is subclassed by BridgeExtContext and BridgeApplicationContext. The methods in\nthis class are meant to give parity between the two contexts, while still allowing for all of their functionality.",
            "When this is passed to a command, it will either be passed as BridgeExtContext, or\nBridgeApplicationContext. Since they are two separate classes, it’s easy to use the BridgeContext.is_app attribute.\nto make different functionality for each context. For example, if you want to respond to a command with the command\ntype that it was invoked with, you can do the following:",
            "New in version 2.0.",
            "Helper for @overload to raise when called.",
            "This function is a coroutine.",
            "Responds to the command with the respective response type to the current context. In BridgeExtContext,\nthis will be reply() while in BridgeApplicationContext, this will be\nrespond().",
            "Interaction | WebhookMessage | Message",
            "This function is a coroutine.",
            "Alias for respond().",
            "Interaction | WebhookMessage | Message",
            "This function is a coroutine.",
            "Defers the command with the respective approach to the current context. In BridgeExtContext, this will\nbe trigger_typing() while in BridgeApplicationContext, this will be\ndefer.\n:rtype: None",
            "Note",
            "There is no trigger_typing alias for this method. trigger_typing will always provide the same\nfunctionality across contexts.",
            "This function is a coroutine.",
            "Edits the original response message with the respective approach to the current context. In\nBridgeExtContext, this will have a custom approach where respond() caches the message to be\nedited here. In BridgeApplicationContext, this will be edit.",
            "InteractionMessage | Message",
            "Whether the context is an BridgeApplicationContext or not."
        ],
        "code": [
            "abc",
            "BridgeExtContext",
            "BridgeApplicationContext",
            "BridgeExtContext",
            "BridgeApplicationContext",
            "BridgeContext.is_app",
            "@bot.bridge_command()\nasync def example(ctx: BridgeContext):\n    if ctx.is_app:\n        command_type = \"Application command\"\n    else:\n        command_type = \"Traditional (prefix-based) command\"\n    await ctx.send(f\"This command was invoked with a(n) {command_type}.\")",
            "BridgeExtContext",
            "reply()",
            "BridgeApplicationContext",
            "respond()",
            "respond()",
            "BridgeExtContext",
            "trigger_typing()",
            "BridgeApplicationContext",
            "defer",
            "None",
            "trigger_typing",
            "trigger_typing",
            "BridgeExtContext",
            "respond()",
            "BridgeApplicationContext",
            "edit",
            "BridgeApplicationContext"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "BridgeContext Subclasses#",
        "content": [
            "The application context class for compatibility commands. This class is a subclass of BridgeContext and\nApplicationContext. This class is meant to be used with BridgeCommand.",
            "New in version 2.0.",
            "The ext.commands context class for compatibility commands. This class is a subclass of BridgeContext and\nContext. This class is meant to be used with BridgeCommand.",
            "New in version 2.0.",
            "This function is a coroutine.",
            "Deletes the original response message, if it exists.",
            "delay (Optional[float]) – If provided, the number of seconds to wait before deleting the message.",
            "reason (Optional[str]) – The reason for deleting the message. Shows up on the audit log.",
            "None",
            "alias of Union[BridgeExtContext, BridgeApplicationContext]"
        ],
        "code": [
            "BridgeContext",
            "ApplicationContext",
            "BridgeCommand",
            "BridgeContext",
            "Context",
            "BridgeCommand",
            "float",
            "str",
            "Union",
            "BridgeExtContext",
            "BridgeApplicationContext"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "Option#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "BridgeOption#",
        "content": [
            "A subclass of discord.Option which represents a selectable slash\ncommand option and a prefixed command argument for bridge commands.",
            "input_type (InputType) –",
            "description (str | None) –",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "Any"
        ],
        "code": [
            "discord.Option",
            "CommandError",
            "Context",
            "str",
            "Any",
            "Bot",
            "add_bridge_command()",
            "bridge_command()",
            "bridge_group()",
            "AutoShardedBot",
            "on_bridge_command_error()",
            "on_bridge_command()",
            "on_bridge_command_completion()",
            "BridgeCommand",
            "slash_variant",
            "ext_variant",
            "name_localizations",
            "description_localizations",
            "add_to()",
            "error()",
            "before_invoke()",
            "after_invoke()",
            "BridgeCommandGroup",
            "slash_variant",
            "ext_variant",
            "subcommands",
            "mapped",
            "walk_commands()",
            "command()",
            "bridge_command()",
            "bridge_group()",
            "map_to()",
            "guild_only()",
            "is_nsfw()",
            "has_permissions()",
            "BridgeExtCommand",
            "BridgeExtGroup",
            "BridgeSlashCommand",
            "BridgeSlashGroup",
            "BridgeContext",
            "invoke()",
            "respond()",
            "reply()",
            "defer()",
            "edit()",
            "is_app",
            "BridgeApplicationContext",
            "BridgeExtContext",
            "delete()",
            "Context",
            "BridgeOption",
            "convert()"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/bridge/api.html"
    },
    {
        "title": "API Reference#",
        "content": [
            "The following section outlines the API of Pycord’s prefixed command extension module.",
            "Note",
            "Using prefixed commands in guilds requires Intents.message_content to be enabled."
        ],
        "code": [
            "Intents.message_content"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Bots#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Bot#",
        "content": [
            "Represents a discord bot.",
            "This class is a subclass of discord.Bot and as a result\nanything that you can do with a discord.Bot you can do with\nthis bot.",
            "This class also subclasses GroupMixin to provide the functionality\nto manage commands.",
            "Note",
            "Using prefixed commands requires discord.Intents.message_content to be enabled.",
            "The command prefix is what the message content must contain initially\nto have a command invoked. This prefix could either be a string to\nindicate what the prefix should be, or a callable that takes in the bot\nas its first parameter and discord.Message as its second\nparameter and returns the prefix. This is to facilitate “dynamic”\ncommand prefixes. This callable can be either a regular function or\na coroutine.",
            "An empty string as the prefix always matches, enabling prefix-less\ncommand invocation. While this may be useful in DMs it should be avoided\nin servers, as it’s likely to cause performance issues and unintended\ncommand invocations.",
            "The command prefix could also be an iterable of strings indicating that\nmultiple checks for the prefix should be used and the first one to\nmatch will be the invocation prefix. You can get this prefix via\nContext.prefix. To avoid confusion empty iterables are not\nallowed.",
            "Note",
            "When passing multiple prefixes be careful to not pass a prefix\nthat matches a longer prefix occurring later in the sequence.  For\nexample, if the command prefix is ('!', '!?')  the '!?'\nprefix will never be matched to any message as the previous one\nmatches messages starting with !?. This is especially important\nwhen passing an empty string, it should always be last as no prefix\nafter it will be matched.",
            "Whether the commands should be case-insensitive. Defaults to False. This\nattribute does not carry over to groups. You must set it to every group if\nyou require group commands to be case-insensitive as well.",
            "bool",
            "The help command implementation to use. This can be dynamically\nset at runtime. To remove the help command pass None. For more\ninformation on implementing a help command, see Help Commands.",
            "Optional[HelpCommand]",
            "Whether to strip whitespace characters after encountering the command\nprefix. This allows for !   hello and !hello to both work if\nthe command_prefix is set to !. Defaults to False.",
            "New in version 1.7.",
            "bool",
            "command_prefix (str | Iterable[str] | Callable[[Bot | AutoShardedBot, Message], str | Iterable[str] | Coroutine[Any, Any, str | Iterable[str]]]) –",
            "help_command (HelpCommand | None) –",
            "A decorator that registers a coroutine as a post-invoke hook.\nA post-invoke hook is called directly after the command is\ncalled. This makes it a useful function to clean-up database\nconnections or any type of clean up required.\nThis post-invoke hook takes a sole parameter, a Context.",
            "Note",
            "Similar to before_invoke(), this is not called unless\nchecks and argument parsing procedures succeed. This hook is,\nhowever, always called regardless of the internal command\ncallback raising an error (i.e. CommandInvokeError).\nThis makes it ideal for clean-up scenarios.",
            "coro (coroutine) – The coroutine to register as the post-invoke hook.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "A decorator that registers a coroutine as a pre-invoke hook.\nA pre-invoke hook is called directly before the command is\ncalled. This makes it a useful function to set up database\nconnections or any type of set up required.\nThis pre-invoke hook takes a sole parameter, a Context.",
            "Note",
            "The before_invoke() and after_invoke() hooks are\nonly called if all checks and argument parsing procedures pass\nwithout error. If any check or argument parsing procedures fail\nthen the hooks are not called.",
            "coro (coroutine) – The coroutine to register as the pre-invoke hook.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "A decorator that adds a global check to the bot. A global check is similar to a check() that is\napplied on a per-command basis except it is run before any command checks have been verified and applies to\nevery command the bot has.",
            "Note",
            "This function can either be a regular function or a coroutine. Similar to a command check(), this\ntakes a single parameter of type Context and can only raise exceptions inherited from\nApplicationCommandError.",
            "Example",
            "A decorator that adds a “call once” global check to the bot. Unlike regular global checks, this one is called\nonly once per Bot.invoke() call. Regular global checks are called whenever a command is called or\nCommand.can_run() is called. This type of check bypasses that and ensures that it’s called only once,\neven inside the default help command.",
            "Note",
            "When using this function the Context sent to a group subcommand may only parse the parent command\nand not the subcommands due to it being invoked once per Bot.invoke() call.",
            "Note",
            "This function can either be a regular function or a coroutine. Similar to a command check(),\nthis takes a single parameter of type Context and can only raise exceptions inherited from\nApplicationCommandError.",
            "Example",
            "A shortcut decorator that invokes command() and adds it to\nthe internal command list via add_command().",
            "A decorator that converts the provided method into a Command, adds it to the bot, then returns it.",
            "Callable[…, Command]",
            "A decorator that registers an event to listen to.",
            "You can find more info about the events on the documentation below.",
            "The events must be a coroutine, if not, TypeError is raised.",
            "Note",
            "This replaces any default handlers.\nDevelopers are encouraged to use listen() for adding additional handlers\ninstead of event() unless default method replacement is intended.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "Example",
            "coro (TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])) –",
            "TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])",
            "A shortcut decorator that invokes group() and adds it to\nthe internal command list via add_command().",
            "A decorator that converts the provided method into a Group, adds it to the bot, then returns it.",
            "Callable[…, Group]",
            "A decorator that registers another function as an external\nevent listener. Basically this allows you to listen to multiple\nevents from different places e.g. such as on_ready()",
            "The functions being listened to must be a coroutine.",
            "TypeError – The function being listened to is not a coroutine.",
            "ValueError – The name (event name) does not start with ‘on_’",
            "Example",
            "Would print one and two in an unspecified order.",
            "name (str) –",
            "once (bool) –",
            "Callable[[TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])], TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])]",
            "The activity being used upon logging in.",
            "Optional[BaseActivity]",
            "Adds an ApplicationCommand into the internal list of commands.",
            "This is usually not called, instead the command() or\nother shortcut decorators are used instead.",
            "New in version 2.0.",
            "command (ApplicationCommand) – The command to add.",
            "None",
            "Adds a global check to the bot. This is the non-decorator interface to check() and\ncheck_once().",
            "func – The function that was used as a global check.",
            "call_once (bool) – If the function should only be called once per Bot.invoke() call.",
            "None",
            "Adds a “cog” to the bot.",
            "A cog is a class that has its own event listeners and commands.",
            "Changed in version 2.0: ClientException is raised when a cog with the same name\nis already loaded.",
            "cog (Cog) – The cog to register to the bot.",
            "override (bool) – If a previously loaded cog with the same name should be ejected\ninstead of raising an error.\n\nNew in version 2.0.",
            "If a previously loaded cog with the same name should be ejected\ninstead of raising an error.",
            "New in version 2.0.",
            "TypeError – The cog does not inherit from Cog.",
            "ApplicationCommandError – An error happened during loading.",
            "ClientException – A cog with the same name is already loaded.",
            "None",
            "Adds a Command into the internal list of commands.",
            "This is usually not called, instead the command() or\ngroup() shortcut decorators are used instead.",
            "Changed in version 1.4: Raise CommandRegistrationError instead of generic ClientException",
            "command (Command) – The command to add.",
            ".CommandRegistrationError – If the command or its alias is already registered by different command.",
            "TypeError – If the command passed is not a subclass of Command.",
            "None",
            "The non decorator alternative to listen().",
            "func (coroutine) – The function to call.",
            "name (str) – The name of the event to listen for. Defaults to func.__name__.",
            "TypeError – The func parameter is not a coroutine function.",
            "ValueError – The name (event name) does not start with ‘on_’",
            "None",
            "Example",
            "Registers a View for persistent listening.",
            "This method should be used for when a view is comprised of components\nthat last longer than the lifecycle of the program.",
            "New in version 2.0.",
            "view (discord.ui.View) – The view to register for dispatching.",
            "message_id (Optional[int]) – The message ID that the view is attached to. This is currently used to\nrefresh the view’s state during message update events. If not given\nthen message update events are not propagated for the view.",
            "TypeError – A view was not passed.",
            "ValueError – The view is not persistent. A persistent view has no timeout\n    and all their components have an explicitly provided custom_id.",
            "None",
            "The allowed mention configuration.",
            "New in version 1.4.",
            "A shortcut decorator that invokes command() and adds it to\nthe internal command list via add_application_command().",
            "New in version 2.0.",
            "A decorator that converts the provided method into an ApplicationCommand, adds it to the bot,\nthen returns it.",
            "Callable[…, ApplicationCommand]",
            "The client’s application flags.",
            "New in version 2.0.",
            "The client’s application ID.",
            "If this is not passed via __init__ then this is retrieved\nthrough the gateway when an event contains the data. Usually\nafter on_connect() is called.",
            "New in version 2.0.",
            "This function is a coroutine.",
            "Retrieves the bot’s application information.",
            "The bot’s application information.",
            "AppInfo",
            "HTTPException – Retrieving the information failed somehow.",
            "This function is a coroutine.",
            "A hook that is called before IDENTIFYing a session. This is useful\nif you wish to have more control over the synchronization of multiple\nIDENTIFYing clients.",
            "The default implementation sleeps for 5 seconds.",
            "New in version 1.4.",
            "shard_id (int) – The shard ID that requested being IDENTIFY’d",
            "initial (bool) – Whether this IDENTIFY is the first initial IDENTIFY.",
            "None",
            "Read-only list of messages the connected client has cached.",
            "New in version 1.1.",
            "This function is a coroutine.",
            "Changes the client’s presence.",
            "activity (Optional[BaseActivity]) – The activity being done. None if no currently active activity is done.",
            "status (Optional[Status]) – Indicates what status to change to. If None, then\nStatus.online is used.",
            "InvalidArgument – If the activity parameter is not the proper type.",
            "Example",
            "Changed in version 2.0: Removed the afk keyword-only parameter.",
            "Clears the internal state of the bot.",
            "After this, the bot can be considered “re-opened”, i.e. is_closed()\nand is_ready() both return False along with the bot’s internal\ncache cleared.",
            "None",
            "This function is a coroutine.",
            "Closes the connection to Discord.",
            "None",
            "A read-only mapping of cog name to cog.",
            "A unique set of commands without aliases that are registered.",
            "This function is a coroutine.",
            "Creates a WebSocket connection and lets the WebSocket listen\nto messages from Discord. This is a loop that runs the entire\nevent system and miscellaneous aspects of the library. Control\nis not resumed until the WebSocket connection is terminated.",
            "reconnect (bool) – If we should attempt reconnecting, either due to internet\nfailure or a specific failure on Discord’s part. Certain\ndisconnects that lead to bad state will not be handled (such as\ninvalid sharding payloads or bad tokens).",
            "GatewayNotFound – The gateway to connect to Discord is not found. Usually if this\n    is thrown then there is a Discord API outage.",
            "ConnectionClosed – The WebSocket connection has been terminated.",
            "None",
            "This function is a coroutine.",
            "Creates a DMChannel with this user.",
            "This should be rarely called, as this is done transparently for most\npeople.",
            "New in version 2.0.",
            "user (Snowflake) – The user to create a DM with.",
            "The channel that was created.",
            "DMChannel",
            "A shortcut method that creates a slash command group with no subcommands and adds it to the internal\ncommand list via add_application_command().",
            "New in version 2.0.",
            "name (str) – The name of the group to create.",
            "description (Optional[str]) – The description of the group to create.",
            "guild_ids (Optional[List[int]]) – A list of the IDs of each guild this group should be added to, making it a guild command.\nThis will be a global command if None is passed.",
            "kwargs – Any additional keyword arguments to pass to SlashCommandGroup.",
            "The slash command group that was created.",
            "SlashCommandGroup",
            "This function is a coroutine.",
            "Creates a Guild.",
            "Bot accounts in more than 10 guilds are not allowed to create guilds.",
            "name (str) – The name of the guild.",
            "icon (Optional[bytes]) – The bytes-like object representing the icon. See ClientUser.edit()\nfor more details on what is expected.",
            "code (str) – The code for a template to create the guild with.\n\nNew in version 1.4.",
            "The code for a template to create the guild with.",
            "New in version 1.4.",
            "The guild created. This is not the same guild that is\nadded to cache.",
            "Guild",
            "HTTPException – Guild creation failed.",
            "InvalidArgument – Invalid icon image format given. Must be PNG or JPG.",
            "This function is a coroutine.",
            "Revokes an Invite, URL, or ID to an invite.",
            "You must have the manage_channels permission in\nthe associated guild to do this.",
            "invite (Union[Invite, str]) – The invite to revoke.",
            "Forbidden – You do not have permissions to revoke invites.",
            "NotFound – The invite is invalid or expired.",
            "HTTPException – Revoking the invite failed.",
            "None",
            "The emojis that the connected client has.",
            "Returns an AsyncIterator that enables fetching the application’s entitlements.",
            "New in version 2.6.",
            "user (abc.Snowflake | None) – Limit the fetched entitlements to entitlements owned by this user.",
            "skus (list[abc.Snowflake] | None) – Limit the fetched entitlements to entitlements that are for these SKUs.",
            "before (abc.Snowflake | datetime.datetime | None) – Retrieves guilds before this date or object.\nIf a datetime is provided, it is recommended to use a UTC-aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (abc.Snowflake | datetime.datetime | None) – Retrieve guilds after this date or object.\nIf a datetime is provided, it is recommended to use a UTC-aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "limit (Optional[int]) – The number of entitlements to retrieve.\nIf None, retrieves every entitlement, which may be slow.\nDefaults to 100.",
            "guild (abc.Snowflake | None) – Limit the fetched entitlements to entitlements owned by this guild.",
            "exclude_ended (bool) – Whether to limit the fetched entitlements to those that have not ended.\nDefaults to False.",
            "Entitlement – The application’s entitlements.",
            "HTTPException – Retrieving the entitlements failed.",
            "EntitlementIterator",
            "Examples",
            "Usage",
            "Flattening into a list",
            "All parameters are optional.",
            "A read-only mapping of extension name to extension.",
            "This function is a coroutine.\nRetrieves a PartialAppInfo from an application ID.",
            "application_id (int) – The application ID to retrieve information from.",
            "The application information.",
            "PartialAppInfo",
            "NotFound – An application with this ID does not exist.",
            "HTTPException – Retrieving the application failed.",
            "This function is a coroutine.",
            "Retrieves a abc.GuildChannel, abc.PrivateChannel, or Thread with the specified ID.",
            "Note",
            "This method is an API call. For general usage, consider get_channel() instead.",
            "New in version 1.2.",
            "The channel from the ID.",
            "Union[abc.GuildChannel, abc.PrivateChannel, Thread]",
            "InvalidData – An unknown channel type was received from Discord.",
            "HTTPException – Retrieving the channel failed.",
            "NotFound – Invalid Channel ID.",
            "Forbidden – You do not have permission to fetch this channel.",
            "channel_id (int) –",
            "This function is a coroutine.",
            "Retrieves a Guild from an ID.",
            "Note",
            "Using this, you will not receive Guild.channels, Guild.members,\nMember.activity and Member.voice per Member.",
            "Note",
            "This method is an API call. For general usage, consider get_guild() instead.",
            "guild_id (int) – The guild’s ID to fetch from.",
            "with_counts (bool) – Whether to include count information in the guild. This fills the\nGuild.approximate_member_count and Guild.approximate_presence_count\nfields.\n\nNew in version 2.0.",
            "Whether to include count information in the guild. This fills the\nGuild.approximate_member_count and Guild.approximate_presence_count\nfields.",
            "New in version 2.0.",
            "The guild from the ID.",
            "Guild",
            "Forbidden – You do not have access to the guild.",
            "HTTPException – Getting the guild failed.",
            "Retrieves an AsyncIterator that enables receiving your guilds.",
            "Note",
            "Using this, you will only receive Guild.owner, Guild.icon,\nGuild.id, and Guild.name per Guild.",
            "Note",
            "This method is an API call. For general usage, consider guilds instead.",
            "limit (Optional[int]) – The number of guilds to retrieve.\nIf None, it retrieves every guild you have access to. Note, however,\nthat this would make it a slow operation.\nDefaults to 100.",
            "before (Union[abc.Snowflake, datetime.datetime]) – Retrieves guilds before this date or object.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Union[abc.Snowflake, datetime.datetime]) – Retrieve guilds after this date or object.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "Guild – The guild with the guild data parsed.",
            "HTTPException – Getting the guilds failed.",
            "GuildIterator",
            "Examples",
            "Usage",
            "Flattening into a list",
            "All parameters are optional.",
            "This function is a coroutine.",
            "Gets an Invite from a discord.gg URL or ID.",
            "Note",
            "If the invite is for a guild you have not joined, the guild and channel\nattributes of the returned Invite will be PartialInviteGuild and\nPartialInviteChannel respectively.",
            "url (Union[Invite, str]) – The Discord invite ID or URL (must be a discord.gg URL).",
            "with_counts (bool) – Whether to include count information in the invite. This fills the\nInvite.approximate_member_count and Invite.approximate_presence_count\nfields.",
            "with_expiration (bool) – Whether to include the expiration date of the invite. This fills the\nInvite.expires_at field.\n\nNew in version 2.0.",
            "Whether to include the expiration date of the invite. This fills the\nInvite.expires_at field.",
            "New in version 2.0.",
            "event_id (Optional[int]) – The ID of the scheduled event to be associated with the event.\nSee Invite.set_scheduled_event() for more\ninfo on event invite linking.\n\nNew in version 2.0.",
            "The ID of the scheduled event to be associated with the event.",
            "See Invite.set_scheduled_event() for more\ninfo on event invite linking.",
            "New in version 2.0.",
            "The invite from the URL/ID.",
            "Invite",
            "NotFound – The invite has expired or is invalid.",
            "HTTPException – Getting the invite failed.",
            "This function is a coroutine.",
            "Retrieves all available premium sticker packs.",
            "New in version 2.0.",
            "All available premium sticker packs.",
            "List[StickerPack]",
            "HTTPException – Retrieving the sticker packs failed.",
            "This function is a coroutine.",
            "Fetches the bot’s role connection metadata records.",
            "New in version 2.4.",
            "The bot’s role connection metadata records.",
            "List[ApplicationRoleConnectionMetadata]",
            "This function is a coroutine.",
            "Fetches the bot’s SKUs.",
            "New in version 2.5.",
            "The bot’s SKUs.",
            "List[SKU]",
            "This function is a coroutine.",
            "Gets a StageInstance for a stage channel id.",
            "New in version 2.0.",
            "channel_id (int) – The stage channel ID.",
            "The stage instance from the stage channel ID.",
            "StageInstance",
            "NotFound – The stage instance or channel could not be found.",
            "HTTPException – Getting the stage instance failed.",
            "This function is a coroutine.",
            "Retrieves a Sticker with the specified ID.",
            "New in version 2.0.",
            "The sticker you requested.",
            "Union[StandardSticker, GuildSticker]",
            "HTTPException – Retrieving the sticker failed.",
            "NotFound – Invalid sticker ID.",
            "sticker_id (int) –",
            "This function is a coroutine.",
            "Gets a Template from a discord.new URL or code.",
            "code (Union[Template, str]) – The Discord Template Code or URL (must be a discord.new URL).",
            "The template from the URL/code.",
            "Template",
            "NotFound – The template is invalid.",
            "HTTPException – Getting the template failed.",
            "This function is a coroutine.",
            "Retrieves a User based on their ID.\nYou do not have to share any guilds with the user to get this information,\nhowever many operations do require that you do.",
            "Note",
            "This method is an API call. If you have discord.Intents.members and member cache enabled,\nconsider get_user() instead.",
            "user_id (int) – The user’s ID to fetch from.",
            "The user you requested.",
            "User",
            "NotFound – A user with this ID does not exist.",
            "HTTPException – Fetching the user failed.",
            "This function is a coroutine.",
            "Retrieves a Webhook with the specified ID.",
            "The webhook you requested.",
            "Webhook",
            "HTTPException – Retrieving the webhook failed.",
            "NotFound – Invalid webhook ID.",
            "Forbidden – You do not have permission to fetch this webhook.",
            "webhook_id (int) –",
            "This function is a coroutine.",
            "Gets a Widget from a guild ID.",
            "Note",
            "The guild must have the widget enabled to get this information.",
            "guild_id (int) – The ID of the guild.",
            "The guild’s widget.",
            "Widget",
            "Forbidden – The widget for this guild is disabled.",
            "HTTPException – Retrieving the widget failed.",
            "A generator that retrieves every abc.GuildChannel the client can ‘access’.",
            "This is equivalent to:",
            "Generator[GuildChannel, None, None]",
            "Note",
            "Just because you receive a abc.GuildChannel does not mean that\nyou can communicate in said channel. abc.GuildChannel.permissions_for() should\nbe used for that.",
            "abc.GuildChannel – A channel the client can ‘access’.",
            "Returns a generator with every Member the client can see.",
            "This is equivalent to:",
            "Member – A member the client can see.",
            "Generator[Member, None, None]",
            "Get an ApplicationCommand from the internal list\nof commands.",
            "New in version 2.0.",
            "name (str) – The qualified name of the command to get.",
            "guild_ids (List[int]) – The guild ids associated to the command to get.",
            "type (Type[ApplicationCommand]) – The type of the command to get. Defaults to ApplicationCommand.",
            "The command that was requested. If not found, returns None.",
            "Optional[ApplicationCommand]",
            "This function is a coroutine.",
            "Returns the invocation context from the interaction.",
            "This is a more low-level counter-part for process_application_commands()\nto allow users more fine-grained control over the processing.",
            "interaction (discord.Interaction) – The interaction to get the invocation context from.",
            "cls (Any) – The factory class that will be used to create the context.\nBy default, this is ApplicationContext. Should a custom\nclass be provided, it must be similar enough to\nApplicationContext's interface.",
            "The invocation context. The type of this can change via the\ncls parameter.",
            "ApplicationContext",
            "This function is a coroutine.",
            "Returns the autocomplete context from the interaction.",
            "This is a more low-level counter-part for process_application_commands()\nto allow users more fine-grained control over the processing.",
            "interaction (discord.Interaction) – The interaction to get the invocation context from.",
            "cls (Any) – The factory class that will be used to create the context.\nBy default, this is AutocompleteContext. Should a custom\nclass be provided, it must be similar enough to\nAutocompleteContext's interface.",
            "The autocomplete context. The type of this can change via the\ncls parameter.",
            "AutocompleteContext",
            "Returns a channel or thread with the given ID.",
            "id (int) – The ID to search for.",
            "The returned channel or None if not found.",
            "Optional[Union[abc.GuildChannel, Thread, abc.PrivateChannel]]",
            "Gets the cog instance requested.",
            "If the cog is not found, None is returned instead.",
            "name (str) – The name of the cog you are requesting.\nThis is equivalent to the name passed via keyword\nargument in class creation or the class name if unspecified.",
            "The cog that was requested. If not found, returns None.",
            "Optional[Cog]",
            "Get a Command from the internal list\nof commands.",
            "This could also be used as a way to get aliases.",
            "The name could be fully qualified (e.g. 'foo bar') will get\nthe subcommand bar of the group command foo. If a\nsubcommand is not found then None is returned just as usual.",
            "name (str) – The name of the command to get.",
            "The command that was requested. If not found, returns None.",
            "Optional[Command]",
            "This function is a coroutine.",
            "Returns the invocation context from the message.",
            "This is a more low-level counter-part for process_commands()\nto allow users more fine-grained control over the processing.",
            "The returned context is not guaranteed to be a valid invocation\ncontext, Context.valid must be checked to make sure it is.\nIf the context is not valid then it is not a valid candidate to be\ninvoked under invoke().",
            "message (discord.Message) – The message to get the invocation context from.",
            "cls – The factory class that will be used to create the context.\nBy default, this is Context. Should a custom\nclass be provided, it must be similar enough to Context's\ninterface.",
            "The invocation context. The type of this can change via the\ncls parameter.",
            "Context",
            "This function is a coroutine.",
            "Gets the list of commands that are desynced from discord. If guild_id is specified, it will only return\nguild commands that are desynced from said guild, else it will return global commands.",
            "Note",
            "This function is meant to be used internally, and should only be used if you want to override the default\ncommand registration behavior.",
            "New in version 2.0.",
            "guild_id (Optional[int]) – The guild id to get the desynced commands for, else global commands if unspecified.",
            "prefetched (Optional[List[ApplicationCommand]]) – If you already fetched the commands, you can pass them here to be used. Not recommended for typical usage.",
            "A list of the desynced commands. Each will come with at least the cmd and action keys, which\nrespectively contain the command and the action to perform. Other keys may also be present depending on\nthe action, including id.",
            "List[Dict[str, Any]]",
            "Returns an emoji with the given ID.",
            "id (int) – The ID to search for.",
            "The custom emoji or None if not found.",
            "Optional[Emoji]",
            "Returns a guild with the given ID.",
            "id (int) – The ID to search for.",
            "The guild or None if not found.",
            "Optional[Guild]",
            "Returns a message the given ID.",
            "This is useful if you have a message_id but don’t want to do an API call\nto access the message.",
            "id (int) – The ID to search for.",
            "The returned message or None if not found.",
            "Optional[Message]",
            "This function is a coroutine.",
            "Looks up a user in the user cache or fetches if not found.",
            "id (int) – The ID to search for.",
            "The user or None if not found.",
            "Optional[User]",
            "Returns a partial messageable with the given channel ID.",
            "This is useful if you have a channel_id but don’t want to do an API call\nto send messages to it.",
            "New in version 2.0.",
            "id (int) – The channel ID to create a partial messageable for.",
            "type (Optional[ChannelType]) – The underlying channel type for the partial messageable.",
            "The partial messageable",
            "PartialMessageable",
            "Returns a poll attached to the given message ID.",
            "id (int) – The message ID of the poll to search for.",
            "The poll or None if not found.",
            "Optional[Poll]",
            "This function is a coroutine.",
            "Retrieves the prefix the bot is listening to\nwith the message as a context.",
            "message (discord.Message) – The message context to get the prefix of.",
            "A list of prefixes or a single prefix that the bot is\nlistening for.",
            "Union[List[str], str]",
            "Returns a stage instance with the given stage channel ID.",
            "New in version 2.0.",
            "id (int) – The ID to search for.",
            "The stage instance or None if not found.",
            "Optional[StageInstance]",
            "Returns a guild sticker with the given ID.",
            "New in version 2.0.",
            "Note",
            "To retrieve standard stickers, use fetch_sticker().\nor fetch_premium_sticker_packs().",
            "The sticker or None if not found.",
            "Optional[GuildSticker]",
            "id (int) –",
            "Returns a user with the given ID.",
            "id (int) – The ID to search for.",
            "The user or None if not found.",
            "Optional[User]",
            "The guilds that the connected client is a member of.",
            "The intents configured for this connection.",
            "New in version 1.5.",
            "This function is a coroutine.",
            "Invokes the command given under the invocation context and\nhandles all the internal event dispatch mechanisms.",
            "ctx (Context) – The invocation context to invoke.",
            "None",
            "This function is a coroutine.",
            "Invokes the application command given under the invocation\ncontext and handles all the internal event dispatch mechanisms.",
            "ctx (ApplicationCommand) – The invocation context to invoke.",
            "None",
            "Indicates if the WebSocket connection is closed.",
            "bool",
            "This function is a coroutine.",
            "Checks if a User or Member is the owner of\nthis bot.",
            "If an owner_id is not set, it is fetched automatically\nthrough the use of application_info().",
            "Changed in version 1.3: The function also checks if the application is team-owned if\nowner_ids is not set.",
            "user (abc.User) – The user to check for.",
            "Whether the user is the owner.",
            "bool",
            "Specifies if the client’s internal cache is ready for use.",
            "bool",
            "Whether the WebSocket is currently rate limited.",
            "This can be useful to know when deciding whether you should query members\nusing HTTP or via the gateway.\n:rtype: bool",
            "New in version 1.6.",
            "Measures latency between a HEARTBEAT and a HEARTBEAT_ACK in seconds.",
            "This could be referred to as the Discord WebSocket protocol latency.",
            "Loads an extension.",
            "An extension is a python module that contains commands, cogs, or\nlisteners.",
            "An extension must have a global function, setup defined as\nthe entry point on what to do when the extension is loaded. This entry\npoint must have a single argument, the bot.",
            "The extension passed can either be the direct name of a file within\nthe current working directory or a folder that contains multiple extensions.",
            "name (str) – The extension or folder name to load. It must be dot separated\nlike regular Python imports if accessing a submodule. e.g.\nfoo.test if you want to import foo/test.py.",
            "package (Optional[str]) – The package name to resolve relative imports with.\nThis is required when loading an extension using a relative\npath, e.g .foo.test.\nDefaults to None.\n\nNew in version 1.7.",
            "The package name to resolve relative imports with.\nThis is required when loading an extension using a relative\npath, e.g .foo.test.\nDefaults to None.",
            "New in version 1.7.",
            "recursive (Optional[bool]) – If subdirectories under the given head directory should be\nrecursively loaded.\nDefaults to False.\n\nNew in version 2.0.",
            "If subdirectories under the given head directory should be\nrecursively loaded.\nDefaults to False.",
            "New in version 2.0.",
            "store (Optional[bool]) – If exceptions should be stored or raised. If set to True,\nall exceptions encountered will be stored in a returned dictionary\nas a load status. If set to False, if any exceptions are\nencountered they will be raised and the bot will be closed.\nIf no exceptions are encountered, a list of loaded\nextension names will be returned.\nDefaults to False.\n\nNew in version 2.0.",
            "If exceptions should be stored or raised. If set to True,\nall exceptions encountered will be stored in a returned dictionary\nas a load status. If set to False, if any exceptions are\nencountered they will be raised and the bot will be closed.\nIf no exceptions are encountered, a list of loaded\nextension names will be returned.\nDefaults to False.",
            "New in version 2.0.",
            "If the store parameter is set to True, a dictionary will be returned that\ncontains keys to represent the loaded extension names. The values bound to\neach key can either be an exception that occurred when loading that extension\nor a True boolean representing a successful load. If the store parameter\nis set to False, either a list containing a list of loaded extensions or\nnothing due to an encountered exception.",
            "Optional[Union[Dict[str, Union[errors.ExtensionError, bool]], List[str]]]",
            "ExtensionNotFound – The extension could not be imported.\n    This is also raised if the name of the extension could not\n    be resolved using the provided package parameter.",
            "ExtensionAlreadyLoaded – The extension is already loaded.",
            "NoEntryPointError – The extension does not have a setup function.",
            "ExtensionFailed – The extension or its setup function had an execution error.",
            "Loads multiple extensions at once.",
            "This method simplifies the process of loading multiple\nextensions by handling the looping of load_extension.",
            "names (str) – The extension or folder names to load. It must be dot separated\nlike regular Python imports if accessing a submodule. e.g.\nfoo.test if you want to import foo/test.py.",
            "package (Optional[str]) – The package name to resolve relative imports with.\nThis is required when loading an extension using a relative\npath, e.g .foo.test.\nDefaults to None.\n\nNew in version 1.7.",
            "The package name to resolve relative imports with.\nThis is required when loading an extension using a relative\npath, e.g .foo.test.\nDefaults to None.",
            "New in version 1.7.",
            "recursive (Optional[bool]) – If subdirectories under the given head directory should be\nrecursively loaded.\nDefaults to False.\n\nNew in version 2.0.",
            "If subdirectories under the given head directory should be\nrecursively loaded.\nDefaults to False.",
            "New in version 2.0.",
            "store (Optional[bool]) – If exceptions should be stored or raised. If set to True,\nall exceptions encountered will be stored in a returned dictionary\nas a load status. If set to False, if any exceptions are\nencountered they will be raised and the bot will be closed.\nIf no exceptions are encountered, a list of loaded\nextension names will be returned.\nDefaults to False.\n\nNew in version 2.0.",
            "If exceptions should be stored or raised. If set to True,\nall exceptions encountered will be stored in a returned dictionary\nas a load status. If set to False, if any exceptions are\nencountered they will be raised and the bot will be closed.\nIf no exceptions are encountered, a list of loaded\nextension names will be returned.\nDefaults to False.",
            "New in version 2.0.",
            "If the store parameter is set to True, a dictionary will be returned that\ncontains keys to represent the loaded extension names. The values bound to\neach key can either be an exception that occurred when loading that extension\nor a True boolean representing a successful load. If the store parameter\nis set to False, either a list containing names of loaded extensions or\nnothing due to an encountered exception.",
            "Optional[Union[Dict[str, Union[errors.ExtensionError, bool]], List[str]]]",
            "ExtensionNotFound – A given extension could not be imported.\n    This is also raised if the name of the extension could not\n    be resolved using the provided package parameter.",
            "ExtensionAlreadyLoaded – A given extension is already loaded.",
            "NoEntryPointError – A given extension does not have a setup function.",
            "ExtensionFailed – A given extension or its setup function had an execution error.",
            "This function is a coroutine.",
            "Logs in the client with the specified credentials.",
            "token (str) – The authentication token. Do not prefix this token with\nanything as the library will do it for you.",
            "TypeError – The token was in invalid type.",
            "LoginFailure – The wrong credentials are passed.",
            "HTTPException – An unknown HTTP related error occurred,\n    usually when it isn’t 200 or the known incorrect credentials\n    passing status code.",
            "None",
            "A shortcut decorator that invokes command() and adds it to\nthe internal command list via add_application_command().\nThis shortcut is made specifically for MessageCommand.",
            "New in version 2.0.",
            "A decorator that converts the provided method into a MessageCommand, adds it to the bot,\nthen returns it.",
            "Callable[…, MessageCommand]",
            "This function is a coroutine.",
            "The default command error handler provided by the bot.",
            "By default, this prints to sys.stderr however it could be\noverridden to have a different implementation.",
            "This only fires if you do not specify any listeners for command error.",
            "context (ApplicationContext) –",
            "exception (DiscordException) –",
            "None",
            "This function is a coroutine.",
            "The default command error handler provided by the bot.",
            "By default, this prints to sys.stderr however it could be\noverridden to have a different implementation.",
            "This only fires if you do not specify any listeners for command error.",
            "context (Context) –",
            "exception (CommandError) –",
            "None",
            "This function is a coroutine.",
            "The default error handler provided by the client.",
            "By default, this prints to sys.stderr however it could be\noverridden to have a different implementation.\nCheck on_error() for more details.",
            "event_method (str) –",
            "args (Any) –",
            "kwargs (Any) –",
            "None",
            "A sequence of persistent views added to the client.",
            "New in version 2.0.",
            "The polls that the connected client has.",
            "New in version 2.6.",
            "The private channels that the connected client is participating on.",
            "Note",
            "This returns only up to 128 most recent private channels due to an internal working\non how Discord deals with private channels.",
            "This function is a coroutine.",
            "This function processes the commands that have been registered\nto the bot and other groups. Without this coroutine, none of the\ncommands will be triggered.",
            "By default, this coroutine is called inside the on_interaction()\nevent. If you choose to override the on_interaction() event, then\nyou should invoke this coroutine as well.",
            "This function finds a registered command matching the interaction id from\napplication commands and invokes it. If no matching command was\nfound, it replies to the interaction with a default message.",
            "New in version 2.0.",
            "interaction (discord.Interaction) – The interaction to process",
            "auto_sync (Optional[bool]) – Whether to automatically sync and unregister the command if it is not found in the internal cache. This will\ninvoke the sync_commands() method on the context of the command, either globally or per-guild,\nbased on the type of the command, respectively. Defaults to Bot.auto_sync_commands.",
            "None",
            "This function is a coroutine.",
            "This function processes the commands that have been registered\nto the bot and other groups. Without this coroutine, none of the\ncommands will be triggered.",
            "By default, this coroutine is called inside the on_message()\nevent. If you choose to override the on_message() event, then\nyou should invoke this coroutine as well.",
            "This is built using other low level tools, and is equivalent to a\ncall to get_context() followed by a call to invoke().",
            "This also checks if the message’s author is a bot and doesn’t\ncall get_context() or invoke() if so.",
            "message (discord.Message) – The message to process commands for.",
            "None",
            "This function is a coroutine.",
            "Registers a command. If the command has guild_ids set, or if the guild_ids parameter is passed,\nthe command will be registered as a guild command for those guilds.",
            "command (ApplicationCommand) – The command to register.",
            "force (bool) – Whether to force the command to be registered. If this is set to False, the command will only be registered\nif it seems to already be registered and up to date with our internal cache. Defaults to True.",
            "guild_ids (list) – A list of guild ids to register the command for. If this is not set, the command’s\nApplicationCommand.guild_ids attribute will be used.",
            "The command that was registered",
            "ApplicationCommand",
            "This function is a coroutine.",
            "Register a list of commands.",
            "New in version 2.0.",
            "commands (Optional[List[ApplicationCommand]]) – A list of commands to register. If this is not set (None), then all commands will be registered.",
            "guild_id (Optional[int]) – If this is set, the commands will be registered as a guild command for the respective guild. If it is not\nset, the commands will be registered according to their ApplicationCommand.guild_ids attribute.",
            "method (Literal['individual', 'bulk', 'auto']) – The method to use when registering the commands. If this is set to “individual”, then each command will be\nregistered individually. If this is set to “bulk”, then all commands will be registered in bulk. If this is\nset to “auto”, then the method will be determined automatically. Defaults to “bulk”.",
            "force (bool) – Registers the commands regardless of the state of the command on Discord. This uses one less API call, but\ncan result in hitting rate limits more often. Defaults to False.",
            "delete_existing (bool) – Whether to delete existing commands that are not in the list of commands to register. Defaults to True.",
            "Atomically reloads an extension.",
            "This replaces the extension with the same extension, only refreshed. This is\nequivalent to a unload_extension() followed by a load_extension()\nexcept done in an atomic way. That is, if an operation fails mid-reload then\nthe bot will roll back to the prior working state.",
            "name (str) – The extension name to reload. It must be dot separated like\nregular Python imports if accessing a submodule. e.g.\nfoo.test if you want to import foo/test.py.",
            "package (Optional[str]) – The package name to resolve relative imports with.\nThis is required when reloading an extension using a relative path, e.g .foo.test.\nDefaults to None.\n\nNew in version 1.7.",
            "The package name to resolve relative imports with.\nThis is required when reloading an extension using a relative path, e.g .foo.test.\nDefaults to None.",
            "New in version 1.7.",
            "ExtensionNotLoaded – The extension was not loaded.",
            "ExtensionNotFound – The extension could not be imported.\n    This is also raised if the name of the extension could not\n    be resolved using the provided package parameter.",
            "NoEntryPointError – The extension does not have a setup function.",
            "ExtensionFailed – The extension setup function had an execution error.",
            "None",
            "Remove an ApplicationCommand from the internal list\nof commands.",
            "New in version 2.0.",
            "command (ApplicationCommand) – The command to remove.",
            "The command that was removed. If the command has not been added,\nNone is returned instead.",
            "Optional[ApplicationCommand]",
            "Removes a global check from the bot.\nThis function is idempotent and will not raise an exception\nif the function is not in the global checks.",
            "func – The function to remove from the global checks.",
            "call_once (bool) – If the function was added with call_once=True in\nthe Bot.add_check() call or using check_once().",
            "None",
            "Removes a cog from the bot and returns it.",
            "All registered commands and event listeners that the\ncog has registered will be removed as well.",
            "If no cog is found then this method has no effect.",
            "name (str) – The name of the cog to remove.",
            "The cog that was removed. None if not found.",
            "Optional[Cog]",
            "Remove a Command from the internal list\nof commands.",
            "This could also be used as a way to remove aliases.",
            "name (str) – The name of the command to remove.",
            "The command that was removed. If the name is not valid then\nNone is returned instead.",
            "Optional[Command]",
            "Removes a listener from the pool of listeners.",
            "func (TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])) – The function that was used as a listener to remove.",
            "name (str) – The name of the event we want to remove. Defaults to\nfunc.__name__.",
            "None",
            "A blocking call that abstracts away the event loop\ninitialisation from you.",
            "If you want more control over the event loop then this\nfunction should not be used. Use start() coroutine\nor connect() + login().",
            "Roughly Equivalent to:",
            "Warning",
            "This function must be the last function to call due to the fact that it\nis blocking. That means that registration of events or anything being\ncalled after this function call will not execute until it returns.",
            "args (Any) –",
            "kwargs (Any) –",
            "None",
            "A shortcut decorator that invokes command() and adds it to\nthe internal command list via add_application_command().\nThis shortcut is made specifically for SlashCommand.",
            "New in version 2.0.",
            "A decorator that converts the provided method into a SlashCommand, adds it to the bot,\nthen returns it.",
            "Callable[…, SlashCommand]",
            "A shortcut decorator that initializes the provided subclass of SlashCommandGroup\nand adds it to the internal command list via add_application_command().",
            "New in version 2.0.",
            "name (Optional[str]) – The name of the group to create. This will resolve to the name of the decorated class if None is passed.",
            "description (Optional[str]) – The description of the group to create.",
            "guild_ids (Optional[List[int]]) – A list of the IDs of each guild this group should be added to, making it a guild command.\nThis will be a global command if None is passed.",
            "The slash command group that was created.",
            "Callable[[Type[SlashCommandGroup]], SlashCommandGroup]",
            "This function is a coroutine.",
            "A shorthand coroutine for login() + connect().",
            "TypeError – An unexpected keyword argument was received.",
            "token (str) –",
            "reconnect (bool) –",
            "None",
            "The status being used upon logging on to Discord.",
            "The stickers that the connected client has.",
            "New in version 2.0.",
            "The URL that leads to the application’s store page for monetization.",
            "New in version 2.6.",
            "str",
            "This function is a coroutine.",
            "Registers all commands that have been added through add_application_command(). This method cleans up all\ncommands over the API and should sync them with the internal cache of commands. It attempts to register the\ncommands in the most efficient way possible, unless force is set to True, in which case it will always\nregister all commands.",
            "By default, this coroutine is called inside the on_connect() event. If you choose to override the\non_connect() event, then you should invoke this coroutine as well such as the following:",
            "Note",
            "If you remove all guild commands from a particular guild, the library may not be able to detect and update\nthe commands accordingly, as it would have to individually check for each guild. To force the library to\nunregister a guild’s commands, call this function with commands=[] and guild_ids=[guild_id].",
            "New in version 2.0.",
            "commands (Optional[List[ApplicationCommand]]) – A list of commands to register. If this is not set (None), then all commands will be registered.",
            "method (Literal['individual', 'bulk', 'auto']) – The method to use when registering the commands. If this is set to “individual”, then each command will be\nregistered individually. If this is set to “bulk”, then all commands will be registered in bulk. If this is\nset to “auto”, then the method will be determined automatically. Defaults to “bulk”.",
            "force (bool) – Registers the commands regardless of the state of the command on Discord. This uses one less API call, but\ncan result in hitting rate limits more often. Defaults to False.",
            "guild_ids (Optional[List[int]]) – A list of guild ids to register the commands for. If this is not set, the commands’\nguild_ids attribute will be used.",
            "register_guild_commands (bool) – Whether to register guild commands. Defaults to True.",
            "check_guilds (Optional[List[int]]) – A list of guilds ids to check for commands to unregister, since the bot would otherwise have to check all\nguilds. Unlike guild_ids, this does not alter the commands’ guild_ids\nattribute, instead it adds the guild ids to a list of guilds to sync commands for. If\nregister_guild_commands is set to False, then this parameter is ignored.",
            "delete_existing (bool) – Whether to delete existing commands that are not in the list of commands to register. Defaults to True.",
            "Unloads an extension.",
            "When the extension is unloaded, all commands, listeners, and cogs are\nremoved from the bot and the module is un-imported.",
            "The extension can provide an optional global function, teardown,\nto do miscellaneous clean-up if necessary. This function takes a single\nparameter, the bot, similar to setup from\nload_extension().",
            "name (str) – The extension name to unload. It must be dot separated like\nregular Python imports if accessing a submodule. e.g.\nfoo.test if you want to import foo/test.py.",
            "package (Optional[str]) – The package name to resolve relative imports with.\nThis is required when unloading an extension using a relative path, e.g .foo.test.\nDefaults to None.\n\nNew in version 1.7.",
            "The package name to resolve relative imports with.\nThis is required when unloading an extension using a relative path, e.g .foo.test.\nDefaults to None.",
            "New in version 1.7.",
            "ExtensionNotFound – The name of the extension could not\n    be resolved using the provided package parameter.",
            "ExtensionNotLoaded – The extension was not loaded.",
            "None",
            "This function is a coroutine.",
            "Updates the bot’s role connection metadata records.",
            "New in version 2.4.",
            "*role_connection_metadata (ApplicationRoleConnectionMetadata) – The new metadata records to send to Discord.",
            "The updated role connection metadata records.",
            "List[ApplicationRoleConnectionMetadata]",
            "Represents the connected client. None if not logged in.",
            "A shortcut decorator that invokes command() and adds it to\nthe internal command list via add_application_command().\nThis shortcut is made specifically for UserCommand.",
            "New in version 2.0.",
            "A decorator that converts the provided method into a UserCommand, adds it to the bot,\nthen returns it.",
            "Callable[…, UserCommand]",
            "Returns a list of all the users the bot can see.",
            "Represents a list of voice connections.",
            "These are usually VoiceClient instances.",
            "This function is a coroutine.",
            "Waits for a WebSocket event to be dispatched.",
            "This could be used to wait for a user to reply to a message,\nor to react to a message, or to edit a message in a self-contained\nway.",
            "The timeout parameter is passed onto asyncio.wait_for(). By default,\nit does not timeout. Note that this does propagate the\nasyncio.TimeoutError for you in case of timeout and is provided for\nease of use.",
            "In case the event returns multiple arguments, a tuple containing those\narguments is returned instead. Please check the\ndocumentation for a list of events and their\nparameters.",
            "This function returns the first event that meets the requirements.",
            "event (str) – The event name, similar to the event reference,\nbut without the on_ prefix, to wait for.",
            "check (Optional[Callable[…, bool]]) – A predicate to check what to wait for. The arguments must meet the\nparameters of the event being waited for.",
            "timeout (Optional[float]) – The number of seconds to wait before timing out and raising\nasyncio.TimeoutError.",
            "Returns no arguments, a single argument, or a tuple of multiple\narguments that mirrors the parameters passed in the\nevent reference.",
            "Any",
            "asyncio.TimeoutError – Raised if a timeout is provided and reached.",
            "Examples",
            "Waiting for a user reply:",
            "Waiting for a thumbs up reaction from the message author:",
            "This function is a coroutine.",
            "Waits until the client’s internal cache is all ready.",
            "None",
            "An iterator that recursively walks through all application commands and subcommands.",
            "ApplicationCommand – An application command from the internal list of application commands.",
            "Generator[ApplicationCommand, None, None]",
            "An iterator that recursively walks through all commands and subcommands.\n:rtype: Generator[Command[TypeVar(CogT, bound= Cog), Any, Any], None, None]",
            "Changed in version 1.4: Duplicates due to aliases are no longer returned",
            "Union[Command, Group] – A command or group from the internal list of commands."
        ],
        "code": [
            "discord.Bot",
            "discord.Bot",
            "GroupMixin",
            "discord.Intents.message_content",
            "discord.Message",
            "Context.prefix",
            "('!', '!?')",
            "'!?'",
            "!?",
            "False",
            "bool",
            "None",
            "HelpCommand",
            "!   hello",
            "!hello",
            "command_prefix",
            "!",
            "False",
            "bool",
            "Context",
            "before_invoke()",
            "CommandInvokeError",
            "Context",
            "before_invoke()",
            "after_invoke()",
            "check()",
            "check()",
            "Context",
            "ApplicationCommandError",
            "@bot.check\ndef check_commands(ctx):\n    return ctx.command.qualified_name in allowed_commands",
            "Bot.invoke()",
            "Command.can_run()",
            "Context",
            "Bot.invoke()",
            "check()",
            "Context",
            "ApplicationCommandError",
            "@bot.check_once\ndef whitelist(ctx):\n    return ctx.message.author.id in my_whitelist",
            "command()",
            "add_command()",
            "Command",
            "TypeError",
            "listen()",
            "event()",
            "@client.event\nasync def on_ready():\n    print('Ready!')",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "group()",
            "add_command()",
            "Group",
            "on_ready()",
            "name",
            "@client.listen()\nasync def on_message(message):\n    print('one')\n\n# in some other file...\n\n@client.listen('on_message')\nasync def my_message(message):\n    print('two')\n\n# listen to the first event only\n@client.listen('on_ready', once=True)\nasync def on_ready():\n    print('ready!')",
            "str",
            "bool",
            "Callable",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "BaseActivity",
            "ApplicationCommand",
            "command()",
            "ApplicationCommand",
            "None",
            "check()",
            "check_once()",
            "bool",
            "Bot.invoke()",
            "None",
            "ClientException",
            "Cog",
            "bool",
            "Cog",
            "None",
            "Command",
            "command()",
            "group()",
            "CommandRegistrationError",
            "ClientException",
            "Command",
            "Command",
            "None",
            "listen()",
            "str",
            "func.__name__",
            "func",
            "name",
            "None",
            "async def on_ready(): pass\nasync def my_message(message): pass\n\nclient.add_listener(on_ready)\nclient.add_listener(my_message, 'on_message')",
            "View",
            "discord.ui.View",
            "int",
            "custom_id",
            "command()",
            "add_application_command()",
            "ApplicationCommand",
            "ApplicationCommand",
            "__init__",
            "on_connect()",
            "AppInfo",
            "int",
            "bool",
            "BaseActivity",
            "None",
            "Status",
            "None",
            "Status.online",
            "activity",
            "game = discord.Game(\"with the API\")\nawait client.change_presence(status=discord.Status.idle, activity=game)",
            "afk",
            "is_closed()",
            "is_ready()",
            "False",
            "None",
            "None",
            "bool",
            "None",
            "DMChannel",
            "Snowflake",
            "DMChannel",
            "add_application_command()",
            "str",
            "str",
            "int",
            "None",
            "SlashCommandGroup",
            "Guild",
            "str",
            "bytes",
            "ClientUser.edit()",
            "str",
            "Guild",
            "Invite",
            "manage_channels",
            "Invite",
            "str",
            "AsyncIterator",
            "abc.Snowflake",
            "abc.Snowflake",
            "abc.Snowflake",
            "datetime.datetime",
            "abc.Snowflake",
            "datetime.datetime",
            "int",
            "None",
            "100",
            "abc.Snowflake",
            "bool",
            "False",
            "Entitlement",
            "async for entitlement in client.entitlements():\n    print(entitlement.user_id)",
            "entitlements = await user.entitlements().flatten()",
            "PartialAppInfo",
            "int",
            "PartialAppInfo",
            "abc.GuildChannel",
            "abc.PrivateChannel",
            "Thread",
            "get_channel()",
            "abc.GuildChannel",
            "abc.PrivateChannel",
            "Thread",
            "Guild",
            "Guild.channels",
            "Guild.members",
            "Member.activity",
            "Member.voice",
            "Member",
            "get_guild()",
            "int",
            "bool",
            "Guild.approximate_member_count",
            "Guild.approximate_presence_count",
            "Guild",
            "AsyncIterator",
            "Guild.owner",
            "Guild.icon",
            "Guild.id",
            "Guild.name",
            "Guild",
            "guilds",
            "int",
            "None",
            "100",
            "abc.Snowflake",
            "datetime.datetime",
            "abc.Snowflake",
            "datetime.datetime",
            "Guild",
            "async for guild in client.fetch_guilds(limit=150):\n    print(guild.name)",
            "guilds = await client.fetch_guilds(limit=150).flatten()\n# guilds is now a list of Guild...",
            "Invite",
            "Invite",
            "PartialInviteGuild",
            "PartialInviteChannel",
            "Invite",
            "str",
            "bool",
            "Invite.approximate_member_count",
            "Invite.approximate_presence_count",
            "bool",
            "Invite.expires_at",
            "int",
            "Invite.set_scheduled_event()",
            "Invite",
            "StickerPack",
            "ApplicationRoleConnectionMetadata",
            "SKU",
            "StageInstance",
            "int",
            "StageInstance",
            "Sticker",
            "StandardSticker",
            "GuildSticker",
            "Template",
            "Template",
            "str",
            "Template",
            "User",
            "discord.Intents.members",
            "get_user()",
            "int",
            "User",
            "Webhook",
            "Webhook",
            "int",
            "Widget",
            "int",
            "Widget",
            "abc.GuildChannel",
            "for guild in client.guilds:\n    for channel in guild.channels:\n        yield channel",
            "Generator",
            "GuildChannel",
            "None",
            "None",
            "abc.GuildChannel",
            "abc.GuildChannel.permissions_for()",
            "abc.GuildChannel",
            "Member",
            "for guild in client.guilds:\n    for member in guild.members:\n        yield member",
            "Member",
            "Generator",
            "Member",
            "None",
            "None",
            "ApplicationCommand",
            "str",
            "int",
            "ApplicationCommand",
            "ApplicationCommand",
            "None",
            "ApplicationCommand",
            "process_application_commands()",
            "discord.Interaction",
            "Any",
            "ApplicationContext",
            "ApplicationContext",
            "cls",
            "ApplicationContext",
            "process_application_commands()",
            "discord.Interaction",
            "Any",
            "AutocompleteContext",
            "AutocompleteContext",
            "cls",
            "AutocompleteContext",
            "int",
            "None",
            "abc.GuildChannel",
            "Thread",
            "abc.PrivateChannel",
            "None",
            "str",
            "None",
            "Cog",
            "Command",
            "'foo bar'",
            "bar",
            "foo",
            "None",
            "str",
            "None",
            "Command",
            "process_commands()",
            "Context.valid",
            "invoke()",
            "discord.Message",
            "Context",
            "Context",
            "cls",
            "Context",
            "guild_id",
            "int",
            "ApplicationCommand",
            "cmd",
            "action",
            "id",
            "str",
            "int",
            "None",
            "Emoji",
            "int",
            "None",
            "Guild",
            "int",
            "None",
            "Message",
            "int",
            "None",
            "User",
            "int",
            "ChannelType",
            "PartialMessageable",
            "int",
            "None",
            "Poll",
            "discord.Message",
            "str",
            "str",
            "int",
            "None",
            "StageInstance",
            "fetch_sticker()",
            "fetch_premium_sticker_packs()",
            "None",
            "GuildSticker",
            "int",
            "None",
            "User",
            "Context",
            "None",
            "ApplicationCommand",
            "None",
            "bool",
            "User",
            "Member",
            "owner_id",
            "application_info()",
            "owner_ids",
            "abc.User",
            "bool",
            "bool",
            "bool",
            "setup",
            "bot",
            "str",
            "foo.test",
            "foo/test.py",
            "str",
            ".foo.test",
            "None",
            "bool",
            "False",
            "bool",
            "True",
            "False",
            "False",
            "True",
            "True",
            "False",
            "str",
            "errors.ExtensionError",
            "bool",
            "str",
            "package",
            "load_extension",
            "str",
            "foo.test",
            "foo/test.py",
            "str",
            ".foo.test",
            "None",
            "bool",
            "False",
            "bool",
            "True",
            "False",
            "False",
            "True",
            "True",
            "False",
            "str",
            "errors.ExtensionError",
            "bool",
            "str",
            "package",
            "str",
            "None",
            "command()",
            "add_application_command()",
            "MessageCommand",
            "MessageCommand",
            "MessageCommand",
            "sys.stderr",
            "ApplicationContext",
            "DiscordException",
            "None",
            "sys.stderr",
            "Context",
            "CommandError",
            "None",
            "sys.stderr",
            "on_error()",
            "str",
            "Any",
            "Any",
            "None",
            "on_interaction()",
            "on_interaction()",
            "discord.Interaction",
            "bool",
            "sync_commands()",
            "Bot.auto_sync_commands",
            "on_message()",
            "on_message()",
            "get_context()",
            "invoke()",
            "get_context()",
            "invoke()",
            "discord.Message",
            "None",
            "guild_ids",
            "guild_ids",
            "ApplicationCommand",
            "bool",
            "list",
            "ApplicationCommand.guild_ids",
            "ApplicationCommand",
            "ApplicationCommand",
            "None",
            "ApplicationCommand.guild_ids",
            "bool",
            "bool",
            "unload_extension()",
            "load_extension()",
            "str",
            "foo.test",
            "foo/test.py",
            "str",
            ".foo.test",
            "None",
            "package",
            "ApplicationCommand",
            "ApplicationCommand",
            "None",
            "ApplicationCommand",
            "bool",
            "call_once=True",
            "Bot.add_check()",
            "check_once()",
            "None",
            "str",
            "None",
            "Cog",
            "Command",
            "str",
            "None",
            "Command",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "str",
            "func.__name__",
            "None",
            "start()",
            "connect()",
            "login()",
            "try:\n    loop.run_until_complete(start(*args, **kwargs))\nexcept KeyboardInterrupt:\n    loop.run_until_complete(close())\n    # cancel all tasks lingering\nfinally:\n    loop.close()",
            "Any",
            "Any",
            "None",
            "command()",
            "add_application_command()",
            "SlashCommand",
            "SlashCommand",
            "SlashCommand",
            "SlashCommandGroup",
            "add_application_command()",
            "str",
            "None",
            "str",
            "int",
            "None",
            "login()",
            "connect()",
            "str",
            "bool",
            "None",
            "str",
            "add_application_command()",
            "force",
            "True",
            "on_connect()",
            "on_connect()",
            "@bot.event\nasync def on_connect():\n    if bot.auto_sync_commands:\n        await bot.sync_commands()\n    print(f\"{bot.user.name} connected.\")",
            "commands=[]",
            "guild_ids=[guild_id]",
            "ApplicationCommand",
            "bool",
            "int",
            "guild_ids",
            "bool",
            "int",
            "guild_ids",
            "guild_ids",
            "register_guild_commands",
            "bool",
            "teardown",
            "bot",
            "setup",
            "load_extension()",
            "str",
            "foo.test",
            "foo/test.py",
            "str",
            ".foo.test",
            "None",
            "package",
            "ApplicationRoleConnectionMetadata",
            "ApplicationRoleConnectionMetadata",
            "None",
            "command()",
            "add_application_command()",
            "UserCommand",
            "UserCommand",
            "UserCommand",
            "VoiceClient",
            "timeout",
            "asyncio.wait_for()",
            "asyncio.TimeoutError",
            "tuple",
            "str",
            "on_",
            "bool",
            "float",
            "asyncio.TimeoutError",
            "tuple",
            "@client.event\nasync def on_message(message):\n    if message.content.startswith('$greet'):\n        channel = message.channel\n        await channel.send('Say hello!')\n\n        def check(m):\n            return m.content == 'hello' and m.channel == channel\n\n        msg = await client.wait_for('message', check=check)\n        await channel.send(f'Hello {msg.author}!')",
            "@client.event\nasync def on_message(message):\n    if message.content.startswith('$thumb'):\n        channel = message.channel\n        await channel.send('Send me that 👍 reaction, mate')\n\n        def check(reaction, user):\n            return user == message.author and str(reaction.emoji) == '👍'\n\n        try:\n            reaction, user = await client.wait_for('reaction_add', timeout=60.0, check=check)\n        except asyncio.TimeoutError:\n            await channel.send('👎')\n        else:\n            await channel.send('👍')",
            "None",
            "ApplicationCommand",
            "Generator",
            "ApplicationCommand",
            "None",
            "None",
            "Generator",
            "Command",
            "TypeVar",
            "CogT",
            "Any",
            "Any",
            "None",
            "None",
            "Command",
            "Group"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "AutoShardedBot#",
        "content": [
            "This is similar to Bot except that it is inherited from\ndiscord.AutoShardedBot instead.",
            "command_prefix (str | Iterable[str] | Callable[[Bot | AutoShardedBot, Message], str | Iterable[str] | Coroutine[Any, Any, str | Iterable[str]]]) –",
            "help_command (HelpCommand | None) –"
        ],
        "code": [
            "Bot",
            "discord.AutoShardedBot"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Prefix Helpers#",
        "content": [
            "A callable that implements a command prefix equivalent to being mentioned.",
            "These are meant to be passed into the Bot.command_prefix attribute.",
            "bot (Bot | AutoShardedBot) –",
            "msg (Message) –",
            "list[str]",
            "A callable that implements when mentioned or other prefixes provided.",
            "These are meant to be passed into the Bot.command_prefix attribute.",
            "See also",
            "when_mentioned()",
            "Example",
            "Note",
            "This callable returns another callable, so if this is done inside a custom\ncallable, you must call the returned callable, for example:",
            "prefixes (str) –",
            "Callable[[Bot | AutoShardedBot, Message], list[str]]"
        ],
        "code": [
            "Bot.command_prefix",
            "Bot.command_prefix",
            "when_mentioned()",
            "bot = commands.Bot(command_prefix=commands.when_mentioned_or('!'))",
            "async def get_prefix(bot, message):\n    extras = await prefixes_for(message.guild) # returns a list\n    return commands.when_mentioned_or(*extras)(bot, message)"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Event Reference#",
        "content": [
            "These events function similar to the regular events, except they\nare custom to the command extension module.",
            "An error handler that is called when an error is raised\ninside a command either through user input error, check\nfailure, or an error in your own code.",
            "A default one is provided (Bot.on_command_error()).",
            "ctx (Context) – The invocation context.",
            "error (CommandError derived) – The error that was raised.",
            "An event that is called when a command is found and is about to be invoked.",
            "This event is called regardless of whether the command itself succeeds via\nerror or completes.",
            "ctx (Context) – The invocation context.",
            "An event that is called when a command has completed its invocation.",
            "This event is called only if the command succeeded, i.e. all checks have\npassed and the user input it correctly.",
            "ctx (Context) – The invocation context."
        ],
        "code": [
            "Bot.on_command_error()",
            "Context",
            "CommandError",
            "Context",
            "Context"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Commands#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Decorators#",
        "content": [
            "A decorator that transforms a function into a Command\nor if called with group(), Group.",
            "By default the help attribute is received automatically from the\ndocstring of the function and is cleaned up with the use of\ninspect.cleandoc. If the docstring is bytes, then it is decoded\ninto str using utf-8 encoding.",
            "All checks added using the check() & co. decorators are added into\nthe function. There is no way to supply your own checks through this\ndecorator.",
            "name (str) – The name to create the command with. By default, this uses the\nfunction name unchanged.",
            "cls – The class to construct with. By default, this is Command.\nYou usually do not change this.",
            "attrs – Keyword arguments to pass into the construction of the class denoted\nby cls.",
            "TypeError – If the function is not a coroutine or is already a command.",
            "A decorator that transforms a function into a Group.",
            "This is similar to the command() decorator but the cls\nparameter is set to Group by default.",
            "Changed in version 1.1: The cls parameter can now be passed."
        ],
        "code": [
            "Command",
            "group()",
            "Group",
            "help",
            "inspect.cleandoc",
            "bytes",
            "str",
            "check()",
            "str",
            "Command",
            "cls",
            "Group",
            "command()",
            "cls",
            "Group",
            "cls"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Command#",
        "content": [
            "A class that implements the protocol for a bot text command.",
            "These are not created manually, instead they are created via the\ndecorator or functional interface.",
            "The name of the command.",
            "str",
            "The coroutine that is executed when the command is called.",
            "coroutine",
            "The long help text for the command.",
            "Optional[str]",
            "The short help text for the command.",
            "Optional[str]",
            "A replacement for arguments in the default help text.",
            "Optional[str]",
            "The list of aliases the command can be invoked under.",
            "Union[List[str], Tuple[str]]",
            "A boolean that indicates if the command is currently enabled.\nIf the command is invoked while it is disabled, then\nDisabledCommand is raised to the on_command_error()\nevent. Defaults to True.",
            "bool",
            "The parent group that this command belongs to. None if there\nisn’t one.",
            "Optional[Group]",
            "The cog that this command belongs to. None if there isn’t one.",
            "Optional[Cog]",
            "A list of predicates that verifies if the command could be executed\nwith the given Context as the sole parameter. If an exception\nis necessary to be thrown to signal failure, then one inherited from\nCommandError should be used. Note that if the checks fail then\nCheckFailure exception is raised to the on_command_error()\nevent.",
            "List[Callable[[Context], bool]]",
            "The message prefixed into the default help command.",
            "str",
            "If True, the default help command does not show this in the\nhelp output.",
            "bool",
            "If False and a keyword-only argument is provided then the keyword\nonly argument is stripped and handled as if it was a regular argument\nthat handles MissingRequiredArgument and default values in a\nregular matter rather than passing the rest completely raw. If True\nthen the keyword-only argument will pass in the rest of the arguments\nin a completely raw matter. Defaults to False.",
            "bool",
            "The subcommand that was invoked, if any.",
            "Optional[Command]",
            "If True and a variadic positional argument is specified, requires\nthe user to specify at least one argument. Defaults to False.",
            "New in version 1.5.",
            "bool",
            "If True, ignores extraneous strings passed to a command if all its\nrequirements are met (e.g. ?foo a b c when only expecting a\nand b). Otherwise on_command_error() and local error handlers\nare called with TooManyArguments. Defaults to True.",
            "bool",
            "If True, cooldown processing is done after argument parsing,\nwhich calls converters. If False then cooldown processing is done\nfirst and then the converters are called second. Defaults to False.",
            "bool",
            "A dict of user provided extras to attach to the Command.",
            "Note",
            "This object may be copied by the library.",
            "dict",
            "New in version 2.0.",
            "The cooldown applied when the command is invoked. None if the command\ndoesn’t have a cooldown.",
            "New in version 2.0.",
            "func (Callable[Concatenate[CogT, ContextT, P], Coro[T]] | Callable[Concatenate[ContextT, P], Coro[T]]) –",
            "kwargs (Any) –",
            "A decorator that registers a coroutine as a post-invoke hook.",
            "A post-invoke hook is called directly after the command is\ncalled. This makes it a useful function to clean-up database\nconnections or any type of clean up required.",
            "This post-invoke hook takes a sole parameter, a Context.",
            "See Bot.after_invoke() for more info.",
            "coro (coroutine) – The coroutine to register as the post-invoke hook.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "TypeVar(HookT, bound= Hook)",
            "A decorator that registers a coroutine as a pre-invoke hook.",
            "A pre-invoke hook is called directly before the command is\ncalled. This makes it a useful function to set up database\nconnections or any type of set up required.",
            "This pre-invoke hook takes a sole parameter, a Context.",
            "See Bot.before_invoke() for more info.",
            "coro (coroutine) – The coroutine to register as the pre-invoke hook.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "TypeVar(HookT, bound= Hook)",
            "A decorator that registers a coroutine as a local error handler.",
            "A local error handler is an on_command_error() event limited to\na single command. However, the on_command_error() is still\ninvoked afterwards as the catch-all.",
            "coro (coroutine) – The coroutine to register as the local error handler.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "TypeVar(ErrorT, bound= Error)",
            "Adds a check to the command.",
            "This is the non-decorator interface to check().",
            "New in version 1.3.",
            "func (Union[Callable[[Cog, Context[Any]], Union[bool, Coroutine[Any, Any, bool]]], Callable[[Context[Any]], Union[bool, Coroutine[Any, Any, bool]]]]) – The function that will be used as a check.",
            "None",
            "Removes a check from the command.",
            "This function is idempotent and will not raise an exception\nif the function is not in the command’s checks.",
            "New in version 1.3.",
            "func (Union[Callable[[Cog, Context[Any]], Union[bool, Coroutine[Any, Any, bool]]], Callable[[Context[Any]], Union[bool, Coroutine[Any, Any, bool]]]]) – The function to remove from the checks.",
            "None",
            "Updates Command instance with updated attribute.",
            "This works similarly to the command() decorator in terms\nof parameters in that they are passed to the Command or\nsubclass constructors, sans the name and callback.",
            "kwargs (Any) –",
            "None",
            "This function is a coroutine.",
            "Calls the internal callback that the command holds.",
            "Note",
            "This bypasses all mechanisms – including checks, converters,\ninvoke hooks, cooldowns, etc. You must take care to pass\nthe proper arguments and types to this function.",
            "New in version 1.3.",
            "Creates a copy of this command.",
            "A new instance of this command.",
            "Command",
            "self (TypeVar(CommandT, bound= Command)) –",
            "Dict[str, inspect.Parameter]:\nRetrieves the parameter dictionary without the context or self parameters.",
            "Useful for inspecting signature.",
            "Retrieves the fully qualified parent command name.",
            "This the base command name required to execute it. For example,\nin ?one two three the parent name would be one two.",
            "Retrieves the parents of this command.",
            "If the command has no parents then it returns an empty list.",
            "For example in commands ?a b c test, the parents are [c, b, a].",
            "New in version 1.1.",
            "Retrieves the root parent of this command.",
            "If the command has no parents then it returns None.",
            "For example in commands ?a b c test, the root parent is a.",
            "Retrieves the fully qualified command name.",
            "This is the full parent name with the command name as well.\nFor example, in ?one two three the qualified name would be\none two three.",
            "Checks whether the command is currently on cooldown.",
            "ctx (Context) – The invocation context to use when checking the command’s cooldown status.",
            "A boolean indicating if the command is on cooldown.",
            "bool",
            "Resets the cooldown on this command.",
            "ctx (Context) – The invocation context to reset the cooldown under.",
            "None",
            "Retrieves the amount of seconds before this command can be tried again.",
            "New in version 1.4.",
            "ctx (Context) – The invocation context to retrieve the cooldown from.",
            "The amount of time left on this command’s cooldown in seconds.\nIf this is 0.0 then the command isn’t on cooldown.",
            "float",
            "Checks whether the command has an error handler registered.\n:rtype: bool",
            "New in version 1.7.",
            "The name of the cog this command belongs to, if any.",
            "Gets the “short” documentation of a command.",
            "By default, this is the brief attribute.\nIf that lookup leads to an empty string then the first line of the\nhelp attribute is used instead.",
            "Returns a POSIX-like signature useful for help command output.",
            "This function is a coroutine.",
            "Checks if the command can be executed by checking all the predicates\ninside the checks attribute. This also checks whether the\ncommand is disabled.",
            "Changed in version 1.3: Checks whether the command is disabled or not",
            "ctx (Context) – The ctx of the command currently being invoked.",
            "A boolean indicating if the command can be invoked.",
            "bool",
            "CommandError – Any command error that was raised during a check call will be propagated\n    by this function."
        ],
        "code": [
            "str",
            "str",
            "str",
            "str",
            "str",
            "str",
            "DisabledCommand",
            "on_command_error()",
            "True",
            "bool",
            "None",
            "Group",
            "None",
            "Cog",
            "Context",
            "CommandError",
            "CheckFailure",
            "on_command_error()",
            "Context",
            "bool",
            "str",
            "True",
            "bool",
            "False",
            "MissingRequiredArgument",
            "True",
            "False",
            "bool",
            "Command",
            "True",
            "False",
            "bool",
            "True",
            "?foo a b c",
            "a",
            "b",
            "on_command_error()",
            "TooManyArguments",
            "True",
            "bool",
            "True",
            "False",
            "False",
            "bool",
            "dict",
            "Cooldown",
            "None",
            "Context",
            "Bot.after_invoke()",
            "TypeVar",
            "HookT",
            "Context",
            "Bot.before_invoke()",
            "TypeVar",
            "HookT",
            "on_command_error()",
            "on_command_error()",
            "TypeVar",
            "ErrorT",
            "check()",
            "Union",
            "Callable",
            "Union",
            "bool",
            "Coroutine",
            "Any",
            "Any",
            "bool",
            "Callable",
            "Union",
            "bool",
            "Coroutine",
            "Any",
            "Any",
            "bool",
            "None",
            "Union",
            "Callable",
            "Union",
            "bool",
            "Coroutine",
            "Any",
            "Any",
            "bool",
            "Callable",
            "Union",
            "bool",
            "Coroutine",
            "Any",
            "Any",
            "bool",
            "None",
            "Command",
            "command()",
            "Command",
            "Any",
            "None",
            "Command",
            "TypeVar",
            "CommandT",
            "str",
            "inspect.Parameter",
            "?one two three",
            "one two",
            "list",
            "?a b c test",
            "[c, b, a]",
            "None",
            "?a b c test",
            "a",
            "?one two three",
            "one two three",
            "Context",
            "bool",
            "Context",
            "None",
            "Context",
            "0.0",
            "float",
            "bool",
            "brief",
            "help",
            "checks",
            "Context",
            "bool"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Group#",
        "content": [
            "A class that implements a grouping protocol for commands to be\nexecuted as subcommands.",
            "This class is a subclass of Command and thus all options\nvalid in Command are valid in here as well.",
            "Indicates if the group callback should begin parsing and\ninvocation only if no subcommand was found. Useful for\nmaking it an error handling function to tell the user that\nno subcommand was found or to have different functionality\nin case no subcommand was found. If this is False, then\nthe group callback will always be invoked first. This means\nthat the checks and the parsing dictated by its parameters\nwill be executed. Defaults to False.",
            "bool",
            "Indicates if the group’s commands should be case-insensitive.\nDefaults to False.",
            "bool",
            "args (Any) –",
            "attrs (Any) –",
            "A decorator that registers a coroutine as a post-invoke hook.",
            "A post-invoke hook is called directly after the command is\ncalled. This makes it a useful function to clean-up database\nconnections or any type of clean up required.",
            "This post-invoke hook takes a sole parameter, a Context.",
            "See Bot.after_invoke() for more info.",
            "coro (coroutine) – The coroutine to register as the post-invoke hook.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "TypeVar(HookT, bound= Hook)",
            "A decorator that registers a coroutine as a pre-invoke hook.",
            "A pre-invoke hook is called directly before the command is\ncalled. This makes it a useful function to set up database\nconnections or any type of set up required.",
            "This pre-invoke hook takes a sole parameter, a Context.",
            "See Bot.before_invoke() for more info.",
            "coro (coroutine) – The coroutine to register as the pre-invoke hook.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "TypeVar(HookT, bound= Hook)",
            "A shortcut decorator that invokes command() and adds it to\nthe internal command list via add_command().",
            "A decorator that converts the provided method into a Command, adds it to the bot, then returns it.",
            "Callable[…, Command]",
            "A decorator that registers a coroutine as a local error handler.",
            "A local error handler is an on_command_error() event limited to\na single command. However, the on_command_error() is still\ninvoked afterwards as the catch-all.",
            "coro (coroutine) – The coroutine to register as the local error handler.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "TypeVar(ErrorT, bound= Error)",
            "A shortcut decorator that invokes group() and adds it to\nthe internal command list via add_command().",
            "A decorator that converts the provided method into a Group, adds it to the bot, then returns it.",
            "Callable[…, Group]",
            "Creates a copy of this Group.",
            "A new instance of this group.",
            "Group",
            "self (TypeVar(GroupT, bound= Group)) –",
            "Adds a check to the command.",
            "This is the non-decorator interface to check().",
            "New in version 1.3.",
            "func (Union[Callable[[Cog, Context[Any]], Union[bool, Coroutine[Any, Any, bool]]], Callable[[Context[Any]], Union[bool, Coroutine[Any, Any, bool]]]]) – The function that will be used as a check.",
            "None",
            "Adds a Command into the internal list of commands.",
            "This is usually not called, instead the command() or\ngroup() shortcut decorators are used instead.",
            "Changed in version 1.4: Raise CommandRegistrationError instead of generic ClientException",
            "command (Command) – The command to add.",
            ".CommandRegistrationError – If the command or its alias is already registered by different command.",
            "TypeError – If the command passed is not a subclass of Command.",
            "None",
            "This function is a coroutine.",
            "Checks if the command can be executed by checking all the predicates\ninside the checks attribute. This also checks whether the\ncommand is disabled.",
            "Changed in version 1.3: Checks whether the command is disabled or not",
            "ctx (Context) – The ctx of the command currently being invoked.",
            "A boolean indicating if the command can be invoked.",
            "bool",
            "CommandError – Any command error that was raised during a check call will be propagated\n    by this function.",
            "Dict[str, inspect.Parameter]:\nRetrieves the parameter dictionary without the context or self parameters.",
            "Useful for inspecting signature.",
            "The name of the cog this command belongs to, if any.",
            "A unique set of commands without aliases that are registered.",
            "Retrieves the fully qualified parent command name.",
            "This the base command name required to execute it. For example,\nin ?one two three the parent name would be one two.",
            "Get a Command from the internal list\nof commands.",
            "This could also be used as a way to get aliases.",
            "The name could be fully qualified (e.g. 'foo bar') will get\nthe subcommand bar of the group command foo. If a\nsubcommand is not found then None is returned just as usual.",
            "name (str) – The name of the command to get.",
            "The command that was requested. If not found, returns None.",
            "Optional[Command]",
            "Retrieves the amount of seconds before this command can be tried again.",
            "New in version 1.4.",
            "ctx (Context) – The invocation context to retrieve the cooldown from.",
            "The amount of time left on this command’s cooldown in seconds.\nIf this is 0.0 then the command isn’t on cooldown.",
            "float",
            "Checks whether the command has an error handler registered.\n:rtype: bool",
            "New in version 1.7.",
            "Checks whether the command is currently on cooldown.",
            "ctx (Context) – The invocation context to use when checking the command’s cooldown status.",
            "A boolean indicating if the command is on cooldown.",
            "bool",
            "Retrieves the parents of this command.",
            "If the command has no parents then it returns an empty list.",
            "For example in commands ?a b c test, the parents are [c, b, a].",
            "New in version 1.1.",
            "Retrieves the fully qualified command name.",
            "This is the full parent name with the command name as well.\nFor example, in ?one two three the qualified name would be\none two three.",
            "Removes a check from the command.",
            "This function is idempotent and will not raise an exception\nif the function is not in the command’s checks.",
            "New in version 1.3.",
            "func (Union[Callable[[Cog, Context[Any]], Union[bool, Coroutine[Any, Any, bool]]], Callable[[Context[Any]], Union[bool, Coroutine[Any, Any, bool]]]]) – The function to remove from the checks.",
            "None",
            "Remove a Command from the internal list\nof commands.",
            "This could also be used as a way to remove aliases.",
            "name (str) – The name of the command to remove.",
            "The command that was removed. If the name is not valid then\nNone is returned instead.",
            "Optional[Command]",
            "Resets the cooldown on this command.",
            "ctx (Context) – The invocation context to reset the cooldown under.",
            "None",
            "Retrieves the root parent of this command.",
            "If the command has no parents then it returns None.",
            "For example in commands ?a b c test, the root parent is a.",
            "Gets the “short” documentation of a command.",
            "By default, this is the brief attribute.\nIf that lookup leads to an empty string then the first line of the\nhelp attribute is used instead.",
            "Returns a POSIX-like signature useful for help command output.",
            "Updates Command instance with updated attribute.",
            "This works similarly to the command() decorator in terms\nof parameters in that they are passed to the Command or\nsubclass constructors, sans the name and callback.",
            "kwargs (Any) –",
            "None",
            "An iterator that recursively walks through all commands and subcommands.\n:rtype: Generator[Command[TypeVar(CogT, bound= Cog), Any, Any], None, None]",
            "Changed in version 1.4: Duplicates due to aliases are no longer returned",
            "Union[Command, Group] – A command or group from the internal list of commands."
        ],
        "code": [
            "Command",
            "Command",
            "False",
            "False",
            "bool",
            "False",
            "bool",
            "Any",
            "Any",
            "Context",
            "Bot.after_invoke()",
            "TypeVar",
            "HookT",
            "Context",
            "Bot.before_invoke()",
            "TypeVar",
            "HookT",
            "command()",
            "add_command()",
            "Command",
            "on_command_error()",
            "on_command_error()",
            "TypeVar",
            "ErrorT",
            "group()",
            "add_command()",
            "Group",
            "Group",
            "Group",
            "TypeVar",
            "GroupT",
            "check()",
            "Union",
            "Callable",
            "Union",
            "bool",
            "Coroutine",
            "Any",
            "Any",
            "bool",
            "Callable",
            "Union",
            "bool",
            "Coroutine",
            "Any",
            "Any",
            "bool",
            "None",
            "Command",
            "command()",
            "group()",
            "CommandRegistrationError",
            "ClientException",
            "Command",
            "Command",
            "None",
            "checks",
            "Context",
            "bool",
            "str",
            "inspect.Parameter",
            "?one two three",
            "one two",
            "Command",
            "'foo bar'",
            "bar",
            "foo",
            "None",
            "str",
            "None",
            "Command",
            "Context",
            "0.0",
            "float",
            "bool",
            "Context",
            "bool",
            "list",
            "?a b c test",
            "[c, b, a]",
            "?one two three",
            "one two three",
            "Union",
            "Callable",
            "Union",
            "bool",
            "Coroutine",
            "Any",
            "Any",
            "bool",
            "Callable",
            "Union",
            "bool",
            "Coroutine",
            "Any",
            "Any",
            "bool",
            "None",
            "Command",
            "str",
            "None",
            "Command",
            "Context",
            "None",
            "None",
            "?a b c test",
            "a",
            "brief",
            "help",
            "Command",
            "command()",
            "Command",
            "Any",
            "None",
            "Generator",
            "Command",
            "TypeVar",
            "CogT",
            "Any",
            "Any",
            "None",
            "None",
            "Command",
            "Group"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "GroupMixin#",
        "content": [
            "A mixin that implements common functionality for classes that behave\nsimilar to Group and are allowed to register commands.",
            "A mapping of command name to Command\nobjects.",
            "dict",
            "Whether the commands should be case-insensitive. Defaults to False.",
            "bool",
            "args (Any) –",
            "kwargs (Any) –",
            "A shortcut decorator that invokes command() and adds it to\nthe internal command list via add_command().",
            "A decorator that converts the provided method into a Command, adds it to the bot, then returns it.",
            "Callable[…, Command]",
            "A shortcut decorator that invokes group() and adds it to\nthe internal command list via add_command().",
            "A decorator that converts the provided method into a Group, adds it to the bot, then returns it.",
            "Callable[…, Group]",
            "A unique set of commands without aliases that are registered.",
            "Adds a Command into the internal list of commands.",
            "This is usually not called, instead the command() or\ngroup() shortcut decorators are used instead.",
            "Changed in version 1.4: Raise CommandRegistrationError instead of generic ClientException",
            "command (Command) – The command to add.",
            ".CommandRegistrationError – If the command or its alias is already registered by different command.",
            "TypeError – If the command passed is not a subclass of Command.",
            "None",
            "Remove a Command from the internal list\nof commands.",
            "This could also be used as a way to remove aliases.",
            "name (str) – The name of the command to remove.",
            "The command that was removed. If the name is not valid then\nNone is returned instead.",
            "Optional[Command]",
            "An iterator that recursively walks through all commands and subcommands.\n:rtype: Generator[Command[TypeVar(CogT, bound= Cog), Any, Any], None, None]",
            "Changed in version 1.4: Duplicates due to aliases are no longer returned",
            "Union[Command, Group] – A command or group from the internal list of commands.",
            "Get a Command from the internal list\nof commands.",
            "This could also be used as a way to get aliases.",
            "The name could be fully qualified (e.g. 'foo bar') will get\nthe subcommand bar of the group command foo. If a\nsubcommand is not found then None is returned just as usual.",
            "name (str) – The name of the command to get.",
            "The command that was requested. If not found, returns None.",
            "Optional[Command]"
        ],
        "code": [
            "Group",
            "Command",
            "dict",
            "False",
            "bool",
            "Any",
            "Any",
            "command()",
            "add_command()",
            "Command",
            "group()",
            "add_command()",
            "Group",
            "Command",
            "command()",
            "group()",
            "CommandRegistrationError",
            "ClientException",
            "Command",
            "Command",
            "None",
            "Command",
            "str",
            "None",
            "Command",
            "Generator",
            "Command",
            "TypeVar",
            "CogT",
            "Any",
            "Any",
            "None",
            "None",
            "Command",
            "Group",
            "Command",
            "'foo bar'",
            "bar",
            "foo",
            "None",
            "str",
            "None",
            "Command"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Cogs#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Cog#",
        "content": [
            "An iterator that recursively walks through this cog’s commands and subcommands.",
            "Union[Command, Group] – A command or group from the cog.",
            "Generator[Command, None, None]",
            "A list of commands that are defined inside this cog.\n\nNote\nThis does not include subcommands.",
            "A list of commands that are defined inside this cog.",
            "Note",
            "This does not include subcommands.",
            "List[Union[ApplicationCommand, Command]]"
        ],
        "code": [
            "Command",
            "Group",
            "Generator",
            "Command",
            "None",
            "None",
            "list",
            "ApplicationCommand",
            "Command"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "CogMeta#",
        "content": [
            "A metaclass for defining a cog.",
            "Note that you should probably not use this directly. It is exposed\npurely for documentation purposes along with making custom metaclasses to intermix\nwith other metaclasses such as the abc.ABCMeta metaclass.",
            "For example, to create an abstract cog mixin class, the following would be done.",
            "Note",
            "When passing an attribute of a metaclass that is documented below, note\nthat you must pass it as a keyword-only argument to the class creation\nlike the following example:",
            "The cog name. By default, it is the name of the class with no modification.",
            "str",
            "The cog description. By default, it is the cleaned docstring of the class.",
            "New in version 1.6.",
            "str",
            "A list of attributes to apply to every command inside this cog. The dictionary\nis passed into the Command options at __init__.\nIf you specify attributes inside the command attribute in the class, it will\noverride the one specified inside this attribute. For example:",
            "dict",
            "A shortcut to command_attrs, what guild_ids should all application commands have\nin the cog. You can override this by setting guild_ids per command.",
            "New in version 2.0.",
            "Optional[List[int]]",
            "args (Any) –",
            "kwargs (Any) –"
        ],
        "code": [
            "abc.ABCMeta",
            "import abc\n\nclass CogABCMeta(discord.CogMeta, abc.ABCMeta):\n    pass\n\nclass SomeMixin(metaclass=abc.ABCMeta):\n    pass\n\nclass SomeCogMixin(SomeMixin, discord.Cog, metaclass=CogABCMeta):\n    pass",
            "class MyCog(discord.Cog, name='My Cog'):\n    pass",
            "str",
            "str",
            "Command",
            "__init__",
            "class MyCog(discord.Cog, command_attrs=dict(hidden=True)):\n    @discord.slash_command()\n    async def foo(self, ctx):\n        pass # hidden -> True\n\n    @discord.slash_command(hidden=False)\n    async def bar(self, ctx):\n        pass # hidden -> False",
            "dict",
            "command_attrs",
            "guild_ids",
            "guild_ids",
            "int",
            "Any",
            "Any"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Help Commands#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "HelpCommand#",
        "content": [
            "The base implementation for help command formatting.",
            "Note",
            "Internally instances of this class are deep copied every time\nthe command itself is invoked to prevent a race condition\nmentioned in GH-2123.",
            "This means that relying on the state of this class to be\nthe same between command invocations would not work as expected.",
            "The context that invoked this help formatter. This is generally set after\nthe help command assigned, command_callback(), has been called.",
            "Optional[Context]",
            "Specifies if hidden commands should be shown in the output.\nDefaults to False.",
            "bool",
            "Specifies if commands should have their Command.checks called\nand verified. If True, always calls Command.checks.\nIf None, only calls Command.checks in a guild setting.\nIf False, never calls Command.checks. Defaults to True.",
            "Changed in version 1.7.",
            "Optional[bool]",
            "A dictionary of options to pass in for the construction of the help command.\nThis allows you to change the command behaviour without actually changing\nthe implementation of the command. The attributes will be the same as the\nones passed in the Command constructor.",
            "dict",
            "Adds a check to the help command.",
            "New in version 1.4.",
            "func – The function that will be used as a check.",
            "Removes a check from the help command.",
            "This function is idempotent and will not raise an exception if\nthe function is not in the command’s checks.",
            "New in version 1.4.",
            "func – The function to remove from the checks.",
            "Retrieves the bot mapping passed to send_bot_help().",
            "Similar to Context.invoked_with except properly handles\nthe case where Context.send_help() is used.",
            "If the help command was used regularly then this returns\nthe Context.invoked_with attribute. Otherwise, if\nthe help command was called using Context.send_help()\nthen it returns the internal command name of the help command.",
            "The command name that triggered this invocation.",
            "str",
            "Retrieves the signature portion of the help page.",
            "command (Command) – The command to get the signature of.",
            "The signature for the command.",
            "str",
            "Removes mentions from the string to prevent abuse.",
            "This includes @everyone, @here, member mentions and role mentions.",
            "The string with mentions removed.",
            "str",
            "A property for retrieving or setting the cog for the help command.",
            "When a cog is set for the help command, it is as-if the help command\nbelongs to that cog. All cog special methods will apply to the help\ncommand, and it will be automatically unset on unload.",
            "To unbind the cog from the help command, you can set it to None.",
            "The cog that is currently set for the help command.",
            "Optional[Cog]",
            "This function could be a coroutine.",
            "A method called when a command is not found in the help command.\nThis is useful to override for i18n.",
            "Defaults to No command called {0} found.",
            "string (str) – The string that contains the invalid command. Note that this has\nhad mentions removed to prevent abuse.",
            "The string to use when a command has not been found.",
            "str",
            "This function could be a coroutine.",
            "A method called when a command did not have a subcommand requested in the help command.\nThis is useful to override for i18n.",
            "Defaults to either:",
            "If there is no subcommand in the command parameter.",
            "If the command parameter has subcommands but not one named string.",
            "command (Command) – The command that did not have the subcommand requested.",
            "string (str) – The string that contains the invalid subcommand. Note that this has\nhad mentions removed to prevent abuse.",
            "The string to use when the command did not have the subcommand requested.",
            "str",
            "This function is a coroutine.",
            "Returns a filtered list of commands and optionally sorts them.",
            "This takes into account the verify_checks and show_hidden\nattributes.",
            "commands (Iterable[Command]) – An iterable of commands that are getting filtered.",
            "sort (bool) – Whether to sort the result.",
            "key (Optional[Callable[Command, Any]]) – An optional key function to pass to sorted() that\ntakes a Command as its sole parameter. If sort is\npassed as True then this will default as the command name.",
            "A list of commands that passed the filter.",
            "List[Command]",
            "Returns the largest name length of the specified command list.",
            "commands (Sequence[Command]) – A sequence of commands to check for the largest size.",
            "The maximum width of the commands.",
            "int",
            "Returns the Messageable where the help command will be output.",
            "You can override this method to customise the behaviour.",
            "By default, this returns the context’s channel.",
            "The destination where the help command will be output.",
            "abc.Messageable",
            "This function is a coroutine.",
            "Handles the implementation when an error happens in the help command.\nFor example, the result of command_not_found() will be passed here.",
            "You can override this method to customise the behaviour.",
            "By default, this sends the error message to the destination\nspecified by get_destination().",
            "Note",
            "You can access the invocation context with HelpCommand.context.",
            "error (str) – The error message to display to the user. Note that this has\nhad mentions removed to prevent abuse.",
            "This function is a coroutine.",
            "The help command’s error handler, as specified by Error Handling.",
            "Useful to override if you need some specific behaviour when the error handler\nis called.",
            "By default, this method does nothing and just propagates to the default\nerror handlers.",
            "ctx (Context) – The invocation context.",
            "error (CommandError) – The error that was raised.",
            "This function is a coroutine.",
            "Handles the implementation of the bot command page in the help command.\nThis function is called when the help command is called with no arguments.",
            "It should be noted that this method does not return anything – rather the\nactual message sending should be done inside this method. Well-behaved subclasses\nshould use get_destination() to know where to send, as this is a customisation\npoint for other users.",
            "You can override this method to customise the behaviour.",
            "Note",
            "You can access the invocation context with HelpCommand.context.",
            "Also, the commands in the mapping are not filtered. To do the filtering\nyou will have to call filter_commands() yourself.",
            "mapping (Mapping[Optional[Cog], List[Command]]) – A mapping of cogs to commands that have been requested by the user for help.\nThe key of the mapping is the Cog that the command belongs to, or\nNone if there isn’t one, and the value is a list of commands that belongs to that cog.",
            "This function is a coroutine.",
            "Handles the implementation of the cog page in the help command.\nThis function is called when the help command is called with a cog as the argument.",
            "It should be noted that this method does not return anything – rather the\nactual message sending should be done inside this method. Well-behaved subclasses\nshould use get_destination() to know where to send, as this is a customisation\npoint for other users.",
            "You can override this method to customise the behaviour.",
            "Note",
            "You can access the invocation context with HelpCommand.context.",
            "To get the commands that belong to this cog see Cog.get_commands().\nThe commands returned not filtered. To do the filtering you will have to call\nfilter_commands() yourself.",
            "cog (Cog) – The cog that was requested for help.",
            "This function is a coroutine.",
            "Handles the implementation of the group page in the help command.\nThis function is called when the help command is called with a group as the argument.",
            "It should be noted that this method does not return anything – rather the\nactual message sending should be done inside this method. Well-behaved subclasses\nshould use get_destination() to know where to send, as this is a customisation\npoint for other users.",
            "You can override this method to customise the behaviour.",
            "Note",
            "You can access the invocation context with HelpCommand.context.",
            "To get the commands that belong to this group without aliases see\nGroup.commands. The commands returned not filtered. To do the\nfiltering you will have to call filter_commands() yourself.",
            "group (Group) – The group that was requested for help.",
            "This function is a coroutine.",
            "Handles the implementation of the single command page in the help command.",
            "It should be noted that this method does not return anything – rather the\nactual message sending should be done inside this method. Well-behaved subclasses\nshould use get_destination() to know where to send, as this is a customisation\npoint for other users.",
            "You can override this method to customise the behaviour.",
            "Note",
            "You can access the invocation context with HelpCommand.context.",
            "Showing Help",
            "There are certain attributes and methods that are helpful for a help command\nto show such as the following:",
            "Command.help",
            "Command.brief",
            "Command.short_doc",
            "Command.description",
            "get_command_signature()",
            "There are more than just these attributes but feel free to play around with\nthese to help you get started to get the output that you want.",
            "command (Command) – The command that was requested for help.",
            "This function is a coroutine.",
            "A low level method that can be used to prepare the help command\nbefore it does anything. For example, if you need to prepare\nsome state in your subclass before the command does its processing\nthen this would be the place to do it.",
            "The default implementation does nothing.",
            "Note",
            "This is called inside the help command callback body. So all\nthe usual rules that happen inside apply here as well.",
            "ctx (Context) – The invocation context.",
            "command (Optional[str]) – The argument passed to the help command.",
            "This function is a coroutine.",
            "The actual implementation of the help command.",
            "It is not recommended to override this method and instead change\nthe behaviour through the methods that actually get dispatched.",
            "send_bot_help()",
            "send_cog_help()",
            "send_group_help()",
            "send_command_help()",
            "get_destination()",
            "command_not_found()",
            "subcommand_not_found()",
            "send_error_message()",
            "on_help_command_error()",
            "prepare_help_command()"
        ],
        "code": [
            "command_callback()",
            "Context",
            "False",
            "bool",
            "Command.checks",
            "True",
            "Command.checks",
            "None",
            "Command.checks",
            "False",
            "Command.checks",
            "True",
            "bool",
            "Command",
            "dict",
            "send_bot_help()",
            "Context.invoked_with",
            "Context.send_help()",
            "Context.invoked_with",
            "Context.send_help()",
            "str",
            "Command",
            "str",
            "@everyone",
            "@here",
            "str",
            "None",
            "Cog",
            "No command called {0} found.",
            "str",
            "str",
            "'Command \"{command.qualified_name}\" has no subcommands.'",
            "command",
            "'Command \"{command.qualified_name}\" has no subcommand named {string}'",
            "command",
            "string",
            "Command",
            "str",
            "str",
            "verify_checks",
            "show_hidden",
            "Command",
            "bool",
            "Command",
            "sorted()",
            "Command",
            "sort",
            "True",
            "Command",
            "Command",
            "int",
            "Messageable",
            "abc.Messageable",
            "command_not_found()",
            "get_destination()",
            "HelpCommand.context",
            "str",
            "Context",
            "CommandError",
            "get_destination()",
            "HelpCommand.context",
            "filter_commands()",
            "Cog",
            "Command",
            "Cog",
            "None",
            "get_destination()",
            "HelpCommand.context",
            "Cog.get_commands()",
            "filter_commands()",
            "Cog",
            "get_destination()",
            "HelpCommand.context",
            "Group.commands",
            "filter_commands()",
            "Group",
            "get_destination()",
            "HelpCommand.context",
            "Command.help",
            "Command.brief",
            "Command.short_doc",
            "Command.description",
            "get_command_signature()",
            "Command",
            "Context",
            "str",
            "send_bot_help()",
            "send_cog_help()",
            "send_group_help()",
            "send_command_help()",
            "get_destination()",
            "command_not_found()",
            "subcommand_not_found()",
            "send_error_message()",
            "on_help_command_error()",
            "prepare_help_command()"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "DefaultHelpCommand#",
        "content": [
            "The implementation of the default help command.",
            "This inherits from HelpCommand.",
            "It extends it with the following attributes.",
            "The maximum number of characters that fit in a line.\nDefaults to 80.",
            "int",
            "Whether to sort the commands in the output alphabetically. Defaults to True.",
            "bool",
            "A tribool that indicates if the help command should DM the user instead of\nsending it to the channel it received it from. If the boolean is set to\nTrue, then all help output is DM’d. If False, none of the help\noutput is DM’d. If None, then the bot will only DM when the help\nmessage becomes too long (dictated by more than dm_help_threshold characters).\nDefaults to False.",
            "Optional[bool]",
            "The number of characters the paginator must accumulate before getting DM’d to the\nuser if dm_help is set to None. Defaults to 1000.",
            "Optional[int]",
            "How much to indent the commands from a heading. Defaults to 2.",
            "int",
            "The command list’s heading string used when the help command is invoked with a category name.\nUseful for i18n. Defaults to \"Commands:\"",
            "str",
            "The string used when there is a command which does not belong to any category(cog).\nUseful for i18n. Defaults to \"No Category\"",
            "str",
            "The paginator used to paginate the help command output.",
            "Paginator",
            "Shortens text to fit into the width.",
            "text (str) –",
            "str",
            "Returns help command’s ending note. This is mainly useful to override for i18n purposes.",
            "str",
            "Indents a list of commands after the specified heading.",
            "The formatting is added to the paginator.",
            "The default implementation is the command name indented by\nindent spaces, padded to max_size followed by\nthe command’s Command.short_doc and then shortened\nto fit into the width.",
            "commands (Sequence[Command]) – A list of commands to indent for output.",
            "heading (str) – The heading to add to the output. This is only added\nif the list of commands is greater than 0.",
            "max_size (Optional[int]) – The max size to use for the gap between indents.\nIf unspecified, calls get_max_size() on the\ncommands parameter.",
            "A helper utility to send the page output from paginator to the destination.",
            "A utility function to format the non-indented block of commands and groups.",
            "command (Command) – The command to format.",
            "Returns the Messageable where the help command will be output.",
            "You can override this method to customise the behaviour.",
            "By default, this returns the context’s channel.",
            "The destination where the help command will be output.",
            "abc.Messageable"
        ],
        "code": [
            "HelpCommand",
            "int",
            "True",
            "bool",
            "True",
            "False",
            "None",
            "dm_help_threshold",
            "False",
            "bool",
            "dm_help",
            "None",
            "int",
            "2",
            "int",
            "\"Commands:\"",
            "str",
            "\"No Category\"",
            "str",
            "Paginator",
            "width",
            "str",
            "str",
            "str",
            "paginator",
            "indent",
            "max_size",
            "Command.short_doc",
            "width",
            "Command",
            "str",
            "int",
            "get_max_size()",
            "paginator",
            "Command",
            "Messageable",
            "abc.Messageable"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "MinimalHelpCommand#",
        "content": [
            "An implementation of a help command with minimal output.",
            "This inherits from HelpCommand.",
            "Whether to sort the commands in the output alphabetically. Defaults to True.",
            "bool",
            "The command list’s heading string used when the help command is invoked with a category name.\nUseful for i18n. Defaults to \"Commands\"",
            "str",
            "The alias list’s heading string used to list the aliases of the command. Useful for i18n.\nDefaults to \"Aliases:\".",
            "str",
            "A tribool that indicates if the help command should DM the user instead of\nsending it to the channel it received it from. If the boolean is set to\nTrue, then all help output is DM’d. If False, none of the help\noutput is DM’d. If None, then the bot will only DM when the help\nmessage becomes too long (dictated by more than dm_help_threshold characters).\nDefaults to False.",
            "Optional[bool]",
            "The number of characters the paginator must accumulate before getting DM’d to the\nuser if dm_help is set to None. Defaults to 1000.",
            "Optional[int]",
            "The string used when there is a command which does not belong to any category(cog).\nUseful for i18n. Defaults to \"No Category\"",
            "str",
            "The paginator used to paginate the help command output.",
            "Paginator",
            "A helper utility to send the page output from paginator to the destination.",
            "Returns help command’s opening note. This is mainly useful to override for i18n purposes.",
            "The default implementation returns",
            "The help command opening note.",
            "str",
            "Retrieves the signature portion of the help page.",
            "command (Command) – The command to get the signature of.",
            "The signature for the command.",
            "str",
            "Return the help command’s ending note. This is mainly useful to override for i18n purposes.",
            "The default implementation does nothing.",
            "The help command ending note.",
            "str",
            "Adds the minified bot heading with commands to the output.",
            "The formatting should be added to the paginator.",
            "The default implementation is a bold underline heading followed\nby commands separated by an EN SPACE (U+2002) in the next line.",
            "commands (Sequence[Command]) – A list of commands that belong to the heading.",
            "heading (str) – The heading to add to the line.",
            "Adds formatting information on a subcommand.",
            "The formatting should be added to the paginator.",
            "The default implementation is the prefix and the Command.qualified_name\noptionally followed by an En dash and the command’s Command.short_doc.",
            "command (Command) – The command to show information of.",
            "Adds the formatting information on a command’s aliases.",
            "The formatting should be added to the paginator.",
            "The default implementation is the aliases_heading bolded\nfollowed by a comma separated list of aliases.",
            "This is not called if there are no aliases to format.",
            "aliases (Sequence[str]) – A list of aliases to format.",
            "A utility function to format commands and groups.",
            "command (Command) – The command to format.",
            "Returns the Messageable where the help command will be output.",
            "You can override this method to customise the behaviour.",
            "By default, this returns the context’s channel.",
            "The destination where the help command will be output.",
            "abc.Messageable"
        ],
        "code": [
            "HelpCommand",
            "True",
            "bool",
            "\"Commands\"",
            "str",
            "\"Aliases:\"",
            "str",
            "True",
            "False",
            "None",
            "dm_help_threshold",
            "False",
            "bool",
            "dm_help",
            "None",
            "int",
            "\"No Category\"",
            "str",
            "Paginator",
            "paginator",
            "Use `{prefix}{command_name} [command]` for more info on a command.\nYou can also use `{prefix}{command_name} [category]` for more info on a category.",
            "str",
            "Command",
            "str",
            "str",
            "paginator",
            "Command",
            "str",
            "paginator",
            "Command.qualified_name",
            "Command.short_doc",
            "Command",
            "paginator",
            "aliases_heading",
            "str",
            "Command",
            "Messageable",
            "abc.Messageable"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Paginator#",
        "content": [
            "A class that aids in paginating code blocks for Discord messages.",
            "Returns the total number of characters in the paginator.",
            "The prefix inserted to every page. e.g. three backticks.",
            "str",
            "The suffix appended at the end of every page. e.g. three backticks.",
            "str",
            "The maximum amount of codepoints allowed in a page.",
            "int",
            "New in version 1.7.",
            "str",
            "prefix (str | None) –",
            "suffix (str | None) –",
            "max_size (int) –",
            "linesep (str) –",
            "Clears the paginator to have no pages.",
            "Adds a line to the current page.",
            "If the line exceeds the max_size then an exception\nis raised.",
            "line (str) – The line to add.",
            "empty (bool) – Indicates if another empty line should be added.",
            "RuntimeError – The line was too big for the current max_size.",
            "Prematurely terminate a page.",
            "Returns the rendered list of pages."
        ],
        "code": [
            "str",
            "str",
            "int",
            "str",
            "max_size",
            "str",
            "bool",
            "max_size"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Enums#",
        "content": [
            "Specifies a type of bucket for, e.g. a cooldown.",
            "The default bucket operates on a global basis.",
            "The user bucket operates on a per-user basis.",
            "The guild bucket operates on a per-guild basis.",
            "The channel bucket operates on a per-channel basis.",
            "The member bucket operates on a per-member basis.",
            "The category bucket operates on a per-category basis.",
            "The role bucket operates on a per-role basis.",
            "New in version 1.3."
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Checks#",
        "content": [
            "A decorator that adds a check to the Command or its\nsubclasses. These checks could be accessed via Command.checks.",
            "These checks should be predicates that take in a single parameter taking\na Context. If the check returns a False-like value then\nduring invocation a CheckFailure exception is raised and sent to\nthe on_command_error() event.",
            "If an exception should be thrown in the predicate then it should be a\nsubclass of CommandError. Any exception not subclassed from it\nwill be propagated while those subclassed will be sent to\non_command_error().",
            "A special attribute named predicate is bound to the value\nreturned by this decorator to retrieve the predicate passed to the\ndecorator. This allows the following introspection and chaining to be done:",
            "Note",
            "The function returned by predicate is always a coroutine,\neven if the original function was not a coroutine.",
            "Changed in version 1.3: The predicate attribute was added.",
            "Examples",
            "Creating a basic check to see if the command invoker is you.",
            "Transforming common checks into its own decorator:",
            "predicate (Callable[[Context], bool]) – The predicate to check if the command should be invoked.",
            "Callable[[TypeVar(T)], TypeVar(T)]",
            "A check() that is added that checks if any of the checks passed\nwill pass, i.e. using logical OR.",
            "If all checks fail then CheckAnyFailure is raised to signal the failure.\nIt inherits from CheckFailure.",
            "Note",
            "The predicate attribute for this function is a coroutine.",
            "New in version 1.3.",
            "*checks (Callable[[Context], bool]) – An argument list of checks that have been decorated with\nthe check() decorator.",
            "TypeError – A check passed has not been decorated with the check()\n    decorator.",
            "Examples",
            "Callable[[TypeVar(T)], TypeVar(T)]",
            "Creating a basic check to see if it’s the bot owner or\nthe server owner:",
            "A check() that is added that checks if the member invoking the\ncommand has the role specified via the name or ID specified.",
            "If a string is specified, you must give the exact name of the role, including\ncaps and spelling.",
            "If an integer is specified, you must give the exact snowflake ID of the role.",
            "If the message is invoked in a private message context then the check will\nreturn False.",
            "This check raises one of two special exceptions, MissingRole if the user\nis missing a role, or NoPrivateMessage if it is used in a private message.\nBoth inherit from CheckFailure.",
            "Changed in version 1.1: Raise MissingRole or NoPrivateMessage\ninstead of generic CheckFailure",
            "item (Union[int, str]) – The name or ID of the role to check.",
            "Callable[[T], T]",
            "A check() that is added that checks if the member has all of\nthe permissions necessary.",
            "Note that this check operates on the current channel permissions, not the\nguild wide permissions.",
            "The permissions passed in must be exactly like the properties shown under\ndiscord.Permissions.",
            "This check raises a special exception, MissingPermissions\nthat is inherited from CheckFailure.",
            "If the command is executed within a DM, it returns True.",
            "**perms (Dict[str, bool]) – An argument list of permissions to check for.",
            "Callable[[TypeVar(T)], TypeVar(T)]",
            "Example",
            "Similar to has_permissions(), but operates on guild wide\npermissions instead of the current channel permissions.",
            "If this check is called in a DM context, it will raise an\nexception, NoPrivateMessage.",
            "New in version 1.3.",
            "perms (bool) –",
            "Callable[[TypeVar(T)], TypeVar(T)]",
            "A check() that is added that checks if the member invoking the\ncommand has any of the roles specified. This means that if they have\none out of the three roles specified, then this check will return True.",
            "Similar to has_role(), the names or IDs passed in must be exact.",
            "This check raises one of two special exceptions, MissingAnyRole if the user\nis missing all roles, or NoPrivateMessage if it is used in a private message.\nBoth inherit from CheckFailure.",
            "Changed in version 1.1: Raise MissingAnyRole or NoPrivateMessage\ninstead of generic CheckFailure",
            "items (List[Union[str, int]]) – An argument list of names or IDs to check that the member has roles wise.",
            "Callable[[T], T]",
            "Example",
            "Similar to has_role() except checks if the bot itself has the\nrole.",
            "This check raises one of two special exceptions, BotMissingRole if the bot\nis missing the role, or NoPrivateMessage if it is used in a private message.\nBoth inherit from CheckFailure.",
            "Changed in version 1.1: Raise BotMissingRole or NoPrivateMessage\ninstead of generic CheckFailure",
            "item (int) –",
            "Callable[[TypeVar(T)], TypeVar(T)]",
            "Similar to has_permissions() except checks if the bot itself has\nthe permissions listed.",
            "This check raises a special exception, BotMissingPermissions\nthat is inherited from CheckFailure.",
            "perms (bool) –",
            "Callable[[TypeVar(T)], TypeVar(T)]",
            "Similar to has_guild_permissions(), but checks the bot\nmembers guild permissions.",
            "New in version 1.3.",
            "perms (bool) –",
            "Callable[[TypeVar(T)], TypeVar(T)]",
            "Similar to has_any_role() except checks if the bot itself has\nany of the roles listed.",
            "This check raises one of two special exceptions, BotMissingAnyRole if the bot\nis missing all roles, or NoPrivateMessage if it is used in a private message.\nBoth inherit from CheckFailure.",
            "Changed in version 1.1: Raise BotMissingAnyRole or NoPrivateMessage\ninstead of generic CheckFailure.",
            "items (int) –",
            "Callable[[TypeVar(T)], TypeVar(T)]",
            "A decorator that adds a cooldown to a command",
            "A cooldown allows a command to only be used a specific amount\nof times in a specific time frame. These cooldowns can be based\neither on a per-guild, per-channel, per-user, per-role or global basis.\nDenoted by the third argument of type which must be of enum\ntype BucketType.",
            "If a cooldown is triggered, then CommandOnCooldown is triggered in\non_command_error() and the local error handler.",
            "A command can only have a single cooldown.",
            "rate (int) – The number of times a command can be used before triggering a cooldown.",
            "per (float) – The amount of seconds to wait for a cooldown when it’s been triggered.",
            "type (Union[BucketType, Callable[[Message], Any]]) – The type of cooldown to have. If callable, should return a key for the mapping.\n\nChanged in version 1.7: Callables are now supported for custom bucket types.",
            "The type of cooldown to have. If callable, should return a key for the mapping.",
            "Changed in version 1.7: Callables are now supported for custom bucket types.",
            "Callable[[T], T]",
            "A decorator that adds a dynamic cooldown to a command",
            "This differs from cooldown() in that it takes a function that\naccepts a single parameter of type discord.Message and must\nreturn a Cooldown or None. If None is returned then\nthat cooldown is effectively bypassed.",
            "A cooldown allows a command to only be used a specific amount\nof times in a specific time frame. These cooldowns can be based\neither on a per-guild, per-channel, per-user, per-role or global basis.\nDenoted by the third argument of type which must be of enum\ntype BucketType.",
            "If a cooldown is triggered, then CommandOnCooldown is triggered in\non_command_error() and the local error handler.",
            "A command can only have a single cooldown.",
            "New in version 2.0.",
            "cooldown (Callable[[discord.Message], Optional[Cooldown]]) – A function that takes a message and returns a cooldown that will\napply to this invocation or None if the cooldown should be bypassed.",
            "type (BucketType) – The type of cooldown to have.",
            "Callable[[T], T]",
            "A decorator that adds a maximum concurrency to a command",
            "This enables you to only allow a certain number of command invocations at the same time,\nfor example if a command takes too long or if only one user can use it at a time. This\ndiffers from a cooldown in that there is no set waiting period or token bucket – only\na set number of people can run the command.",
            "New in version 1.3.",
            "number (int) – The maximum number of invocations of this command that can be running at the same time.",
            "per (BucketType) – The bucket that this concurrency is based on, e.g. BucketType.guild would allow\nit to be used up to number times per guild.",
            "wait (bool) – Whether the command should wait for the queue to be over. If this is set to False\nthen instead of waiting until the command can run again, the command raises\nMaxConcurrencyReached to its error handler. If this is set to True\nthen the command waits until it can be executed.",
            "Callable[[TypeVar(T)], TypeVar(T)]",
            "A decorator that registers a coroutine as a pre-invoke hook.",
            "This allows you to refer to one before invoke hook for several commands that\ndo not have to be within the same cog.\n:rtype: Callable[[TypeVar(T)], TypeVar(T)]",
            "New in version 1.4.",
            "Example",
            "A decorator that registers a coroutine as a post-invoke hook.",
            "This allows you to refer to one after invoke hook for several commands that\ndo not have to be within the same cog.\n:rtype: Callable[[TypeVar(T)], TypeVar(T)]",
            "New in version 1.4.",
            "A check() that indicates this command must only be used in a\nguild context only. Basically, no private messages are allowed when\nusing the command.",
            "This check raises a special exception, NoPrivateMessage\nthat is inherited from CheckFailure.",
            "Callable[[TypeVar(T)], TypeVar(T)]",
            "A check() that indicates this command must only be used in a\nDM context. Only private messages are allowed when\nusing the command.",
            "This check raises a special exception, PrivateMessageOnly\nthat is inherited from CheckFailure.\n:rtype: Callable[[TypeVar(T)], TypeVar(T)]",
            "New in version 1.1.",
            "A check() that checks if the person invoking this command is the\nowner of the bot.",
            "This is powered by Bot.is_owner().",
            "This check raises a special exception, NotOwner that is derived\nfrom CheckFailure.",
            "Callable[[TypeVar(T)], TypeVar(T)]",
            "A check() that checks if the channel is a NSFW channel.",
            "This check raises a special exception, NSFWChannelRequired\nthat is derived from CheckFailure.\n:rtype: Callable[[TypeVar(T)], TypeVar(T)]",
            "Changed in version 1.1: Raise NSFWChannelRequired instead of generic CheckFailure.\nDM channels will also now pass this check."
        ],
        "code": [
            "Command",
            "Command.checks",
            "Context",
            "False",
            "CheckFailure",
            "on_command_error()",
            "CommandError",
            "on_command_error()",
            "predicate",
            "def owner_or_permissions(**perms):\n    original = commands.has_permissions(**perms).predicate\n    async def extended_check(ctx):\n        if ctx.guild is None:\n            return False\n        return ctx.guild.owner_id == ctx.author.id or await original(ctx)\n    return commands.check(extended_check)",
            "predicate",
            "predicate",
            "def check_if_it_is_me(ctx):\n    return ctx.message.author.id == 85309593344815104\n\n@bot.command()\n@commands.check(check_if_it_is_me)\nasync def only_for_me(ctx):\n    await ctx.send('I know you!')",
            "def is_me():\n    def predicate(ctx):\n        return ctx.message.author.id == 85309593344815104\n    return commands.check(predicate)\n\n@bot.command()\n@is_me()\nasync def only_me(ctx):\n    await ctx.send('Only you!')",
            "Context",
            "bool",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "check()",
            "CheckAnyFailure",
            "CheckFailure",
            "predicate",
            "Context",
            "bool",
            "check()",
            "check()",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "def is_guild_owner():\n    def predicate(ctx):\n        return ctx.guild is not None and ctx.guild.owner_id == ctx.author.id\n    return commands.check(predicate)\n\n@bot.command()\n@commands.check_any(commands.is_owner(), is_guild_owner())\nasync def only_for_owners(ctx):\n    await ctx.send('Hello mister owner!')",
            "check()",
            "False",
            "MissingRole",
            "NoPrivateMessage",
            "CheckFailure",
            "MissingRole",
            "NoPrivateMessage",
            "CheckFailure",
            "int",
            "str",
            "check()",
            "discord.Permissions",
            "MissingPermissions",
            "CheckFailure",
            "True",
            "str",
            "bool",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "@bot.command()\n@commands.has_permissions(manage_messages=True)\nasync def test(ctx):\n    await ctx.send('You can manage messages.')",
            "has_permissions()",
            "NoPrivateMessage",
            "bool",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "check()",
            "has_role()",
            "MissingAnyRole",
            "NoPrivateMessage",
            "CheckFailure",
            "MissingAnyRole",
            "NoPrivateMessage",
            "CheckFailure",
            "str",
            "int",
            "@bot.command()\n@commands.has_any_role('Library Devs', 'Moderators', 492212595072434186)\nasync def cool(ctx):\n    await ctx.send('You are cool indeed')",
            "has_role()",
            "BotMissingRole",
            "NoPrivateMessage",
            "CheckFailure",
            "BotMissingRole",
            "NoPrivateMessage",
            "CheckFailure",
            "int",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "has_permissions()",
            "BotMissingPermissions",
            "CheckFailure",
            "bool",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "has_guild_permissions()",
            "bool",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "has_any_role()",
            "BotMissingAnyRole",
            "NoPrivateMessage",
            "CheckFailure",
            "BotMissingAnyRole",
            "NoPrivateMessage",
            "CheckFailure",
            "int",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "type",
            "BucketType",
            "CommandOnCooldown",
            "on_command_error()",
            "int",
            "float",
            "BucketType",
            "Message",
            "cooldown()",
            "discord.Message",
            "Cooldown",
            "None",
            "None",
            "type",
            "BucketType",
            "CommandOnCooldown",
            "on_command_error()",
            "discord.Message",
            "Cooldown",
            "None",
            "BucketType",
            "int",
            "BucketType",
            "BucketType.guild",
            "number",
            "bool",
            "False",
            "MaxConcurrencyReached",
            "True",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "async def record_usage(ctx):\n    print(ctx.author, 'used', ctx.command, 'at', ctx.message.created_at)\n\n@bot.command()\n@commands.before_invoke(record_usage)\nasync def who(ctx): # Output: <User> used who at <Time>\n    await ctx.send('I am a bot')\n\nclass What(commands.Cog):\n\n    @commands.before_invoke(record_usage)\n    @commands.command()\n    async def when(self, ctx): # Output: <User> used when at <Time>\n        await ctx.send(f'and I have existed since {ctx.bot.user.created_at}')\n\n    @commands.command()\n    async def where(self, ctx): # Output: <Nothing>\n        await ctx.send('on Discord')\n\n    @commands.command()\n    async def why(self, ctx): # Output: <Nothing>\n        await ctx.send('because someone made me')\n\nbot.add_cog(What())",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "check()",
            "NoPrivateMessage",
            "CheckFailure",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "check()",
            "PrivateMessageOnly",
            "CheckFailure",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "check()",
            "Bot.is_owner()",
            "NotOwner",
            "CheckFailure",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "check()",
            "NSFWChannelRequired",
            "CheckFailure",
            "Callable",
            "TypeVar",
            "T",
            "TypeVar",
            "T",
            "NSFWChannelRequired",
            "CheckFailure"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Cooldown#",
        "content": [
            "Represents a cooldown for a command.",
            "The total number of tokens available per per seconds.",
            "int",
            "The length of the cooldown period in seconds.",
            "float",
            "rate (float) –",
            "per (float) –",
            "Returns the number of available tokens before rate limiting is applied.",
            "current (Optional[float]) – The time in seconds since Unix epoch to calculate tokens at.\nIf not supplied then time.time() is used.",
            "The number of tokens available before the cooldown is to be applied.",
            "int",
            "Returns the time in seconds until the cooldown will be reset.",
            "current (Optional[float]) – The current time in seconds since Unix epoch.\nIf not supplied, then time.time() is used.",
            "The number of seconds to wait before this cooldown will be reset.",
            "float",
            "Updates the cooldown rate limit.",
            "current (Optional[float]) – The time in seconds since Unix epoch to update the rate limit at.\nIf not supplied, then time.time() is used.",
            "The retry-after time in seconds if rate limited.",
            "Optional[float]",
            "Reset the cooldown to its initial state.",
            "None",
            "Creates a copy of this cooldown.",
            "A new instance of this cooldown.",
            "Cooldown"
        ],
        "code": [
            "per",
            "int",
            "float",
            "float",
            "float",
            "float",
            "time.time()",
            "int",
            "float",
            "time.time()",
            "float",
            "float",
            "time.time()",
            "float",
            "None",
            "Cooldown"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Context#",
        "content": [
            "Represents the context in which a command is being invoked under.",
            "This class contains a lot of metadata to help you understand more about\nthe invocation context. This class is not created manually and is instead\npassed around to commands as the first parameter.",
            "This class implements the Messageable ABC.",
            "The message that triggered the command being executed.",
            "Message",
            "The bot that contains the command being executed.",
            "Bot",
            "The list of transformed arguments that were passed into the command.\nIf this is accessed during the on_command_error() event\nthen this list could be incomplete.",
            "list",
            "A dictionary of transformed arguments that were passed into the command.\nSimilar to args, if this is accessed in the\non_command_error() event then this dict could be incomplete.",
            "dict",
            "The parameter that is currently being inspected and converted.\nThis is only of use for within converters.",
            "New in version 2.0.",
            "Optional[inspect.Parameter]",
            "The prefix that was used to invoke the command.",
            "Optional[str]",
            "The command that is being invoked currently.",
            "Optional[Command]",
            "The command name that triggered this invocation. Useful for finding out\nwhich alias called the command.",
            "Optional[str]",
            "The command names of the parents that triggered this invocation. Useful for\nfinding out which aliases called the command.",
            "For example in commands ?a b c test, the invoked parents are ['a', 'b', 'c'].",
            "New in version 1.7.",
            "List[str]",
            "The subcommand that was invoked.\nIf no valid subcommand was invoked then this is equal to None.",
            "Optional[Command]",
            "The string that was attempted to call a subcommand. This does not have\nto point to a valid registered subcommand and could just point to a\nnonsense string. If nothing was passed to attempt a call to a\nsubcommand then this is set to None.",
            "Optional[str]",
            "A boolean that indicates if the command failed to be parsed, checked,\nor invoked.",
            "bool",
            "Returns an AsyncIterator that enables receiving the destination’s message history.",
            "You must have read_message_history permissions to use this.",
            "limit (Optional[int]) – The number of messages to retrieve.\nIf None, retrieves every message in the channel. Note, however,\nthat this would make it a slow operation.",
            "before (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages before this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages after this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "around (Optional[Union[Snowflake, datetime.datetime]]) – Retrieve messages around this date or message.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.\nWhen using this argument, the maximum limit is 101. Note that if the limit is an\neven number, then this will return at most limit + 1 messages.",
            "oldest_first (Optional[bool]) – If set to True, return messages in oldest->newest order. Defaults to True if\nafter is specified, otherwise False.",
            "Message – The message with the message data parsed.",
            "Forbidden – You do not have permissions to get channel message history.",
            "HTTPException – The request to get message history failed.",
            "HistoryIterator",
            "Examples",
            "Usage",
            "Flattening into a list:",
            "All parameters are optional.",
            "Returns a context manager that allows you to type for an indefinite period of time.",
            "This is useful for denoting long computations in your bot.\n:rtype: Typing",
            "Note",
            "This is both a regular context manager and an async context manager.\nThis means that both with and async with work with this.",
            "Example Usage:",
            "This function is a coroutine.",
            "Calls a command with the arguments given.",
            "This is useful if you want to just call the callback that a\nCommand holds internally.",
            "Note",
            "This does not handle converters, checks, cooldowns, pre-invoke,\nor after-invoke hooks in any matter. It calls the internal callback\ndirectly as-if it was a regular function.",
            "You must take care in passing the proper arguments when\nusing this function.",
            "command (Command) – The command that is going to be called.",
            "*args – The arguments to use.",
            "**kwargs – The keyword arguments to use.",
            "TypeError – The command argument to invoke is missing.",
            "This function is a coroutine.",
            "Calls the command again.",
            "This is similar to invoke() except that it bypasses\nchecks, cooldowns, and error handlers.",
            "Note",
            "If you want to bypass UserInputError derived exceptions,\nit is recommended to use the regular invoke()\nas it will work more naturally. After all, this will end up\nusing the old arguments the user has used and will thus just\nfail again.",
            "call_hooks (bool) – Whether to call the before and after invoke hooks.",
            "restart (bool) – Whether to start the call chain from the very beginning\nor where we left off (i.e. the command that caused the error).\nThe default is to start where we left off.",
            "ValueError – The context to reinvoke is not valid.",
            "None",
            "Checks if the invocation context is valid to be invoked with.",
            "The cleaned up invoke prefix. i.e. mentions are @name instead of <@id>.",
            "New in version 2.0.",
            "Returns the cog associated with this context’s command.\nNone if it does not exist.",
            "Returns the guild associated with this context’s command.\nNone if not available.",
            "Returns the channel associated with this context’s command.\nShorthand for Message.channel.",
            "Union[User, Member]:\nReturns the author associated with this context’s command. Shorthand for Message.author",
            "Union[Member, ClientUser]:\nSimilar to Guild.me except it may return the ClientUser in private message\nmessage contexts, or when Intents.guilds() is absent.",
            "A shortcut to Guild.voice_client, if applicable.",
            "This function is a coroutine.",
            "Shows the help command for the specified entity if given.\nThe entity can be a command or a cog.",
            "If no entity is given, then it’ll show help for the\nentire bot.",
            "If the entity is a string, then it looks up whether it’s a\nCog or a Command.",
            "Note",
            "Due to the way this function works, instead of returning\nsomething similar to command_not_found()\nthis returns None on bad input or no help command.",
            "entity (Optional[Union[Command, Cog, str]]) – The entity to show help for.",
            "args (Any) –",
            "The result of the help command, if any.",
            "Any",
            "Returns a bool indicating whether you have the permissions to send the object(s).",
            "Indicates whether you have the permissions to send the object(s).",
            "bool",
            "TypeError – An invalid type has been passed.",
            "This function is a coroutine.",
            "Retrieves a single Message from the destination.",
            "id (int) – The message ID to look for.",
            "The message asked for.",
            "Message",
            "NotFound – The specified message was not found.",
            "Forbidden – You do not have the permissions required to get a message.",
            "HTTPException – Retrieving the message failed.",
            "This function is a coroutine.",
            "Retrieves all messages that are currently pinned in the channel.",
            "Note",
            "Due to a limitation with the Discord API, the Message\nobjects returned by this method do not contain complete\nMessage.reactions data.",
            "The messages that are currently pinned.",
            "List[Message]",
            "HTTPException – Retrieving the pinned messages failed.",
            "This function is a coroutine.",
            "A shortcut method to abc.Messageable.send() to reply to the\nMessage.",
            "New in version 1.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size, or\n    you specified both file and files.",
            "content (str | None) –",
            "kwargs (Any) –",
            "This function is a coroutine.",
            "Sends a message to the destination with the content given.",
            "The content must be a type that can convert to a string through str(content).\nIf the content is set to None (the default), then the embed parameter must\nbe provided.",
            "To upload a single file, the file parameter should be used with a\nsingle File object. To upload multiple files, the files\nparameter should be used with a list of File objects.\nSpecifying both parameters will lead to an exception.",
            "To upload a single embed, the embed parameter should be used with a\nsingle Embed object. To upload multiple embeds, the embeds\nparameter should be used with a list of Embed objects.\nSpecifying both parameters will lead to an exception.",
            "content (Optional[str]) – The content of the message to send.",
            "tts (bool) – Indicates if the message should be sent using text-to-speech.",
            "embed (Embed) – The rich embed for the content.",
            "file (File) – The file to upload.",
            "files (List[File]) – A list of files to upload. Must be a maximum of 10.",
            "nonce (Union[str, int]) – The nonce to use for sending this message. If the message was successfully sent,\nthen the message will have a nonce with this value.",
            "enforce_nonce (Optional[bool]) – Whether nonce is enforced to be validated.\n\nNew in version 2.5.",
            "Whether nonce is enforced to be validated.",
            "New in version 2.5.",
            "delete_after (float) – If provided, the number of seconds to wait in the background\nbefore deleting the message we just sent. If the deletion fails,\nthen it is silently ignored.",
            "allowed_mentions (AllowedMentions) – Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.\n\nNew in version 1.4.",
            "Controls the mentions being processed in this message. If this is\npassed, then the object is merged with allowed_mentions.\nThe merging behaviour only overrides attributes that have been explicitly passed\nto the object, otherwise it uses the attributes set in allowed_mentions.\nIf no object is passed at all then the defaults given by allowed_mentions\nare used instead.",
            "New in version 1.4.",
            "reference (Union[Message, MessageReference, PartialMessage]) – A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.\n\nNew in version 1.6.",
            "A reference to the Message to which you are replying, this can be created using\nto_reference() or passed directly as a Message. You can control\nwhether this mentions the author of the referenced message using the\nreplied_user attribute of allowed_mentions or by\nsetting mention_author.",
            "New in version 1.6.",
            "mention_author (Optional[bool]) – If set, overrides the replied_user attribute of allowed_mentions.\n\nNew in version 1.6.",
            "If set, overrides the replied_user attribute of allowed_mentions.",
            "New in version 1.6.",
            "view (discord.ui.View) – A Discord UI View to add to the message.",
            "embeds (List[Embed]) – A list of embeds to upload. Must be a maximum of 10.\n\nNew in version 2.0.",
            "A list of embeds to upload. Must be a maximum of 10.",
            "New in version 2.0.",
            "stickers (Sequence[Union[GuildSticker, StickerItem]]) – A list of stickers to upload. Must be a maximum of 3.\n\nNew in version 2.0.",
            "A list of stickers to upload. Must be a maximum of 3.",
            "New in version 2.0.",
            "suppress (bool) – Whether to suppress embeds for the message.",
            "silent (bool) – Whether to suppress push and desktop notifications for the message.\n\nNew in version 2.4.",
            "Whether to suppress push and desktop notifications for the message.",
            "New in version 2.4.",
            "poll (Poll) – The poll to send.\n\nNew in version 2.6.",
            "The poll to send.",
            "New in version 2.6.",
            "The message that was sent.",
            "Message",
            "HTTPException – Sending the message failed.",
            "Forbidden – You do not have the proper permissions to send the message.",
            "InvalidArgument – The files list is not of the appropriate size,\n    you specified both file and files,\n    or you specified both embed and embeds,\n    or the reference object is not a Message,\n    MessageReference or PartialMessage.",
            "This function is a coroutine.",
            "Triggers a typing indicator to the destination.",
            "Typing indicator will go away after 10 seconds, or after a message is sent.",
            "None"
        ],
        "code": [
            "Messageable",
            "Message",
            "Bot",
            "on_command_error()",
            "list",
            "args",
            "on_command_error()",
            "dict",
            "inspect.Parameter",
            "str",
            "Command",
            "str",
            "?a b c test",
            "['a', 'b', 'c']",
            "str",
            "None",
            "Command",
            "None",
            "str",
            "bool",
            "AsyncIterator",
            "read_message_history",
            "int",
            "None",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "Snowflake",
            "datetime.datetime",
            "bool",
            "True",
            "True",
            "after",
            "False",
            "Message",
            "counter = 0\nasync for message in channel.history(limit=200):\n    if message.author == client.user:\n        counter += 1",
            "messages = await channel.history(limit=123).flatten()\n# messages is now a list of Message...",
            "Typing",
            "with",
            "async with",
            "async with channel.typing():\n    # simulate something heavy\n    await asyncio.sleep(10)\n\nawait channel.send('done!')",
            "Command",
            "Command",
            "invoke()",
            "UserInputError",
            "invoke()",
            "bool",
            "bool",
            "None",
            "@name",
            "<@id>",
            "Message.channel",
            "User",
            "Member",
            "Message.author",
            "Member",
            "ClientUser",
            "Guild.me",
            "ClientUser",
            "Intents.guilds()",
            "Guild.voice_client",
            "Cog",
            "Command",
            "command_not_found()",
            "None",
            "Command",
            "Cog",
            "str",
            "Any",
            "bool",
            "bool",
            "Message",
            "int",
            "Message",
            "Message",
            "Message.reactions",
            "Message",
            "abc.Messageable.send()",
            "Message",
            "Message",
            "files",
            "file",
            "files",
            "str(content)",
            "None",
            "embed",
            "file",
            "File",
            "files",
            "list",
            "File",
            "embed",
            "Embed",
            "embeds",
            "list",
            "Embed",
            "str",
            "bool",
            "Embed",
            "File",
            "File",
            "str",
            "int",
            "bool",
            "nonce",
            "float",
            "AllowedMentions",
            "allowed_mentions",
            "allowed_mentions",
            "allowed_mentions",
            "Message",
            "MessageReference",
            "PartialMessage",
            "Message",
            "to_reference()",
            "Message",
            "replied_user",
            "allowed_mentions",
            "mention_author",
            "bool",
            "replied_user",
            "allowed_mentions",
            "discord.ui.View",
            "Embed",
            "GuildSticker",
            "StickerItem",
            "bool",
            "bool",
            "Poll",
            "Message",
            "files",
            "file",
            "files",
            "embed",
            "embeds",
            "reference",
            "Message",
            "MessageReference",
            "PartialMessage",
            "None"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Converters#",
        "content": [
            "The base class of custom converters that require the Context\nto be passed to be useful.",
            "This allows you to implement converters that function similar to the\nspecial cased discord classes.",
            "Classes that derive from this should override the convert()\nmethod to do its conversion logic. This method must be a coroutine.",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "TypeVar(T_co, covariant=True)",
            "Converts to a Object.",
            "The argument must follow the valid ID or mention formats (e.g. <@80088516616269824>).",
            "New in version 2.0.",
            "The lookup strategy is as follows (in order):",
            "Lookup by ID.",
            "Lookup by member, role, or channel mention.",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "Object",
            "Converts to a Member.",
            "All lookups are via the local guild. If in a DM context, then the lookup\nis done by the global cache.",
            "The lookup strategy is as follows (in order):",
            "Lookup by ID.",
            "Lookup by mention.",
            "Lookup by name#discrim",
            "Lookup by name",
            "Lookup by nickname",
            "Changed in version 1.5: Raise MemberNotFound instead of generic BadArgument",
            "Changed in version 1.5.1: This converter now lazily fetches members from the gateway and HTTP APIs,\noptionally caching the result if MemberCacheFlags.joined is enabled.",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "Member",
            "Converts to a User.",
            "All lookups are via the global user cache.",
            "The lookup strategy is as follows (in order):",
            "Lookup by ID.",
            "Lookup by mention.",
            "Lookup by name#discrim",
            "Lookup by name",
            "Changed in version 1.5: Raise UserNotFound instead of generic BadArgument",
            "Changed in version 1.6: This converter now lazily fetches users from the HTTP APIs if an ID is\npassed, and it’s not available in cache.",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "User",
            "Converts to a discord.Message.",
            "New in version 1.1.",
            "The lookup strategy is as follows (in order):",
            "Lookup by “{channel ID}-{message ID}” (retrieved by shift-clicking on “Copy ID”)",
            "Lookup by message ID (the message must be in the context channel)",
            "Lookup by message URL",
            "Changed in version 1.5: Raise ChannelNotFound, MessageNotFound or ChannelNotReadable\ninstead of generic BadArgument",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "Message",
            "Converts to a discord.PartialMessage.",
            "New in version 1.7.",
            "The creation strategy is as follows (in order):",
            "By “{channel ID}-{message ID}” (retrieved by shift-clicking on “Copy ID”)",
            "By message ID (The message is assumed to be in the context channel.)",
            "By message URL",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "PartialMessage",
            "Converts to a GuildChannel.",
            "All lookups are via the local guild. If in a DM context, then the lookup\nis done by the global cache.",
            "The lookup strategy is as follows (in order):",
            "Lookup by ID.",
            "Lookup by mention.",
            "Lookup by name.",
            "New in version 2.0.",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "GuildChannel",
            "Converts to a TextChannel.",
            "All lookups are via the local guild. If in a DM context, then the lookup\nis done by the global cache.",
            "The lookup strategy is as follows (in order):",
            "Lookup by ID.",
            "Lookup by mention.",
            "Lookup by name",
            "Changed in version 1.5: Raise ChannelNotFound instead of generic BadArgument",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "TextChannel",
            "Converts to a VoiceChannel.",
            "All lookups are via the local guild. If in a DM context, then the lookup\nis done by the global cache.",
            "The lookup strategy is as follows (in order):",
            "Lookup by ID.",
            "Lookup by mention.",
            "Lookup by name",
            "Changed in version 1.5: Raise ChannelNotFound instead of generic BadArgument",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "VoiceChannel",
            "Converts to a StageChannel.",
            "New in version 1.7.",
            "All lookups are via the local guild. If in a DM context, then the lookup\nis done by the global cache.",
            "The lookup strategy is as follows (in order):",
            "Lookup by ID.",
            "Lookup by mention.",
            "Lookup by name",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "StageChannel",
            "Converts to a CategoryChannel.",
            "All lookups are via the local guild. If in a DM context, then the lookup\nis done by the global cache.",
            "The lookup strategy is as follows (in order):",
            "Lookup by ID.",
            "Lookup by mention.",
            "Lookup by name",
            "Changed in version 1.5: Raise ChannelNotFound instead of generic BadArgument",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "CategoryChannel",
            "Converts to a ForumChannel.",
            "All lookups are via the local guild. If in a DM context, then the lookup\nis done by the global cache.",
            "The lookup strategy is as follows (in order):",
            "Lookup by ID.",
            "Lookup by mention.",
            "Lookup by name",
            "New in version 2.0.",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "ForumChannel",
            "Converts to a Invite.",
            "This is done via an HTTP request using Bot.fetch_invite().",
            "Changed in version 1.5: Raise BadInviteArgument instead of generic BadArgument",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "Invite",
            "Converts to a Guild.",
            "The lookup strategy is as follows (in order):",
            "Lookup by ID.",
            "Lookup by name. (There is no disambiguation for Guilds with multiple matching names).",
            "New in version 1.7.",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "Guild",
            "Converts to a Role.",
            "All lookups are via the local guild. If in a DM context, the converter raises\nNoPrivateMessage exception.",
            "The lookup strategy is as follows (in order):",
            "Lookup by ID.",
            "Lookup by mention.",
            "Lookup by name",
            "Changed in version 1.5: Raise RoleNotFound instead of generic BadArgument",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "Role",
            "Converts to Game.",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "Game",
            "Converts to a Colour.",
            "Changed in version 1.5: Add an alias named ColorConverter",
            "The following formats are accepted:",
            "0x<hex>",
            "#<hex>",
            "0x#<hex>",
            "rgb(<number>, <number>, <number>)",
            "Any of the classmethod in Colour",
            "The _ in the name can be optionally replaced with spaces.",
            "Like CSS, <number> can be either 0-255 or 0-100% and <hex> can be\neither a 6 digit hex number or a 3 digit hex shortcut (e.g. #fff).",
            "Changed in version 1.5: Raise BadColourArgument instead of generic BadArgument",
            "Changed in version 1.7: Added support for rgb function and 3-digit hex shortcuts",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "Colour",
            "Converts to a Emoji.",
            "All lookups are done for the local guild first, if available. If that lookup\nfails, then it checks the client’s global cache.",
            "The lookup strategy is as follows (in order):",
            "Lookup by ID.",
            "Lookup by extracting ID from the emoji.",
            "Lookup by name",
            "Changed in version 1.5: Raise EmojiNotFound instead of generic BadArgument",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "Emoji",
            "Converts to a PartialEmoji.",
            "This is done by extracting the animated flag, name and ID from the emoji.",
            "Changed in version 1.5: Raise PartialEmojiConversionFailure instead of generic BadArgument",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "PartialEmoji",
            "Coverts to a Thread.",
            "All lookups are via the local guild.",
            "The lookup strategy is as follows (in order):",
            "Lookup by ID.",
            "Lookup by mention.",
            "Lookup by name.",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "Thread",
            "Converts to a GuildSticker.",
            "All lookups are done for the local guild first, if available. If that lookup\nfails, then it checks the client’s global cache.",
            "The lookup strategy is as follows (in order):",
            "1. Lookup by ID.\n3. Lookup by name",
            "New in version 2.0.",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "GuildSticker",
            "Converts the argument to mention scrubbed version of\nsaid content.",
            "This behaves similarly to clean_content.",
            "Whether to clean channel mentions.",
            "bool",
            "Whether to use nicknames when transforming mentions.",
            "bool",
            "Whether to also escape special markdown characters.",
            "bool",
            "Whether to also remove special markdown characters. This option is not supported with escape_markdown",
            "New in version 1.7.",
            "bool",
            "fix_channel_mentions (bool) –",
            "use_nicknames (bool) –",
            "escape_markdown (bool) –",
            "remove_markdown (bool) –",
            "This function is a coroutine.",
            "The method to override to do conversion logic.",
            "If an error is found while converting, it is recommended to\nraise a CommandError derived exception as it will\nproperly propagate to the error handlers.",
            "ctx (Context) – The invocation context that the argument is being used in.",
            "argument (str) – The argument that is being converted.",
            ".CommandError – A generic exception occurred when converting the argument.",
            ".BadArgument – The converter failed to convert the argument.",
            "str",
            "A special converter that greedily consumes arguments until it can’t.\nAs a consequence of this behaviour, most input errors are silently discarded,\nsince it is used as an indicator of when to stop parsing.",
            "When a parser error is met the greedy converter stops converting, undoes the\ninternal string parsing routine, and continues parsing regularly.",
            "For example, in the following code:",
            "An invocation of [p]test 1 2 3 4 5 6 hello would pass numbers with\n[1, 2, 3, 4, 5, 6] and reason with hello.",
            "For more information, check Special Converters.",
            "converter (TypeVar(T)) –",
            "This function is a coroutine.",
            "Runs converters for a given converter, argument, and parameter.",
            "This function does the same work that the library does under the hood.",
            "New in version 2.0.",
            "ctx (Context) – The invocation context to run the converters under.",
            "converter (Any) – The converter to run, this corresponds to the annotation in the function.",
            "argument (Optional[str]) – The argument to convert to.",
            "param (inspect.Parameter) – The parameter being converted. This is mainly for error reporting.",
            "The resulting conversion.",
            "Any",
            "CommandError – The converter failed to convert."
        ],
        "code": [
            "Context",
            "discord",
            "convert()",
            "CommandError",
            "Context",
            "str",
            "TypeVar",
            "T_co",
            "Object",
            "CommandError",
            "Context",
            "str",
            "Object",
            "Member",
            "MemberNotFound",
            "BadArgument",
            "MemberCacheFlags.joined",
            "CommandError",
            "Context",
            "str",
            "Member",
            "User",
            "UserNotFound",
            "BadArgument",
            "CommandError",
            "Context",
            "str",
            "User",
            "discord.Message",
            "ChannelNotFound",
            "MessageNotFound",
            "ChannelNotReadable",
            "BadArgument",
            "CommandError",
            "Context",
            "str",
            "Message",
            "discord.PartialMessage",
            "CommandError",
            "Context",
            "str",
            "PartialMessage",
            "GuildChannel",
            "CommandError",
            "Context",
            "str",
            "GuildChannel",
            "TextChannel",
            "ChannelNotFound",
            "BadArgument",
            "CommandError",
            "Context",
            "str",
            "TextChannel",
            "VoiceChannel",
            "ChannelNotFound",
            "BadArgument",
            "CommandError",
            "Context",
            "str",
            "VoiceChannel",
            "StageChannel",
            "CommandError",
            "Context",
            "str",
            "StageChannel",
            "CategoryChannel",
            "ChannelNotFound",
            "BadArgument",
            "CommandError",
            "Context",
            "str",
            "CategoryChannel",
            "ForumChannel",
            "CommandError",
            "Context",
            "str",
            "ForumChannel",
            "Invite",
            "Bot.fetch_invite()",
            "BadInviteArgument",
            "BadArgument",
            "CommandError",
            "Context",
            "str",
            "Invite",
            "Guild",
            "CommandError",
            "Context",
            "str",
            "Guild",
            "Role",
            "NoPrivateMessage",
            "RoleNotFound",
            "BadArgument",
            "CommandError",
            "Context",
            "str",
            "Role",
            "Game",
            "CommandError",
            "Context",
            "str",
            "Game",
            "Colour",
            "0x<hex>",
            "#<hex>",
            "0x#<hex>",
            "rgb(<number>, <number>, <number>)",
            "classmethod",
            "Colour",
            "_",
            "<number>",
            "<hex>",
            "BadColourArgument",
            "BadArgument",
            "rgb",
            "CommandError",
            "Context",
            "str",
            "Colour",
            "Emoji",
            "EmojiNotFound",
            "BadArgument",
            "CommandError",
            "Context",
            "str",
            "Emoji",
            "PartialEmoji",
            "PartialEmojiConversionFailure",
            "BadArgument",
            "CommandError",
            "Context",
            "str",
            "PartialEmoji",
            "Thread",
            "CommandError",
            "Context",
            "str",
            "Thread",
            "GuildSticker",
            "CommandError",
            "Context",
            "str",
            "GuildSticker",
            "clean_content",
            "bool",
            "bool",
            "bool",
            "escape_markdown",
            "bool",
            "bool",
            "bool",
            "bool",
            "bool",
            "CommandError",
            "Context",
            "str",
            "str",
            "@commands.command()\nasync def test(ctx, numbers: Greedy[int], reason: str):\n    await ctx.send(\"numbers: {}, reason: {}\".format(numbers, reason))",
            "[p]test 1 2 3 4 5 6 hello",
            "numbers",
            "[1, 2, 3, 4, 5, 6]",
            "reason",
            "hello",
            "TypeVar",
            "T",
            "Context",
            "str",
            "inspect.Parameter"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Flag Converter#",
        "content": [
            "A converter that allows for a user-friendly flag syntax.",
            "The flags are defined using PEP 526 type annotations similar\nto the dataclasses Python module. For more information on\nhow this converter works, check the appropriate\ndocumentation.",
            "Returns an iterator of (flag_name, flag_value) pairs. This allows it\nto be, for example, constructed as a dict or a list of pairs.\nNote that aliases are not shown.",
            "New in version 2.0.",
            "case_insensitive (bool) – A class parameter to toggle case insensitivity of the flag parsing.\nIf True then flags are parsed in a case-insensitive manner.\nDefaults to False.",
            "prefix (str) – The prefix that all flags must be prefixed with. By default,\nthere is no prefix.",
            "delimiter (str) – The delimiter that separates a flag’s argument from the flag’s name.\nBy default, this is :.",
            "A mapping of flag name to flag object this converter has.",
            "This function is a coroutine.",
            "The method that actually converters an argument to the flag mapping.",
            "cls (Type[FlagConverter]) – The flag converter class.",
            "ctx (Context) – The invocation context.",
            "argument (str) – The argument to convert from.",
            "The flag converter instance with all flags parsed.",
            "FlagConverter",
            "FlagError – A flag related parsing error.",
            "CommandError – A command related error.",
            "Represents a flag parameter for FlagConverter.",
            "The flag() function helps\ncreate these flag objects, but it is not necessary to\ndo so. These cannot be constructed manually.",
            "The name of the flag.",
            "str",
            "The aliases of the flag name.",
            "List[str]",
            "The attribute in the class that corresponds to this flag.",
            "str",
            "The default value of the flag, if available.",
            "Any",
            "The underlying evaluated annotation of the flag.",
            "Any",
            "The maximum number of arguments the flag can accept.\nA negative value indicates an unlimited amount of arguments.",
            "int",
            "Whether multiple given values overrides the previous value.",
            "bool",
            "Whether the flag is required.",
            "A required flag has no default value.",
            "Override default functionality and parameters of the underlying FlagConverter\nclass attributes.",
            "name (str) – The flag name. If not given, defaults to the attribute name.",
            "aliases (List[str]) – Aliases to the flag name. If not given, no aliases are set.",
            "default (Any) – The default parameter. This could be either a value or a callable that takes\nContext as its sole parameter. If not given then it defaults to\nthe default value given to the attribute.",
            "max_args (int) – The maximum number of arguments the flag can accept.\nA negative value indicates an unlimited amount of arguments.\nThe default value depends on the annotation given.",
            "override (bool) – Whether multiple given values overrides the previous value. The default\nvalue depends on the annotation given."
        ],
        "code": [
            "dataclasses",
            "(flag_name, flag_value)",
            "bool",
            "True",
            "False",
            "str",
            "str",
            ":",
            "FlagConverter",
            "Context",
            "str",
            "FlagConverter",
            "FlagConverter",
            "flag()",
            "str",
            "str",
            "str",
            "int",
            "bool",
            "FlagConverter",
            "str",
            "str",
            "Context",
            "int",
            "bool"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Exceptions#",
        "content": [
            "The base exception type for all command related errors.",
            "This inherits from discord.DiscordException.",
            "This exception and exceptions inherited from it are handled\nin a special way as they are caught and passed into a special event\nfrom Bot, on_command_error().",
            "message (str | None) –",
            "args (Any) –",
            "Exception raised when a Converter class raises non-CommandError.",
            "This inherits from CommandError.",
            "The converter that failed.",
            "discord.ext.commands.Converter",
            "The original exception that was raised. You can also get this via\nthe __cause__ attribute.",
            "Exception",
            "converter (Converter) –",
            "original (Exception) –",
            "Exception raised when parsing a command and a parameter\nthat is required is not encountered.",
            "This inherits from UserInputError",
            "The argument that is missing.",
            "inspect.Parameter",
            "param (Parameter) –",
            "An exception raised when the parser fails to parse a user’s input.",
            "This inherits from UserInputError.",
            "There are child classes that implement more granular parsing errors for\ni18n purposes.",
            "message (str | None) –",
            "args (Any) –",
            "An exception raised when the parser encounters a quote mark inside a non-quoted string.",
            "This inherits from ArgumentParsingError.",
            "The quote mark that was found inside the non-quoted string.",
            "str",
            "quote (str) –",
            "An exception raised when a space is expected after the closing quote in a string\nbut a different character is found.",
            "This inherits from ArgumentParsingError.",
            "The character found instead of the expected string.",
            "str",
            "char (str) –",
            "An exception raised when a quote character is expected but not found.",
            "This inherits from ArgumentParsingError.",
            "The quote character expected.",
            "str",
            "close_quote (str) –",
            "Exception raised when a parsing or conversion failure is encountered\non an argument to pass into a command.",
            "This inherits from UserInputError",
            "message (str | None) –",
            "args (Any) –",
            "Exception raised when a typing.Union converter fails for all\nits associated types.",
            "This inherits from UserInputError",
            "The parameter that failed being converted.",
            "inspect.Parameter",
            "A tuple of converters attempted in conversion, in order of failure.",
            "Tuple[Type, ...]",
            "A list of errors that were caught from failing the conversion.",
            "List[CommandError]",
            "Exception raised when a typing.Literal converter fails for all\nits associated values.",
            "This inherits from UserInputError",
            "New in version 2.0.",
            "The parameter that failed being converted.",
            "inspect.Parameter",
            "A tuple of values compared against in conversion, in order of failure.",
            "Tuple[Any, ...]",
            "A list of errors that were caught from failing the conversion.",
            "List[CommandError]",
            "Exception raised when an operation does not work outside of private\nmessage contexts.",
            "This inherits from CheckFailure",
            "message (str | None) –",
            "Exception raised when an operation does not work in private message\ncontexts.",
            "This inherits from CheckFailure",
            "message (str | None) –",
            "Exception raised when the predicates in Command.checks have failed.",
            "This inherits from CommandError",
            "message (str | None) –",
            "args (Any) –",
            "Exception raised when all predicates in check_any() fail.",
            "This inherits from CheckFailure.",
            "New in version 1.3.",
            "A list of errors that were caught during execution.",
            "List[CheckFailure]",
            "A list of check predicates that failed.",
            "List[Callable[[Context], bool]]",
            "Exception raised when a command is attempted to be invoked\nbut no command under that name is found.",
            "This is not raised for invalid subcommands, rather just the\ninitial main command that is attempted to be invoked.",
            "This inherits from CommandError.",
            "message (str | None) –",
            "args (Any) –",
            "Exception raised when the command being invoked is disabled.",
            "This inherits from CommandError",
            "message (str | None) –",
            "args (Any) –",
            "Exception raised when the command being invoked raised an exception.",
            "This inherits from CommandError",
            "The original exception that was raised. You can also get this via\nthe __cause__ attribute.",
            "Exception",
            "e (Exception) –",
            "Exception raised when the command was passed too many arguments and its\nCommand.ignore_extra attribute was not set to True.",
            "This inherits from UserInputError",
            "message (str | None) –",
            "args (Any) –",
            "The base exception type for errors that involve errors\nregarding user input.",
            "This inherits from CommandError.",
            "message (str | None) –",
            "args (Any) –",
            "Exception raised when the command being invoked is on cooldown.",
            "This inherits from CommandError",
            "A class with attributes rate and per similar to the\ncooldown() decorator.",
            "Cooldown",
            "The type associated with the cooldown.",
            "BucketType",
            "The amount of seconds to wait before you can retry again.",
            "float",
            "cooldown (Cooldown) –",
            "retry_after (float) –",
            "type (BucketType) –",
            "Exception raised when the command being invoked has reached its maximum concurrency.",
            "This inherits from CommandError.",
            "The maximum number of concurrent invokers allowed.",
            "int",
            "The bucket type passed to the max_concurrency() decorator.",
            "BucketType",
            "number (int) –",
            "per (BucketType) –",
            "Exception raised when the message author is not the owner of the bot.",
            "This inherits from CheckFailure",
            "message (str | None) –",
            "args (Any) –",
            "Exception raised when the message provided was not found in the channel.",
            "This inherits from BadArgument",
            "New in version 1.5.",
            "The message supplied by the caller that was not found",
            "str",
            "argument (str) –",
            "Exception raised when the member provided was not found in the bot’s\ncache.",
            "This inherits from BadArgument",
            "New in version 1.5.",
            "The member supplied by the caller that was not found",
            "str",
            "argument (str) –",
            "Exception raised when the guild provided was not found in the bot’s cache.",
            "This inherits from BadArgument",
            "New in version 1.7.",
            "The guild supplied by the called that was not found",
            "str",
            "argument (str) –",
            "Exception raised when the user provided was not found in the bot’s\ncache.",
            "This inherits from BadArgument",
            "New in version 1.5.",
            "The user supplied by the caller that was not found",
            "str",
            "argument (str) –",
            "Exception raised when the bot can not find the channel.",
            "This inherits from BadArgument",
            "New in version 1.5.",
            "The channel supplied by the caller that was not found",
            "str",
            "argument (str) –",
            "Exception raised when the bot does not have permission to read messages\nin the channel.",
            "This inherits from BadArgument",
            "New in version 1.5.",
            "The channel supplied by the caller that was not readable",
            "Union[abc.GuildChannel, Thread]",
            "argument (GuildChannel | Thread) –",
            "Exception raised when the bot can not find the thread.",
            "This inherits from BadArgument",
            "New in version 2.0.",
            "The thread supplied by the caller that was not found",
            "str",
            "argument (str) –",
            "Exception raised when the colour is not valid.",
            "This inherits from BadArgument",
            "New in version 1.5.",
            "The colour supplied by the caller that was not valid",
            "str",
            "argument (str) –",
            "Exception raised when the bot can not find the role.",
            "This inherits from BadArgument",
            "New in version 1.5.",
            "The role supplied by the caller that was not found",
            "str",
            "argument (str) –",
            "Exception raised when the invite is invalid or expired.",
            "This inherits from BadArgument",
            "New in version 1.5.",
            "argument (str) –",
            "Exception raised when the bot can not find the emoji.",
            "This inherits from BadArgument",
            "New in version 1.5.",
            "The emoji supplied by the caller that was not found",
            "str",
            "argument (str) –",
            "Exception raised when the emoji provided does not match the correct\nformat.",
            "This inherits from BadArgument",
            "New in version 1.5.",
            "The emoji supplied by the caller that did not match the regex",
            "str",
            "argument (str) –",
            "Exception raised when the bot can not find the sticker.",
            "This inherits from BadArgument",
            "New in version 2.0.",
            "The sticker supplied by the caller that was not found",
            "str",
            "argument (str) –",
            "Exception raised when a boolean argument was not convertible.",
            "This inherits from BadArgument",
            "New in version 1.5.",
            "The boolean argument supplied by the caller that is not in the predefined list",
            "str",
            "argument (str) –",
            "Exception raised when the command invoker lacks permissions to run a\ncommand.",
            "This inherits from CheckFailure",
            "The required permissions that are missing.",
            "List[str]",
            "Exception raised when the bot’s member lacks permissions to run a\ncommand.",
            "This inherits from CheckFailure",
            "The required permissions that are missing.",
            "List[str]",
            "Exception raised when the command invoker lacks a role to run a command.",
            "This inherits from CheckFailure",
            "New in version 1.1.",
            "The required role that is missing.\nThis is the parameter passed to has_role().",
            "Union[str, int]",
            "missing_role (Union[str, int]) –",
            "Exception raised when the bot’s member lacks a role to run a command.",
            "This inherits from CheckFailure",
            "New in version 1.1.",
            "The required role that is missing.\nThis is the parameter passed to has_role().",
            "Union[str, int]",
            "missing_role (Union[str, int]) –",
            "Exception raised when the command invoker lacks any of\nthe roles specified to run a command.",
            "This inherits from CheckFailure",
            "New in version 1.1.",
            "The roles that the invoker is missing.\nThese are the parameters passed to has_any_role().",
            "List[Union[str, int]]",
            "missing_roles (List[Union[str, int]]) –",
            "Exception raised when the bot’s member lacks any of\nthe roles specified to run a command.",
            "This inherits from CheckFailure",
            "New in version 1.1.",
            "The roles that the bot’s member is missing.\nThese are the parameters passed to has_any_role().",
            "List[Union[str, int]]",
            "missing_roles (List[Union[str, int]]) –",
            "Exception raised when a channel does not have the required NSFW setting.",
            "This inherits from CheckFailure.",
            "New in version 1.1.",
            "channel (Union[abc.GuildChannel, Thread]) – The channel that does not have NSFW enabled.",
            "The base exception type for all flag parsing related errors.",
            "This inherits from BadArgument.",
            "New in version 2.0.",
            "message (str | None) –",
            "args (Any) –",
            "An exception raised when a flag failed to convert a value.",
            "This inherits from FlagError",
            "New in version 2.0.",
            "The flag that failed to convert.",
            "Flag",
            "flag (Flag) –",
            "An exception raised when a flag did not get a value.",
            "This inherits from FlagError",
            "New in version 2.0.",
            "The flag that did not get a value.",
            "Flag",
            "flag (Flag) –",
            "An exception raised when a flag has received too many values.",
            "This inherits from FlagError.",
            "New in version 2.0.",
            "The flag that received too many values.",
            "Flag",
            "The values that were passed.",
            "List[str]",
            "An exception raised when a required flag was not given.",
            "This inherits from FlagError",
            "New in version 2.0.",
            "The required flag that was not found.",
            "Flag",
            "flag (Flag) –",
            "An exception raised when the command can’t be added\nbecause the name is already taken by a different command.",
            "This inherits from discord.ClientException",
            "New in version 1.4.",
            "The command name that had the error.",
            "str",
            "Whether the name that conflicts is an alias of the command we try to add.",
            "bool",
            "name (str) –",
            "alias_conflict (bool) –"
        ],
        "code": [
            "discord.DiscordException",
            "Bot",
            "on_command_error()",
            "CommandError",
            "discord.ext.commands.Converter",
            "__cause__",
            "Exception",
            "Converter",
            "Exception",
            "UserInputError",
            "inspect.Parameter",
            "Parameter",
            "UserInputError",
            "ArgumentParsingError",
            "str",
            "str",
            "ArgumentParsingError",
            "str",
            "str",
            "ArgumentParsingError",
            "str",
            "str",
            "UserInputError",
            "typing.Union",
            "UserInputError",
            "inspect.Parameter",
            "...",
            "CommandError",
            "typing.Literal",
            "UserInputError",
            "inspect.Parameter",
            "...",
            "CommandError",
            "CheckFailure",
            "CheckFailure",
            "Command.checks",
            "CommandError",
            "check_any()",
            "CheckFailure",
            "CheckFailure",
            "Context",
            "bool",
            "CommandError",
            "CommandError",
            "CommandError",
            "__cause__",
            "Exception",
            "Exception",
            "Command.ignore_extra",
            "True",
            "UserInputError",
            "CommandError",
            "CommandError",
            "rate",
            "per",
            "cooldown()",
            "Cooldown",
            "BucketType",
            "float",
            "Cooldown",
            "float",
            "BucketType",
            "CommandError",
            "int",
            "max_concurrency()",
            "BucketType",
            "int",
            "BucketType",
            "CheckFailure",
            "BadArgument",
            "str",
            "str",
            "BadArgument",
            "str",
            "str",
            "BadArgument",
            "str",
            "str",
            "BadArgument",
            "str",
            "str",
            "BadArgument",
            "str",
            "str",
            "BadArgument",
            "abc.GuildChannel",
            "Thread",
            "BadArgument",
            "str",
            "str",
            "BadArgument",
            "str",
            "str",
            "BadArgument",
            "str",
            "str",
            "BadArgument",
            "str",
            "BadArgument",
            "str",
            "str",
            "BadArgument",
            "str",
            "str",
            "BadArgument",
            "str",
            "str",
            "BadArgument",
            "str",
            "str",
            "CheckFailure",
            "str",
            "CheckFailure",
            "str",
            "CheckFailure",
            "has_role()",
            "str",
            "int",
            "Union",
            "str",
            "int",
            "CheckFailure",
            "has_role()",
            "str",
            "int",
            "Union",
            "str",
            "int",
            "CheckFailure",
            "has_any_role()",
            "str",
            "int",
            "List",
            "Union",
            "str",
            "int",
            "CheckFailure",
            "has_any_role()",
            "str",
            "int",
            "List",
            "Union",
            "str",
            "int",
            "CheckFailure",
            "abc.GuildChannel",
            "Thread",
            "BadArgument",
            "FlagError",
            "Flag",
            "Flag",
            "FlagError",
            "Flag",
            "Flag",
            "FlagError",
            "Flag",
            "str",
            "FlagError",
            "Flag",
            "Flag",
            "discord.ClientException",
            "str",
            "bool",
            "str",
            "bool"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Exception Hierarchy#",
        "content": [
            "ConversionError",
            "MissingRequiredArgument",
            "TooManyArguments",
            "MessageNotFound",
            "MemberNotFound",
            "GuildNotFound",
            "UserNotFound",
            "ChannelNotFound",
            "ChannelNotReadable",
            "BadColourArgument",
            "RoleNotFound",
            "BadInviteArgument",
            "EmojiNotFound",
            "GuildStickerNotFound",
            "PartialEmojiConversionFailure",
            "BadBoolArgument",
            "ThreadNotFound",
            "BadFlagArgument",
            "MissingFlagArgument",
            "TooManyFlags",
            "MissingRequiredFlag",
            "BadUnionArgument",
            "BadLiteralArgument",
            "UnexpectedQuoteError",
            "InvalidEndOfQuotedStringError",
            "ExpectedClosingQuoteError",
            "CommandNotFound",
            "CheckAnyFailure",
            "PrivateMessageOnly",
            "NoPrivateMessage",
            "NotOwner",
            "MissingPermissions",
            "BotMissingPermissions",
            "MissingRole",
            "BotMissingRole",
            "MissingAnyRole",
            "BotMissingAnyRole",
            "NSFWChannelRequired",
            "DisabledCommand",
            "CommandInvokeError",
            "CommandOnCooldown",
            "MaxConcurrencyReached",
            "CommandRegistrationError"
        ],
        "code": [
            "DiscordException",
            "CommandError",
            "ConversionError",
            "UserInputError",
            "MissingRequiredArgument",
            "TooManyArguments",
            "BadArgument",
            "MessageNotFound",
            "MemberNotFound",
            "GuildNotFound",
            "UserNotFound",
            "ChannelNotFound",
            "ChannelNotReadable",
            "BadColourArgument",
            "RoleNotFound",
            "BadInviteArgument",
            "EmojiNotFound",
            "GuildStickerNotFound",
            "PartialEmojiConversionFailure",
            "BadBoolArgument",
            "ThreadNotFound",
            "FlagError",
            "BadFlagArgument",
            "MissingFlagArgument",
            "TooManyFlags",
            "MissingRequiredFlag",
            "BadUnionArgument",
            "BadLiteralArgument",
            "ArgumentParsingError",
            "UnexpectedQuoteError",
            "InvalidEndOfQuotedStringError",
            "ExpectedClosingQuoteError",
            "CommandNotFound",
            "CheckFailure",
            "CheckAnyFailure",
            "PrivateMessageOnly",
            "NoPrivateMessage",
            "NotOwner",
            "MissingPermissions",
            "BotMissingPermissions",
            "MissingRole",
            "BotMissingRole",
            "MissingAnyRole",
            "BotMissingAnyRole",
            "NSFWChannelRequired",
            "DisabledCommand",
            "CommandInvokeError",
            "CommandOnCooldown",
            "MaxConcurrencyReached",
            "ClientException",
            "CommandRegistrationError",
            "Bot",
            "command_prefix",
            "case_insensitive",
            "help_command",
            "strip_after_prefix",
            "after_invoke()",
            "before_invoke()",
            "check()",
            "check_once()",
            "command()",
            "event()",
            "group()",
            "listen()",
            "activity",
            "add_application_command()",
            "add_check()",
            "add_cog()",
            "add_command()",
            "add_listener()",
            "add_view()",
            "allowed_mentions",
            "application_command()",
            "application_flags",
            "application_id",
            "application_info()",
            "before_identify_hook()",
            "cached_messages",
            "change_presence()",
            "clear()",
            "close()",
            "cogs",
            "commands",
            "connect()",
            "create_dm()",
            "create_group()",
            "create_guild()",
            "delete_invite()",
            "emojis",
            "entitlements()",
            "extensions",
            "fetch_application()",
            "fetch_channel()",
            "fetch_guild()",
            "fetch_guilds()",
            "fetch_invite()",
            "fetch_premium_sticker_packs()",
            "fetch_role_connection_metadata_records()",
            "fetch_skus()",
            "fetch_stage_instance()",
            "fetch_sticker()",
            "fetch_template()",
            "fetch_user()",
            "fetch_webhook()",
            "fetch_widget()",
            "get_all_channels()",
            "get_all_members()",
            "get_application_command()",
            "get_application_context()",
            "get_autocomplete_context()",
            "get_channel()",
            "get_cog()",
            "get_command()",
            "get_context()",
            "get_desynced_commands()",
            "get_emoji()",
            "get_guild()",
            "get_message()",
            "get_or_fetch_user()",
            "get_partial_messageable()",
            "get_poll()",
            "get_prefix()",
            "get_stage_instance()",
            "get_sticker()",
            "get_user()",
            "guilds",
            "intents",
            "invoke()",
            "invoke_application_command()",
            "is_closed()",
            "is_owner()",
            "is_ready()",
            "is_ws_ratelimited()",
            "latency",
            "load_extension()",
            "load_extensions()",
            "login()",
            "message_command()",
            "on_application_command_error()",
            "on_command_error()",
            "on_error()",
            "persistent_views",
            "polls",
            "private_channels",
            "process_application_commands()",
            "process_commands()",
            "register_command()",
            "register_commands()",
            "reload_extension()",
            "remove_application_command()",
            "remove_check()",
            "remove_cog()",
            "remove_command()",
            "remove_listener()",
            "run()",
            "slash_command()",
            "slash_group()",
            "start()",
            "status",
            "stickers",
            "store_url",
            "sync_commands()",
            "unload_extension()",
            "update_role_connection_metadata_records()",
            "user",
            "user_command()",
            "users",
            "voice_clients",
            "wait_for()",
            "wait_until_ready()",
            "walk_application_commands()",
            "walk_commands()",
            "AutoShardedBot",
            "when_mentioned()",
            "when_mentioned_or()",
            "on_command_error()",
            "on_command()",
            "on_command_completion()",
            "command()",
            "group()",
            "Command",
            "name",
            "callback",
            "help",
            "brief",
            "usage",
            "aliases",
            "enabled",
            "parent",
            "cog",
            "checks",
            "description",
            "hidden",
            "rest_is_raw",
            "invoked_subcommand",
            "require_var_positional",
            "ignore_extra",
            "cooldown_after_parsing",
            "extras",
            "after_invoke()",
            "before_invoke()",
            "error()",
            "add_check()",
            "remove_check()",
            "update()",
            "__call__()",
            "copy()",
            "clean_params",
            "full_parent_name",
            "parents",
            "root_parent",
            "qualified_name",
            "is_on_cooldown()",
            "reset_cooldown()",
            "get_cooldown_retry_after()",
            "has_error_handler()",
            "cog_name",
            "short_doc",
            "signature",
            "can_run()",
            "Group",
            "invoke_without_command",
            "case_insensitive",
            "after_invoke()",
            "before_invoke()",
            "command()",
            "error()",
            "group()",
            "copy()",
            "add_check()",
            "add_command()",
            "can_run()",
            "clean_params",
            "cog_name",
            "commands",
            "full_parent_name",
            "get_command()",
            "get_cooldown_retry_after()",
            "has_error_handler()",
            "is_on_cooldown()",
            "parents",
            "qualified_name",
            "remove_check()",
            "remove_command()",
            "reset_cooldown()",
            "root_parent",
            "short_doc",
            "signature",
            "update()",
            "walk_commands()",
            "GroupMixin",
            "all_commands",
            "case_insensitive",
            "command()",
            "group()",
            "commands",
            "add_command()",
            "remove_command()",
            "walk_commands()",
            "get_command()",
            "Cog",
            "walk_commands()",
            "get_commands()",
            "CogMeta",
            "name",
            "description",
            "command_attrs",
            "guild_ids",
            "HelpCommand",
            "context",
            "show_hidden",
            "verify_checks",
            "command_attrs",
            "add_check()",
            "remove_check()",
            "get_bot_mapping()",
            "invoked_with",
            "get_command_signature()",
            "remove_mentions()",
            "cog",
            "command_not_found()",
            "subcommand_not_found()",
            "filter_commands()",
            "get_max_size()",
            "get_destination()",
            "send_error_message()",
            "on_help_command_error()",
            "send_bot_help()",
            "send_cog_help()",
            "send_group_help()",
            "send_command_help()",
            "prepare_help_command()",
            "command_callback()",
            "DefaultHelpCommand",
            "width",
            "sort_commands",
            "dm_help",
            "dm_help_threshold",
            "indent",
            "commands_heading",
            "no_category",
            "paginator",
            "shorten_text()",
            "get_ending_note()",
            "add_indented_commands()",
            "send_pages()",
            "add_command_formatting()",
            "get_destination()",
            "MinimalHelpCommand",
            "sort_commands",
            "commands_heading",
            "aliases_heading",
            "dm_help",
            "dm_help_threshold",
            "no_category",
            "paginator",
            "send_pages()",
            "get_opening_note()",
            "get_command_signature()",
            "get_ending_note()",
            "add_bot_commands_formatting()",
            "add_subcommand_formatting()",
            "add_aliases_formatting()",
            "add_command_formatting()",
            "get_destination()",
            "Paginator",
            "prefix",
            "suffix",
            "max_size",
            "linesep",
            "clear()",
            "add_line()",
            "close_page()",
            "pages",
            "BucketType",
            "default",
            "user",
            "guild",
            "channel",
            "member",
            "category",
            "role",
            "check()",
            "check_any()",
            "has_role()",
            "has_permissions()",
            "has_guild_permissions()",
            "has_any_role()",
            "bot_has_role()",
            "bot_has_permissions()",
            "bot_has_guild_permissions()",
            "bot_has_any_role()",
            "cooldown()",
            "dynamic_cooldown()",
            "max_concurrency()",
            "before_invoke()",
            "after_invoke()",
            "guild_only()",
            "dm_only()",
            "is_owner()",
            "is_nsfw()",
            "Cooldown",
            "rate",
            "per",
            "get_tokens()",
            "get_retry_after()",
            "update_rate_limit()",
            "reset()",
            "copy()",
            "Context",
            "message",
            "bot",
            "args",
            "kwargs",
            "current_parameter",
            "prefix",
            "command",
            "invoked_with",
            "invoked_parents",
            "invoked_subcommand",
            "subcommand_passed",
            "command_failed",
            "history()",
            "typing()",
            "invoke()",
            "reinvoke()",
            "valid",
            "clean_prefix",
            "cog",
            "guild",
            "channel",
            "author",
            "me",
            "voice_client",
            "send_help()",
            "can_send()",
            "fetch_message()",
            "pins()",
            "reply()",
            "send()",
            "trigger_typing()",
            "Converter",
            "convert()",
            "ObjectConverter",
            "convert()",
            "MemberConverter",
            "convert()",
            "UserConverter",
            "convert()",
            "MessageConverter",
            "convert()",
            "PartialMessageConverter",
            "convert()",
            "GuildChannelConverter",
            "convert()",
            "TextChannelConverter",
            "convert()",
            "VoiceChannelConverter",
            "convert()",
            "StageChannelConverter",
            "convert()",
            "CategoryChannelConverter",
            "convert()",
            "ForumChannelConverter",
            "convert()",
            "InviteConverter",
            "convert()",
            "GuildConverter",
            "convert()",
            "RoleConverter",
            "convert()",
            "GameConverter",
            "convert()",
            "ColourConverter",
            "convert()",
            "EmojiConverter",
            "convert()",
            "PartialEmojiConverter",
            "convert()",
            "ThreadConverter",
            "convert()",
            "GuildStickerConverter",
            "convert()",
            "clean_content",
            "fix_channel_mentions",
            "use_nicknames",
            "escape_markdown",
            "remove_markdown",
            "convert()",
            "Greedy",
            "run_converters()",
            "FlagConverter",
            "get_flags()",
            "convert()",
            "Flag",
            "name",
            "aliases",
            "attribute",
            "default",
            "annotation",
            "max_args",
            "override",
            "required",
            "flag()",
            "CommandError",
            "ConversionError",
            "converter",
            "original",
            "MissingRequiredArgument",
            "param",
            "ArgumentParsingError",
            "UnexpectedQuoteError",
            "quote",
            "InvalidEndOfQuotedStringError",
            "char",
            "ExpectedClosingQuoteError",
            "close_quote",
            "BadArgument",
            "BadUnionArgument",
            "param",
            "converters",
            "errors",
            "BadLiteralArgument",
            "param",
            "literals",
            "errors",
            "PrivateMessageOnly",
            "NoPrivateMessage",
            "CheckFailure",
            "CheckAnyFailure",
            "errors",
            "checks",
            "CommandNotFound",
            "DisabledCommand",
            "CommandInvokeError",
            "original",
            "TooManyArguments",
            "UserInputError",
            "CommandOnCooldown",
            "cooldown",
            "type",
            "retry_after",
            "MaxConcurrencyReached",
            "number",
            "per",
            "NotOwner",
            "MessageNotFound",
            "argument",
            "MemberNotFound",
            "argument",
            "GuildNotFound",
            "argument",
            "UserNotFound",
            "argument",
            "ChannelNotFound",
            "argument",
            "ChannelNotReadable",
            "argument",
            "ThreadNotFound",
            "argument",
            "BadColourArgument",
            "argument",
            "RoleNotFound",
            "argument",
            "BadInviteArgument",
            "EmojiNotFound",
            "argument",
            "PartialEmojiConversionFailure",
            "argument",
            "GuildStickerNotFound",
            "argument",
            "BadBoolArgument",
            "argument",
            "MissingPermissions",
            "missing_permissions",
            "BotMissingPermissions",
            "missing_permissions",
            "MissingRole",
            "missing_role",
            "BotMissingRole",
            "missing_role",
            "MissingAnyRole",
            "missing_roles",
            "BotMissingAnyRole",
            "missing_roles",
            "NSFWChannelRequired",
            "FlagError",
            "BadFlagArgument",
            "flag",
            "MissingFlagArgument",
            "flag",
            "TooManyFlags",
            "flag",
            "values",
            "MissingRequiredFlag",
            "flag",
            "CommandRegistrationError",
            "name",
            "alias_conflict"
        ],
        "url": "https://docs.pycord.dev/en/stable/ext/commands/api.html"
    },
    {
        "title": "Bot UI Kit#",
        "content": [
            "The library has helpers to help create component-based UIs."
        ],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/api/ui_kit.html"
    },
    {
        "title": "Shortcut decorators#",
        "content": [
            "A decorator that attaches a button to a component.",
            "The function being decorated should have three parameters, self representing\nthe discord.ui.View, the discord.ui.Button being pressed and\nthe discord.Interaction you receive.",
            "Note",
            "Premium and link buttons cannot be created with this decorator. Consider\ncreating a Button object manually instead. These types of\nbuttons do not have a callback associated since Discord doesn’t handle\nthem when clicked.",
            "label (Optional[str]) – The label of the button, if any.",
            "custom_id (Optional[str]) – The ID of the button that gets received during an interaction.\nIt is recommended not to set this parameter to prevent conflicts.",
            "style (ButtonStyle) – The style of the button. Defaults to ButtonStyle.grey.",
            "disabled (bool) – Whether the button is disabled or not. Defaults to False.",
            "emoji (Optional[Union[str, Emoji, PartialEmoji]]) – The emoji of the button. This can be in string form or a PartialEmoji\nor a full Emoji.",
            "row (Optional[int]) – The relative row this button belongs to. A Discord component can only have 5\nrows. By default, items are arranged automatically into those 5 rows. If you’d\nlike to control the relative positioning of the row then passing an index is advised.\nFor example, row=1 will show up before row=2. Defaults to None, which is automatic\nordering. The row number must be between 0 and 4 (i.e. zero indexed).",
            "Callable[[ItemCallbackType], ItemCallbackType]",
            "A decorator that attaches a select menu to a component.",
            "The function being decorated should have three parameters, self representing\nthe discord.ui.View, the discord.ui.Select being pressed and\nthe discord.Interaction you receive.",
            "In order to get the selected items that the user has chosen within the callback\nuse Select.values.",
            "Changed in version 2.3: Creating select menus of different types is now supported.",
            "select_type (discord.ComponentType) – The type of select to create. Must be one of\ndiscord.ComponentType.string_select, discord.ComponentType.user_select,\ndiscord.ComponentType.role_select, discord.ComponentType.mentionable_select,\nor discord.ComponentType.channel_select.",
            "placeholder (Optional[str]) – The placeholder text that is shown if nothing is selected, if any.",
            "custom_id (str) – The ID of the select menu that gets received during an interaction.\nIt is recommended not to set this parameter to prevent conflicts.",
            "row (Optional[int]) – The relative row this select menu belongs to. A Discord component can only have 5\nrows. By default, items are arranged automatically into those 5 rows. If you’d\nlike to control the relative positioning of the row then passing an index is advised.\nFor example, row=1 will show up before row=2. Defaults to None, which is automatic\nordering. The row number must be between 0 and 4 (i.e. zero indexed).",
            "min_values (int) – The minimum number of items that must be chosen for this select menu.\nDefaults to 1 and must be between 0 and 25.",
            "max_values (int) – The maximum number of items that must be chosen for this select menu.\nDefaults to 1 and must be between 1 and 25.",
            "options (List[discord.SelectOption]) – A list of options that can be selected in this menu.\nOnly valid for the discord.ComponentType.string_select type.",
            "channel_types (List[discord.ChannelType]) – The channel types that should be selectable.\nOnly valid for the discord.ComponentType.channel_select type.\nDefaults to all channel types.",
            "disabled (bool) – Whether the select is disabled or not. Defaults to False.",
            "Callable[[ItemCallbackType], ItemCallbackType]",
            "A shortcut for discord.ui.select() with select type discord.ComponentType.string_select.",
            "New in version 2.3.",
            "placeholder (str | None) –",
            "custom_id (str | None) –",
            "min_values (int) –",
            "max_values (int) –",
            "options (list[SelectOption]) –",
            "disabled (bool) –",
            "row (int | None) –",
            "Callable[[ItemCallbackType], ItemCallbackType]",
            "A shortcut for discord.ui.select() with select type discord.ComponentType.user_select.",
            "New in version 2.3.",
            "placeholder (str | None) –",
            "custom_id (str | None) –",
            "min_values (int) –",
            "max_values (int) –",
            "disabled (bool) –",
            "row (int | None) –",
            "Callable[[ItemCallbackType], ItemCallbackType]",
            "A shortcut for discord.ui.select() with select type discord.ComponentType.role_select.",
            "New in version 2.3.",
            "placeholder (str | None) –",
            "custom_id (str | None) –",
            "min_values (int) –",
            "max_values (int) –",
            "disabled (bool) –",
            "row (int | None) –",
            "Callable[[ItemCallbackType], ItemCallbackType]",
            "A shortcut for discord.ui.select() with select type discord.ComponentType.mentionable_select.",
            "New in version 2.3.",
            "placeholder (str | None) –",
            "custom_id (str | None) –",
            "min_values (int) –",
            "max_values (int) –",
            "disabled (bool) –",
            "row (int | None) –",
            "Callable[[ItemCallbackType], ItemCallbackType]",
            "A shortcut for discord.ui.select() with select type discord.ComponentType.channel_select.",
            "New in version 2.3.",
            "placeholder (str | None) –",
            "custom_id (str | None) –",
            "min_values (int) –",
            "max_values (int) –",
            "disabled (bool) –",
            "channel_types (list[ChannelType]) –",
            "row (int | None) –",
            "Callable[[ItemCallbackType], ItemCallbackType]"
        ],
        "code": [
            "self",
            "discord.ui.View",
            "discord.ui.Button",
            "discord.Interaction",
            "Button",
            "str",
            "str",
            "ButtonStyle",
            "ButtonStyle.grey",
            "bool",
            "False",
            "str",
            "Emoji",
            "PartialEmoji",
            "PartialEmoji",
            "Emoji",
            "int",
            "None",
            "self",
            "discord.ui.View",
            "discord.ui.Select",
            "discord.Interaction",
            "Select.values",
            "discord.ComponentType",
            "discord.ComponentType.string_select",
            "discord.ComponentType.user_select",
            "discord.ComponentType.role_select",
            "discord.ComponentType.mentionable_select",
            "discord.ComponentType.channel_select",
            "str",
            "str",
            "int",
            "None",
            "int",
            "int",
            "discord.SelectOption",
            "discord.ComponentType.string_select",
            "discord.ChannelType",
            "discord.ComponentType.channel_select",
            "bool",
            "False",
            "discord.ui.select()",
            "discord.ComponentType.string_select",
            "discord.ui.select()",
            "discord.ComponentType.user_select",
            "discord.ui.select()",
            "discord.ComponentType.role_select",
            "discord.ui.select()",
            "discord.ComponentType.mentionable_select",
            "discord.ui.select()",
            "discord.ComponentType.channel_select"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/ui_kit.html"
    },
    {
        "title": "Objects#",
        "content": [
            "Represents a UI view.",
            "This object must be inherited to create a UI within Discord.",
            "New in version 2.0.",
            "*items (Item) – The initial items attached to this view.",
            "timeout (Optional[float]) – Timeout in seconds from last interaction with the UI before no longer accepting input.\nIf None then there is no timeout.",
            "Timeout from last interaction with the UI before no longer accepting input.\nIf None then there is no timeout.",
            "Optional[float]",
            "The list of children attached to this view.",
            "List[Item]",
            "Whether to disable the view when the timeout is reached. Defaults to False.",
            "bool",
            "The message that this view is attached to.\nIf None then the view has not been sent with a message.",
            "Optional[Message]",
            "The parent interaction which this view was sent from.\nIf None then the view was not sent using InteractionResponse.send_message().",
            "Optional[Interaction]",
            "disable_on_timeout (bool) –",
            "Converts a message’s components into a View.",
            "The Message.components of a message are read-only\nand separate types from those in the discord.ui namespace.\nIn order to modify and edit message components they must be\nconverted into a View first.",
            "message (Message) – The message with components to convert into a view.",
            "timeout (Optional[float]) – The timeout of the converted view.",
            "The converted view. This always returns a View and not\none of its subclasses.",
            "View",
            "Adds an item to the view.",
            "item (Item) – The item to add to the view.",
            "TypeError – An Item was not passed.",
            "ValueError – Maximum number of children has been exceeded (25)\n    or the row the item is trying to be added to is full.",
            "None",
            "Removes an item from the view.",
            "item (Item) – The item to remove from the view.",
            "None",
            "Removes all items from the view.",
            "None",
            "Get an item from the view with the given custom ID. Alias for utils.get(view.children, custom_id=custom_id).",
            "custom_id (str) – The custom_id of the item to get",
            "The item with the matching custom_id if it exists.",
            "Optional[Item]",
            "This function is a coroutine.",
            "A callback that is called when an interaction happens within the view\nthat checks whether the view should process item callbacks for the interaction.",
            "This is useful to override if, for example, you want to ensure that the\ninteraction author is a given user.",
            "The default implementation of this returns True.",
            "If this returns False, on_check_failure() is called.",
            "Note",
            "If an exception occurs within the body then the check\nis considered a failure and on_error() is called.",
            "interaction (Interaction) – The interaction that occurred.",
            "Whether the view children’s callbacks should be called.",
            "bool",
            "This function is a coroutine.",
            "A callback that is called when a view’s timeout elapses without being explicitly stopped.",
            "None",
            "This function is a coroutine.\nA callback that is called when a View.interaction_check() returns False.\nThis can be used to send a response when a check failure occurs.",
            "interaction (Interaction) – The interaction that occurred.",
            "None",
            "This function is a coroutine.",
            "A callback that is called when an item’s callback or interaction_check()\nfails with an error.",
            "The default implementation prints the traceback to stderr.",
            "error (Exception) – The exception that was raised.",
            "item (Item) – The item that failed the dispatch.",
            "interaction (Interaction) – The interaction that led to the failure.",
            "None",
            "Stops listening to interaction events from this view.",
            "This operation cannot be undone.",
            "None",
            "Whether the view has finished interacting.",
            "bool",
            "Whether the view has been added for dispatching purposes.",
            "bool",
            "Whether the view is set up as persistent.",
            "A persistent view has all their components with a set custom_id and\na timeout set to None.",
            "bool",
            "Waits until the view has finished interacting.",
            "A view is considered finished when stop()\nis called, or it times out.",
            "If True, then the view timed out. If False then\nthe view finished normally.",
            "bool",
            "Disables all items in the view.",
            "exclusions (Optional[List[Item]]) – A list of items in self.children to not disable from the view.",
            "Enables all items in the view.",
            "exclusions (Optional[List[Item]]) – A list of items in self.children to not enable from the view.",
            "Represents the base UI item that all UI components inherit from.",
            "The current UI items supported are:",
            "discord.ui.Button",
            "discord.ui.Select",
            "New in version 2.0.",
            "The underlying view for this item.",
            "This function is a coroutine.",
            "The callback associated with this UI item.",
            "This can be overridden by subclasses.",
            "interaction (Interaction) – The interaction that triggered this UI item.",
            "Represents a UI button.",
            "New in version 2.0.",
            "style (discord.ButtonStyle) – The style of the button.",
            "custom_id (Optional[str]) – The ID of the button that gets received during an interaction.\nIf this button is for a URL, it does not have a custom ID.",
            "url (Optional[str]) – The URL this button sends you to.",
            "disabled (bool) – Whether the button is disabled or not.",
            "label (Optional[str]) – The label of the button, if any. Maximum of 80 chars.",
            "emoji (Optional[Union[PartialEmoji, Emoji, str]]) – The emoji of the button, if available.",
            "sku_id (Optional[Union[int]]) – The ID of the SKU this button refers to.",
            "row (Optional[int]) – The relative row this button belongs to. A Discord component can only have 5\nrows. By default, items are arranged automatically into those 5 rows. If you’d\nlike to control the relative positioning of the row then passing an index is advised.\nFor example, row=1 will show up before row=2. Defaults to None, which is automatic\nordering. The row number must be between 0 and 4 (i.e. zero indexed).",
            "The style of the button.",
            "The ID of the button that gets received during an interaction.",
            "If this button is for a URL, it does not have a custom ID.",
            "The URL this button sends you to.",
            "Whether the button is disabled or not.",
            "The label of the button, if available.",
            "The emoji of the button, if available.",
            "The ID of the SKU this button refers to.",
            "This function is a coroutine.",
            "The callback associated with this UI item.",
            "This can be overridden by subclasses.",
            "interaction (Interaction) – The interaction that triggered this UI item.",
            "The underlying view for this item.",
            "Represents a UI select menu.",
            "This is usually represented as a drop down menu.",
            "In order to get the selected items that the user has chosen, use Select.values.",
            "New in version 2.0.",
            "Changed in version 2.3: Added support for discord.ComponentType.string_select, discord.ComponentType.user_select,\ndiscord.ComponentType.role_select, discord.ComponentType.mentionable_select,\nand discord.ComponentType.channel_select.",
            "select_type (discord.ComponentType) – The type of select to create. Must be one of\ndiscord.ComponentType.string_select, discord.ComponentType.user_select,\ndiscord.ComponentType.role_select, discord.ComponentType.mentionable_select,\nor discord.ComponentType.channel_select.",
            "custom_id (str) – The ID of the select menu that gets received during an interaction.\nIf not given then one is generated for you.",
            "placeholder (Optional[str]) – The placeholder text that is shown if nothing is selected, if any.",
            "min_values (int) – The minimum number of items that must be chosen for this select menu.\nDefaults to 1 and must be between 1 and 25.",
            "max_values (int) – The maximum number of items that must be chosen for this select menu.\nDefaults to 1 and must be between 1 and 25.",
            "options (List[discord.SelectOption]) – A list of options that can be selected in this menu.\nOnly valid for selects of type discord.ComponentType.string_select.",
            "channel_types (List[discord.ChannelType]) – A list of channel types that can be selected in this menu.\nOnly valid for selects of type discord.ComponentType.channel_select.",
            "disabled (bool) – Whether the select is disabled or not.",
            "row (Optional[int]) – The relative row this select menu belongs to. A Discord component can only have 5\nrows. By default, items are arranged automatically into those 5 rows. If you’d\nlike to control the relative positioning of the row then passing an index is advised.\nFor example, row=1 will show up before row=2. Defaults to None, which is automatic\nordering. The row number must be between 0 and 4 (i.e. zero indexed).",
            "The ID of the select menu that gets received during an interaction.",
            "The placeholder text that is shown if nothing is selected, if any.",
            "The minimum number of items that must be chosen for this select menu.",
            "The maximum number of items that must be chosen for this select menu.",
            "Whether the select is disabled or not.",
            "A list of channel types that can be selected in this menu.",
            "A list of options that can be selected in this menu.",
            "Adds an option to the select menu.",
            "To append a pre-existing discord.SelectOption use the\nappend_option() method instead.",
            "label (str) – The label of the option. This is displayed to users.\nCan only be up to 100 characters.",
            "value (str) – The value of the option. This is not displayed to users.\nIf not given, defaults to the label. Can only be up to 100 characters.",
            "description (Optional[str]) – An additional description of the option, if any.\nCan only be up to 100 characters.",
            "emoji (Optional[Union[str, Emoji, PartialEmoji]]) – The emoji of the option, if available. This can either be a string representing\nthe custom or unicode emoji or an instance of PartialEmoji or Emoji.",
            "default (bool) – Whether this option is selected by default.",
            "ValueError – The number of options exceeds 25.",
            "Appends an option to the select menu.",
            "option (discord.SelectOption) – The option to append to the select menu.",
            "ValueError – The number of options exceeds 25.",
            "List[str] | List[discord.Member | discord.User]] | List[discord.Role]] |\nList[discord.Member | discord.User | discord.Role]] | List[discord.abc.GuildChannel] | None:\nA list of values that have been selected by the user. This will be None if the select has not been interacted with yet.",
            "This function is a coroutine.",
            "The callback associated with this UI item.",
            "This can be overridden by subclasses.",
            "interaction (Interaction) – The interaction that triggered this UI item.",
            "The underlying view for this item.",
            "Represents a UI Modal dialog.",
            "This object must be inherited to create a UI within Discord.",
            "New in version 2.0.",
            "children (InputText) – The initial InputText fields that are displayed in the modal dialog.",
            "title (str) – The title of the modal dialog.\nMust be 45 characters or fewer.",
            "custom_id (Optional[str]) – The ID of the modal dialog that gets received during an interaction.\nMust be 100 characters or fewer.",
            "timeout (Optional[float]) – Timeout in seconds from last interaction with the UI before no longer accepting input.\nIf None then there is no timeout.",
            "The title of the modal dialog.",
            "The child components associated with the modal dialog.",
            "The ID of the modal dialog that gets received during an interaction.",
            "This function is a coroutine.",
            "The coroutine that is called when the modal dialog is submitted.\nShould be overridden to handle the values submitted by the user.",
            "interaction (Interaction) – The interaction that submitted the modal dialog.",
            "Adds an InputText component to the modal dialog.",
            "item (InputText) – The item to add to the modal dialog",
            "Removes an InputText component from the modal dialog.",
            "item (InputText) – The item to remove from the modal dialog.",
            "Stops listening to interaction events from the modal dialog.",
            "None",
            "Waits for the modal dialog to be submitted.",
            "bool",
            "This function is a coroutine.",
            "A callback that is called when the modal’s callback fails with an error.",
            "The default implementation prints the traceback to stderr.",
            "error (Exception) – The exception that was raised.",
            "interaction (Interaction) – The interaction that led to the failure.",
            "None",
            "This function is a coroutine.",
            "A callback that is called when a modal’s timeout elapses without being explicitly stopped.",
            "None",
            "Represents a UI text input field.",
            "New in version 2.0.",
            "style (InputTextStyle) – The style of the input text field.",
            "custom_id (Optional[str]) – The ID of the input text field that gets received during an interaction.",
            "label (str) – The label for the input text field.\nMust be 45 characters or fewer.",
            "placeholder (Optional[str]) – The placeholder text that is shown if nothing is selected, if any.\nMust be 100 characters or fewer.",
            "min_length (Optional[int]) – The minimum number of characters that must be entered.\nDefaults to 0 and must be less than 4000.",
            "max_length (Optional[int]) – The maximum number of characters that can be entered.\nMust be between 1 and 4000.",
            "required (Optional[bool]) – Whether the input text field is required or not. Defaults to True.",
            "value (Optional[str]) – Pre-fills the input text field with this value.\nMust be 4000 characters or fewer.",
            "row (Optional[int]) – The relative row this input text field belongs to. A modal dialog can only have 5\nrows. By default, items are arranged automatically into those 5 rows. If you’d\nlike to control the relative positioning of the row then passing an index is advised.\nFor example, row=1 will show up before row=2. Defaults to None, which is automatic\nordering. The row number must be between 0 and 4 (i.e. zero indexed).",
            "The style of the input text field.",
            "The ID of the input text field that gets received during an interaction.",
            "The label of the input text field.",
            "The placeholder text that is shown before anything is entered, if any.",
            "The minimum number of characters that must be entered. Defaults to 0.",
            "The maximum number of characters that can be entered.",
            "Whether the input text field is required or not. Defaults to True.",
            "The value entered in the text field."
        ],
        "code": [
            "Item",
            "float",
            "None",
            "None",
            "float",
            "Item",
            "False",
            "bool",
            "None",
            "Message",
            "None",
            "InteractionResponse.send_message()",
            "Interaction",
            "View",
            "Message.components",
            "discord.ui",
            "View",
            "Message",
            "float",
            "View",
            "View",
            "Item",
            "Item",
            "None",
            "Item",
            "None",
            "None",
            "str",
            "custom_id",
            "Item",
            "True",
            "False",
            "on_check_failure()",
            "on_error()",
            "Interaction",
            "bool",
            "None",
            "View.interaction_check()",
            "False",
            "Interaction",
            "None",
            "interaction_check()",
            "Exception",
            "Item",
            "Interaction",
            "None",
            "None",
            "bool",
            "bool",
            "custom_id",
            "timeout",
            "None",
            "bool",
            "stop()",
            "True",
            "False",
            "bool",
            "Item",
            "Item",
            "discord.ui.Button",
            "discord.ui.Select",
            "Interaction",
            "discord.ButtonStyle",
            "str",
            "str",
            "bool",
            "str",
            "PartialEmoji",
            "Emoji",
            "str",
            "int",
            "int",
            "None",
            "Interaction",
            "Select.values",
            "discord.ComponentType.string_select",
            "discord.ComponentType.user_select",
            "discord.ComponentType.role_select",
            "discord.ComponentType.mentionable_select",
            "discord.ComponentType.channel_select",
            "discord.ComponentType",
            "discord.ComponentType.string_select",
            "discord.ComponentType.user_select",
            "discord.ComponentType.role_select",
            "discord.ComponentType.mentionable_select",
            "discord.ComponentType.channel_select",
            "str",
            "str",
            "int",
            "int",
            "discord.SelectOption",
            "discord.ComponentType.string_select",
            "discord.ChannelType",
            "discord.ComponentType.channel_select",
            "bool",
            "int",
            "None",
            "discord.SelectOption",
            "append_option()",
            "str",
            "str",
            "str",
            "str",
            "Emoji",
            "PartialEmoji",
            "PartialEmoji",
            "Emoji",
            "bool",
            "discord.SelectOption",
            "str",
            "discord.Member",
            "discord.User",
            "discord.Role",
            "discord.Member",
            "discord.User",
            "discord.Role",
            "discord.abc.GuildChannel",
            "None",
            "Interaction",
            "InputText",
            "str",
            "str",
            "float",
            "None",
            "Interaction",
            "InputText",
            "InputText",
            "None",
            "bool",
            "Exception",
            "Interaction",
            "None",
            "None",
            "InputTextStyle",
            "str",
            "str",
            "str",
            "int",
            "int",
            "bool",
            "True",
            "str",
            "int",
            "None",
            "True",
            "button()",
            "select()",
            "string_select()",
            "user_select()",
            "role_select()",
            "mentionable_select()",
            "channel_select()",
            "View",
            "timeout",
            "children",
            "disable_on_timeout",
            "message",
            "parent",
            "from_message()",
            "add_item()",
            "remove_item()",
            "clear_items()",
            "get_item()",
            "interaction_check()",
            "on_timeout()",
            "on_check_failure()",
            "on_error()",
            "stop()",
            "is_finished()",
            "is_dispatching()",
            "is_persistent()",
            "wait()",
            "disable_all_items()",
            "enable_all_items()",
            "Item",
            "view",
            "callback()",
            "Button",
            "style",
            "custom_id",
            "url",
            "disabled",
            "label",
            "emoji",
            "sku_id",
            "callback()",
            "view",
            "Select",
            "custom_id",
            "placeholder",
            "min_values",
            "max_values",
            "disabled",
            "channel_types",
            "options",
            "add_option()",
            "append_option()",
            "values",
            "callback()",
            "view",
            "Modal",
            "title",
            "children",
            "custom_id",
            "callback()",
            "add_item()",
            "remove_item()",
            "stop()",
            "wait()",
            "on_error()",
            "on_timeout()",
            "InputText",
            "style",
            "custom_id",
            "label",
            "placeholder",
            "min_length",
            "max_length",
            "required",
            "value"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/ui_kit.html"
    },
    {
        "title": "Event Reference#",
        "content": [
            "This section outlines the different types of events listened by Client.",
            "There are 3 ways to register an event, the first way is through the use of\nClient.event(). The second way is through subclassing Client and\noverriding the specific events. The third way is through the use of Client.listen(),\nwhich can be used to assign multiple event handlers instead of only one like in Client.event().\nFor example:",
            "If an event handler raises an exception, on_error() will be called\nto handle it, which defaults to print a traceback and ignoring the exception.",
            "Warning",
            "All the events must be a coroutine. If they aren’t, then you might get unexpected\nerrors. In order to turn a function into a coroutine they must be async def\nfunctions."
        ],
        "code": [
            "Client",
            "Client.event()",
            "Client",
            "Client.listen()",
            "Client.event()",
            "import discord\n\nclass MyClient(discord.Client):\n    async def on_message(self, message):\n        if message.author == self.user:\n            return\n\n        if message.content.startswith('$hello'):\n            await message.channel.send('Hello World!')\n\n\nintents = discord.Intents.default()\nintents.message_content = True # Needed to see message content\nclient = MyClient(intents=intents)\n\n# Overrides the 'on_message' method defined in MyClient\n@client.event\nasync def on_message(message: discord.Message):\n    print(f\"Received {message.content}\")\n\n# Assigns an ADDITIONAL handler\n@client.listen()\nasync def on_message(message: discord.Message):\n    print(f\"Received {message.content}\")\n\n# Runs only for the 1st event dispatch. Can be useful for listening to 'on_ready'\n@client.listen(once=True)\nasync def on_ready():\n    print(\"Client is ready!\")",
            "on_error()",
            "async def"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Application Commands#",
        "content": [
            "Called when an application command is received.",
            "New in version 2.0.",
            "context (ApplicationContext) – The ApplicationContext associated to the command being received.",
            "Called when an application command is completed, after any checks have finished.",
            "New in version 2.0.",
            "context (ApplicationContext) – The ApplicationContext associated to the command that was completed.",
            "Called when an application command has an error.",
            "New in version 2.0.",
            "context (ApplicationContext) – The ApplicationContext associated to the command that has an error.",
            "exception (DiscordException) – The DiscordException associated to the error.",
            "Called when an application command was not found in the bot’s internal cache.",
            "New in version 2.0.",
            "interaction (Interaction) – The interaction associated to the unknown command."
        ],
        "code": [
            "ApplicationContext",
            "ApplicationContext",
            "ApplicationContext",
            "DiscordException",
            "Interaction"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Audit Logs#",
        "content": [
            "Called when an audit log entry is created.",
            "The bot must have view_audit_log to receive this, and\nIntents.moderation must be enabled.",
            "New in version 2.5.",
            "entry (AuditLogEntry) – The audit log entry that was created.",
            "Called when an audit log entry is created. Unlike\non_audit_log_entry(), this is called regardless of the state of the internal\nuser cache.",
            "The bot must have view_audit_log to receive this, and\nIntents.moderation must be enabled.",
            "New in version 2.5.",
            "payload (RawAuditLogEntryEvent) – The raw event payload data."
        ],
        "code": [
            "view_audit_log",
            "Intents.moderation",
            "AuditLogEntry",
            "on_audit_log_entry()",
            "view_audit_log",
            "Intents.moderation",
            "RawAuditLogEntryEvent"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "AutoMod#",
        "content": [
            "Called when an auto moderation rule is created.",
            "The bot must have manage_guild to receive this, and\nIntents.auto_moderation_configuration must be enabled.",
            "rule (AutoModRule) – The newly created rule.",
            "Called when an auto moderation rule is updated.",
            "The bot must have manage_guild to receive this, and\nIntents.auto_moderation_configuration must be enabled.",
            "rule (AutoModRule) – The updated rule.",
            "Called when an auto moderation rule is deleted.",
            "The bot must have manage_guild to receive this, and\nIntents.auto_moderation_configuration must be enabled.",
            "rule (AutoModRule) – The deleted rule.",
            "Called when an auto moderation action is executed.",
            "The bot must have manage_guild to receive this, and\nIntents.auto_moderation_execution must be enabled.",
            "payload (AutoModActionExecutionEvent) – The event’s data."
        ],
        "code": [
            "manage_guild",
            "Intents.auto_moderation_configuration",
            "AutoModRule",
            "manage_guild",
            "Intents.auto_moderation_configuration",
            "AutoModRule",
            "manage_guild",
            "Intents.auto_moderation_configuration",
            "AutoModRule",
            "manage_guild",
            "Intents.auto_moderation_execution",
            "AutoModActionExecutionEvent"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Bans#",
        "content": [
            "Called when user gets banned from a Guild.",
            "This requires Intents.moderation to be enabled.",
            "guild (Guild) – The guild the user got banned from.",
            "user (Union[User, Member]) – The user that got banned.\nCan be either User or Member depending if\nthe user was in the guild or not at the time of removal.",
            "Called when a User gets unbanned from a Guild.",
            "This requires Intents.moderation to be enabled.",
            "guild (Guild) – The guild the user got unbanned from.",
            "user (User) – The user that got unbanned."
        ],
        "code": [
            "Guild",
            "Intents.moderation",
            "Guild",
            "User",
            "Member",
            "User",
            "Member",
            "User",
            "Guild",
            "Intents.moderation",
            "Guild",
            "User"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Channels#",
        "content": [
            "Called whenever a private group DM is updated. e.g. changed name or topic.",
            "This requires Intents.messages to be enabled.",
            "before (GroupChannel) – The updated group channel’s old info.",
            "after (GroupChannel) – The updated group channel’s new info.",
            "Called whenever a message is pinned or unpinned from a private channel.",
            "channel (abc.PrivateChannel) – The private channel that had its pins updated.",
            "last_pin (Optional[datetime.datetime]) – The latest message that was pinned as an aware datetime in UTC. Could be None.",
            "Called whenever a guild channel is updated. e.g. changed name, topic, permissions.",
            "This requires Intents.guilds to be enabled.",
            "before (abc.GuildChannel) – The updated guild channel’s old info.",
            "after (abc.GuildChannel) – The updated guild channel’s new info.",
            "Called whenever a message is pinned or unpinned from a guild channel.",
            "This requires Intents.guilds to be enabled.",
            "channel (Union[abc.GuildChannel, Thread]) – The guild channel that had its pins updated.",
            "last_pin (Optional[datetime.datetime]) – The latest message that was pinned as an aware datetime in UTC. Could be None.",
            "Called whenever a guild channel is deleted or created.",
            "Note that you can get the guild from guild.",
            "This requires Intents.guilds to be enabled.",
            "channel (abc.GuildChannel) – The guild channel that got created or deleted."
        ],
        "code": [
            "Intents.messages",
            "GroupChannel",
            "GroupChannel",
            "abc.PrivateChannel",
            "datetime.datetime",
            "None",
            "Intents.guilds",
            "abc.GuildChannel",
            "abc.GuildChannel",
            "Intents.guilds",
            "abc.GuildChannel",
            "Thread",
            "datetime.datetime",
            "None",
            "guild",
            "Intents.guilds",
            "abc.GuildChannel"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Connection#",
        "content": [
            "Usually when an event raises an uncaught exception, a traceback is\nprinted to stderr and the exception is ignored. If you want to\nchange this behaviour and handle the exception for whatever reason\nyourself, this event can be overridden. Which, when done, will\nsuppress the default action of printing the traceback.",
            "The information of the exception raised and the exception itself can\nbe retrieved with a standard call to sys.exc_info().",
            "If you want exception to propagate out of the Client class\nyou can define an on_error handler consisting of a single empty\nraise statement. Exceptions raised by on_error will not be\nhandled in any way by Client.",
            "Note",
            "on_error will only be dispatched to Client.event().",
            "It will not be received by Client.wait_for(), or, if used,\nBots listeners such as\nlisten() or listener().",
            "event (str) – The name of the event that raised the exception.",
            "args – The positional arguments for the event that raised the\nexception.",
            "kwargs – The keyword arguments for the event that raised the\nexception.",
            "Called when the client has successfully connected to Discord. This is not\nthe same as the client being fully prepared, see on_ready() for that.",
            "The warnings on on_ready() also apply.",
            "Warning",
            "Overriding this event will not call Bot.sync_commands().\nAs a result, ApplicationCommand will not be registered.",
            "Similar to on_connect() except used by AutoShardedClient\nto denote when a particular shard ID has connected to Discord.",
            "New in version 1.4.",
            "shard_id (int) – The shard ID that has connected.",
            "Called when the client has disconnected from Discord, or a connection attempt to Discord has failed.\nThis could happen either through the internet being disconnected, explicit calls to close,\nor Discord terminating the connection one way or the other.",
            "This function can be called many times without a corresponding on_connect() call.",
            "Similar to on_disconnect() except used by AutoShardedClient\nto denote when a particular shard ID has disconnected from Discord.",
            "New in version 1.4.",
            "shard_id (int) – The shard ID that has disconnected.",
            "Called when the client is done preparing the data received from Discord. Usually after login is successful\nand the Client.guilds and co. are filled up.",
            "Warning",
            "This function is not guaranteed to be the first event called.\nLikewise, this function is not guaranteed to only be called\nonce. This library implements reconnection logic and thus will\nend up calling this event whenever a RESUME request fails.",
            "Similar to on_ready() except used by AutoShardedClient\nto denote when a particular shard ID has become ready.",
            "shard_id (int) – The shard ID that is ready.",
            "Called when the client has resumed a session.",
            "Similar to on_resumed() except used by AutoShardedClient\nto denote when a particular shard ID has resumed a session.",
            "New in version 1.4.",
            "shard_id (int) – The shard ID that has resumed.",
            "Called whenever a WebSocket event is received from the WebSocket.",
            "This is mainly useful for logging how many events you are receiving\nfrom the Discord gateway.",
            "New in version 2.0.",
            "event_type (str) – The event type from Discord that is received, e.g. 'READY'.",
            "Called whenever a message is completely received from the WebSocket, before\nit’s processed and parsed. This event is always dispatched when a\ncomplete message is received and the passed data is not parsed in any way.",
            "This is only really useful for grabbing the WebSocket stream and\ndebugging purposes.",
            "This requires setting the enable_debug_events setting in the Client.",
            "Note",
            "This is only for the messages received from the client\nWebSocket. The voice WebSocket will not trigger this event.",
            "msg (str) – The message passed in from the WebSocket library.",
            "Called whenever a send operation is done on the WebSocket before the\nmessage is sent. The passed parameter is the message that is being\nsent to the WebSocket.",
            "This is only really useful for grabbing the WebSocket stream and\ndebugging purposes.",
            "This requires setting the enable_debug_events setting in the Client.",
            "Note",
            "This is only for the messages sent from the client\nWebSocket. The voice WebSocket will not trigger this event.",
            "payload – The message that is about to be passed on to the\nWebSocket library. It can be bytes to denote a binary\nmessage or str to denote a regular text message."
        ],
        "code": [
            "sys.exc_info()",
            "Client",
            "on_error",
            "on_error",
            "Client",
            "on_error",
            "Client.event()",
            "Client.wait_for()",
            "listen()",
            "listener()",
            "str",
            "on_ready()",
            "on_ready()",
            "Bot.sync_commands()",
            "ApplicationCommand",
            "on_connect()",
            "AutoShardedClient",
            "int",
            "on_connect()",
            "on_disconnect()",
            "AutoShardedClient",
            "int",
            "Client.guilds",
            "on_ready()",
            "AutoShardedClient",
            "int",
            "on_resumed()",
            "AutoShardedClient",
            "int",
            "str",
            "'READY'",
            "enable_debug_events",
            "Client",
            "str",
            "enable_debug_events",
            "Client",
            "bytes",
            "str"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Entitlements#",
        "content": [
            "Called when a user subscribes to an SKU.",
            "New in version 2.5.",
            "entitlement (Entitlement) – The entitlement that was created as a result of the subscription.",
            "Called when a user’s subscription to an Entitlement is renewed for the next billing period.",
            "New in version 2.5.",
            "entitlement (Entitlement) – The entitlement that was updated.",
            "Called when a user’s entitlement is deleted.",
            "Entitlements are usually only deleted when Discord issues a refund for a subscription,\nor manually removes an entitlement from a user.",
            "Note",
            "This is not called when a user’s subscription is cancelled.",
            "New in version 2.5.",
            "entitlement (Entitlement) – The entitlement that was deleted."
        ],
        "code": [
            "Entitlement",
            "Entitlement",
            "Entitlement"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Guilds#",
        "content": [
            "Called when a Guild is either created by the Client or when the\nClient joins a guild.",
            "This requires Intents.guilds to be enabled.",
            "guild (Guild) – The guild that was joined.",
            "Called when a Guild is removed from the Client.",
            "This happens through, but not limited to, these circumstances:",
            "The client got banned.",
            "The client got kicked.",
            "The client left the guild.",
            "The client or the guild owner deleted the guild.",
            "In order for this event to be invoked then the Client must have\nbeen part of the guild to begin with. (i.e. it is part of Client.guilds)",
            "This requires Intents.guilds to be enabled.",
            "guild (Guild) – The guild that got removed.",
            "Called when a Guild is updated, for example:",
            "Changed name",
            "Changed AFK channel",
            "Changed AFK timeout",
            "etc.",
            "This requires Intents.guilds to be enabled.",
            "before (Guild) – The guild prior to being updated.",
            "after (Guild) – The guild after being updated.",
            "Called when a Guild creates or deletes a Role.",
            "To get the guild it belongs to, use Role.guild.",
            "This requires Intents.guilds to be enabled.",
            "role (Role) – The role that was created or deleted.",
            "Called when a Role is changed guild-wide.",
            "This requires Intents.guilds to be enabled.",
            "before (Role) – The updated role’s old info.",
            "after (Role) – The updated role’s updated info.",
            "Called when a Guild adds or removes an Emoji.",
            "This requires Intents.emojis_and_stickers to be enabled.",
            "guild (Guild) – The guild who got their emojis updated.",
            "before (Sequence[Emoji]) – A list of emojis before the update.",
            "after (Sequence[Emoji]) – A list of emojis after the update.",
            "Called when a Guild adds or removes a sticker.",
            "This requires Intents.emojis_and_stickers to be enabled.",
            "New in version 2.0.",
            "guild (Guild) – The guild who got their stickers updated.",
            "before (Sequence[GuildSticker]) – A list of stickers before the update.",
            "after (Sequence[GuildSticker]) – A list of stickers after the update.",
            "Called when a guild becomes available or unavailable. The guild must have\nexisted in the Client.guilds cache.",
            "This requires Intents.guilds to be enabled.",
            "guild (Guild) – The guild that has changed availability.",
            "Called whenever a webhook is created, modified, or removed from a guild channel.",
            "This requires Intents.webhooks to be enabled.",
            "channel (abc.GuildChannel) – The channel that had its webhooks updated."
        ],
        "code": [
            "Guild",
            "Client",
            "Client",
            "Intents.guilds",
            "Guild",
            "Guild",
            "Client",
            "Client",
            "Client.guilds",
            "Intents.guilds",
            "Guild",
            "Guild",
            "Intents.guilds",
            "Guild",
            "Guild",
            "Guild",
            "Role",
            "Role.guild",
            "Intents.guilds",
            "Role",
            "Role",
            "Intents.guilds",
            "Role",
            "Role",
            "Guild",
            "Emoji",
            "Intents.emojis_and_stickers",
            "Guild",
            "Emoji",
            "Emoji",
            "Guild",
            "Intents.emojis_and_stickers",
            "Guild",
            "GuildSticker",
            "GuildSticker",
            "Client.guilds",
            "Intents.guilds",
            "Guild",
            "Intents.webhooks",
            "abc.GuildChannel"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Integrations#",
        "content": [
            "Called whenever an integration is created, modified, or removed from a guild.",
            "This requires Intents.integrations to be enabled.",
            "New in version 1.4.",
            "guild (Guild) – The guild that had its integrations updated.",
            "Called when an integration is created.",
            "This requires Intents.integrations to be enabled.",
            "New in version 2.0.",
            "integration (Integration) – The integration that was created.",
            "Called when an integration is updated.",
            "This requires Intents.integrations to be enabled.",
            "New in version 2.0.",
            "integration (Integration) – The integration that was created.",
            "Called when an integration is deleted.",
            "This requires Intents.integrations to be enabled.",
            "New in version 2.0.",
            "payload (RawIntegrationDeleteEvent) – The raw event payload data."
        ],
        "code": [
            "Intents.integrations",
            "Guild",
            "Intents.integrations",
            "Integration",
            "Intents.integrations",
            "Integration",
            "Intents.integrations",
            "RawIntegrationDeleteEvent"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Interactions#",
        "content": [
            "Called when an interaction happened.",
            "This currently happens due to application command invocations or components being used.",
            "Warning",
            "This is a low level function that is not generally meant to be used.\nIf you are working with components, consider using the callbacks associated\nwith the View instead as it provides a nicer user experience.",
            "New in version 2.0.",
            "interaction (Interaction) – The interaction data."
        ],
        "code": [
            "View",
            "Interaction"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Invites#",
        "content": [
            "Called when an Invite is created.\nYou must have the manage_channels permission to receive this.",
            "New in version 1.3.",
            "Note",
            "There is a rare possibility that the Invite.guild and Invite.channel\nattributes will be of Object rather than the respective models.",
            "This requires Intents.invites to be enabled.",
            "invite (Invite) – The invite that was created.",
            "Called when an Invite is deleted.\nYou must have the manage_channels permission to receive this.",
            "New in version 1.3.",
            "Note",
            "There is a rare possibility that the Invite.guild and Invite.channel\nattributes will be of Object rather than the respective models.",
            "Outside of those two attributes, the only other attribute guaranteed to be\nfilled by the Discord gateway for this event is Invite.code.",
            "This requires Intents.invites to be enabled.",
            "invite (Invite) – The invite that was deleted."
        ],
        "code": [
            "Invite",
            "manage_channels",
            "Invite.guild",
            "Invite.channel",
            "Object",
            "Intents.invites",
            "Invite",
            "Invite",
            "manage_channels",
            "Invite.guild",
            "Invite.channel",
            "Object",
            "Invite.code",
            "Intents.invites",
            "Invite"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Members/Users#",
        "content": [
            "Called when a Member joins a Guild.",
            "This requires Intents.members to be enabled.",
            "member (Member) – The member who joined.",
            "Called when a Member leaves a Guild.",
            "If the guild or member could not be found in the internal cache, this event will not\nbe called. Alternatively, on_raw_member_remove() is called regardless of the\ninternal cache.",
            "This requires Intents.members to be enabled.",
            "member (Member) – The member who left.",
            "Called when a Member leaves a Guild. Unlike\non_member_remove(), this is called regardless of the state of the internal\nmember cache.",
            "This requires Intents.members to be enabled.",
            "New in version 2.4.",
            "payload (RawMemberRemoveEvent) – The raw event payload data.",
            "Called when a Member updates their profile.",
            "This is called when one or more of the following things change:",
            "nickname",
            "roles",
            "pending",
            "communication_disabled_until",
            "timed_out",
            "This requires Intents.members to be enabled.",
            "before (Member) – The updated member’s old info.",
            "after (Member) – The updated member’s updated info.",
            "Called when a Member updates their presence.",
            "This is called when one or more of the following things change:",
            "status",
            "activity",
            "This requires Intents.presences and Intents.members to be enabled.",
            "New in version 2.0.",
            "before (Member) – The updated member’s old info.",
            "after (Member) – The updated member’s updated info.",
            "Called when a Member changes their VoiceState.",
            "The following, but not limited to, examples illustrate when this event is called:",
            "A member joins a voice or stage channel.",
            "A member leaves a voice or stage channel.",
            "A member is muted or deafened by their own accord.",
            "A member is muted or deafened by a guild administrator.",
            "This requires Intents.voice_states to be enabled.",
            "member (Member) – The member whose voice states changed.",
            "before (VoiceState) – The voice state prior to the changes.",
            "after (VoiceState) – The voice state after the changes.",
            "Called when a User updates their profile.",
            "This is called when one or more of the following things change:",
            "avatar",
            "username",
            "discriminator",
            "global_name",
            "This requires Intents.members to be enabled.",
            "before (User) – The updated user’s old info.",
            "after (User) – The updated user’s updated info."
        ],
        "code": [
            "Member",
            "Guild",
            "Intents.members",
            "Member",
            "Member",
            "Guild",
            "on_raw_member_remove()",
            "Intents.members",
            "Member",
            "Member",
            "Guild",
            "on_member_remove()",
            "Intents.members",
            "RawMemberRemoveEvent",
            "Member",
            "Intents.members",
            "Member",
            "Member",
            "Member",
            "Intents.presences",
            "Intents.members",
            "Member",
            "Member",
            "Member",
            "VoiceState",
            "Intents.voice_states",
            "Member",
            "VoiceState",
            "VoiceState",
            "User",
            "Intents.members",
            "User",
            "User"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Messages#",
        "content": [
            "Called when a Message is created and sent.",
            "This requires Intents.messages to be enabled.",
            "Warning",
            "Your bot’s own messages and private messages are sent through this\nevent. This can lead cases of ‘recursion’ depending on how your bot was\nprogrammed. If you want the bot to not reply to itself, consider\nchecking the user IDs. Note that Bot does not\nhave this problem.",
            "message (Message) – The current message.",
            "Called when a message is deleted. If the message is not found in the\ninternal message cache, then this event will not be called.\nMessages might not be in cache if the message is too old\nor the client is participating in high traffic guilds.",
            "If this occurs increase the max_messages parameter\nor use the on_raw_message_delete() event instead.",
            "This requires Intents.messages to be enabled.",
            "message (Message) – The deleted message.",
            "Called when messages are bulk deleted. If none of the messages deleted\nare found in the internal message cache, then this event will not be called.\nIf individual messages were not found in the internal message cache,\nthis event will still be called, but the messages not found will not be included in\nthe messages list. Messages might not be in cache if the message is too old\nor the client is participating in high traffic guilds.",
            "If this occurs increase the max_messages parameter\nor use the on_raw_bulk_message_delete() event instead.",
            "This requires Intents.messages to be enabled.",
            "messages (List[Message]) – The messages that have been deleted.",
            "Called when a message is deleted. Unlike on_message_delete(), this is\ncalled regardless of the message being in the internal message cache or not.",
            "If the message is found in the message cache,\nit can be accessed via RawMessageDeleteEvent.cached_message",
            "This requires Intents.messages to be enabled.",
            "payload (RawMessageDeleteEvent) – The raw event payload data.",
            "Called when a bulk delete is triggered. Unlike on_bulk_message_delete(), this is\ncalled regardless of the messages being in the internal message cache or not.",
            "If the messages are found in the message cache,\nthey can be accessed via RawBulkMessageDeleteEvent.cached_messages",
            "This requires Intents.messages to be enabled.",
            "payload (RawBulkMessageDeleteEvent) – The raw event payload data.",
            "Called when a Message receives an update event. If the message is not found\nin the internal message cache, then these events will not be called.\nMessages might not be in cache if the message is too old\nor the client is participating in high traffic guilds.",
            "If this occurs increase the max_messages parameter\nor use the on_raw_message_edit() event instead.",
            "The following non-exhaustive cases trigger this event:",
            "A message has been pinned or unpinned.",
            "The message content has been changed.",
            "The message has received an embed.",
            "For performance reasons, the embed server does not do this in a “consistent” manner.",
            "The message’s embeds were suppressed or unsuppressed.",
            "A call message has received an update to its participants or ending time.",
            "A poll has ended and the results have been finalized.",
            "This requires Intents.messages to be enabled.",
            "before (Message) – The previous version of the message.",
            "after (Message) – The current version of the message.",
            "Called when a message is edited. Unlike on_message_edit(), this is called\nregardless of the state of the internal message cache.",
            "If the message is found in the message cache,\nit can be accessed via RawMessageUpdateEvent.cached_message. The cached message represents\nthe message before it has been edited. For example, if the content of a message is modified and\ntriggers the on_raw_message_edit() coroutine, the RawMessageUpdateEvent.cached_message\nwill return a Message object that represents the message before the content was modified.",
            "Due to the inherently raw nature of this event, the data parameter coincides with\nthe raw data given by the gateway.",
            "Since the data payload can be partial, care must be taken when accessing stuff in the dictionary.\nOne example of a common case of partial data is when the 'content' key is inaccessible. This\ndenotes an “embed” only edit, which is an edit in which only the embeds are updated by the Discord\nembed server.",
            "This requires Intents.messages to be enabled.",
            "payload (RawMessageUpdateEvent) – The raw event payload data."
        ],
        "code": [
            "Message",
            "Intents.messages",
            "Bot",
            "Message",
            "max_messages",
            "on_raw_message_delete()",
            "Intents.messages",
            "Message",
            "max_messages",
            "on_raw_bulk_message_delete()",
            "Intents.messages",
            "Message",
            "on_message_delete()",
            "RawMessageDeleteEvent.cached_message",
            "Intents.messages",
            "RawMessageDeleteEvent",
            "on_bulk_message_delete()",
            "RawBulkMessageDeleteEvent.cached_messages",
            "Intents.messages",
            "RawBulkMessageDeleteEvent",
            "Message",
            "max_messages",
            "on_raw_message_edit()",
            "Intents.messages",
            "Message",
            "Message",
            "on_message_edit()",
            "RawMessageUpdateEvent.cached_message",
            "on_raw_message_edit()",
            "RawMessageUpdateEvent.cached_message",
            "Message",
            "'content'",
            "Intents.messages",
            "RawMessageUpdateEvent"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Polls#",
        "content": [
            "Called when a vote is cast on a poll. If multiple answers were selected, this fires multiple times.\nif the poll was not found in the internal poll cache, then this\nevent will not be called. Consider using on_raw_poll_vote_add() instead.",
            "This requires Intents.polls to be enabled.",
            "poll (Poll) – The current state of the poll.",
            "user (Union[Member, User]) – The user who added the vote.",
            "answer (PollAnswer) – The answer that was voted.",
            "Called when a vote is cast on a poll. Unlike on_poll_vote_add(), this is\ncalled regardless of the state of the internal poll cache.",
            "This requires Intents.polls to be enabled.",
            "payload (RawMessagePollVoteEvent) – The raw event payload data.",
            "Called when a vote is removed from a poll. If multiple answers were removed, this fires multiple times.\nif the poll is not found in the internal poll cache, then this\nevent will not be called. Consider using on_raw_poll_vote_remove() instead.",
            "This requires Intents.polls to be enabled.",
            "poll (Poll) – The current state of the poll.",
            "user (Union[Member, User]) – The user who removed the vote.",
            "answer (PollAnswer) – The answer that was voted.",
            "Called when a vote is removed from a poll. Unlike on_poll_vote_remove(), this is\ncalled regardless of the state of the internal message cache.",
            "This requires Intents.polls to be enabled.",
            "payload (RawMessagePollVoteEvent) – The raw event payload data."
        ],
        "code": [
            "on_raw_poll_vote_add()",
            "Intents.polls",
            "Poll",
            "Member",
            "User",
            "PollAnswer",
            "on_poll_vote_add()",
            "Intents.polls",
            "RawMessagePollVoteEvent",
            "on_raw_poll_vote_remove()",
            "Intents.polls",
            "Poll",
            "Member",
            "User",
            "PollAnswer",
            "on_poll_vote_remove()",
            "Intents.polls",
            "RawMessagePollVoteEvent"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Reactions#",
        "content": [
            "Called when a message has a reaction added to it. Similar to on_message_edit(),\nif the message is not found in the internal message cache, then this\nevent will not be called. Consider using on_raw_reaction_add() instead.",
            "Note",
            "To get the Message being reacted, access it via Reaction.message.",
            "This requires Intents.reactions to be enabled.",
            "Note",
            "This doesn’t require Intents.members within a guild context,\nbut due to Discord not providing updated user information in a direct message\nit’s required for direct messages to receive this event.\nConsider using on_raw_reaction_add() if you need this and do not otherwise want\nto enable the members intent.",
            "reaction (Reaction) – The current state of the reaction.",
            "user (Union[Member, User]) – The user who added the reaction.",
            "Called when a message has a reaction added. Unlike on_reaction_add(), this is\ncalled regardless of the state of the internal message cache.",
            "This requires Intents.reactions to be enabled.",
            "payload (RawReactionActionEvent) – The raw event payload data.",
            "Called when a message has a reaction removed from it. Similar to on_message_edit,\nif the message is not found in the internal message cache, then this event\nwill not be called.",
            "Note",
            "To get the message being reacted, access it via Reaction.message.",
            "This requires both Intents.reactions and Intents.members to be enabled.",
            "Note",
            "Consider using on_raw_reaction_remove() if you need this and do not want\nto enable the members intent.",
            "reaction (Reaction) – The current state of the reaction.",
            "user (Union[Member, User]) – The user who added the reaction.",
            "Called when a message has a reaction removed. Unlike on_reaction_remove(), this is\ncalled regardless of the state of the internal message cache.",
            "This requires Intents.reactions to be enabled.",
            "payload (RawReactionActionEvent) – The raw event payload data.",
            "Called when a message has all its reactions removed from it. Similar to on_message_edit(),\nif the message is not found in the internal message cache, then this event\nwill not be called. Consider using on_raw_reaction_clear() instead.",
            "This requires Intents.reactions to be enabled.",
            "message (Message) – The message that had its reactions cleared.",
            "reactions (List[Reaction]) – The reactions that were removed.",
            "Called when a message has all its reactions removed. Unlike on_reaction_clear(),\nthis is called regardless of the state of the internal message cache.",
            "This requires Intents.reactions to be enabled.",
            "payload (RawReactionClearEvent) – The raw event payload data.",
            "Called when a message has a specific reaction removed from it. Similar to on_message_edit(),\nif the message is not found in the internal message cache, then this event\nwill not be called. Consider using on_raw_reaction_clear_emoji() instead.",
            "This requires Intents.reactions to be enabled.",
            "New in version 1.3.",
            "reaction (Reaction) – The reaction that got cleared.",
            "Called when a message has a specific reaction removed from it. Unlike on_reaction_clear_emoji() this is called\nregardless of the state of the internal message cache.",
            "This requires Intents.reactions to be enabled.",
            "New in version 1.3.",
            "payload (RawReactionClearEmojiEvent) – The raw event payload data."
        ],
        "code": [
            "on_message_edit()",
            "on_raw_reaction_add()",
            "Message",
            "Reaction.message",
            "Intents.reactions",
            "Intents.members",
            "on_raw_reaction_add()",
            "Reaction",
            "Member",
            "User",
            "on_reaction_add()",
            "Intents.reactions",
            "RawReactionActionEvent",
            "Reaction.message",
            "Intents.reactions",
            "Intents.members",
            "on_raw_reaction_remove()",
            "Reaction",
            "Member",
            "User",
            "on_reaction_remove()",
            "Intents.reactions",
            "RawReactionActionEvent",
            "on_message_edit()",
            "on_raw_reaction_clear()",
            "Intents.reactions",
            "Message",
            "Reaction",
            "on_reaction_clear()",
            "Intents.reactions",
            "RawReactionClearEvent",
            "on_message_edit()",
            "on_raw_reaction_clear_emoji()",
            "Intents.reactions",
            "Reaction",
            "on_reaction_clear_emoji()",
            "Intents.reactions",
            "RawReactionClearEmojiEvent"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Scheduled Events#",
        "content": [
            "Called when an ScheduledEvent is created.",
            "This requires Intents.scheduled_events to be enabled.",
            "event (ScheduledEvent) – The newly created scheduled event.",
            "Called when a scheduled event is updated.",
            "This requires Intents.scheduled_events to be enabled.",
            "before (ScheduledEvent) – The old scheduled event.",
            "after (ScheduledEvent) – The updated scheduled event.",
            "Called when a scheduled event is deleted.",
            "This requires Intents.scheduled_events to be enabled.",
            "event (ScheduledEvent) – The deleted scheduled event.",
            "Called when a user subscribes to an event. If the member or event\nis not found in the internal cache, then this event will not be\ncalled. Consider using on_raw_scheduled_event_user_add() instead.",
            "This requires Intents.scheduled_events to be enabled.",
            "event (ScheduledEvent) – The scheduled event subscribed to.",
            "member (Member) – The member who subscribed.",
            "Called when a user subscribes to an event. Unlike\non_scheduled_event_user_add(), this will be called\nregardless of the state of the internal cache.",
            "This requires Intents.scheduled_events to be enabled.",
            "payload (RawScheduledEventSubscription) – The raw event payload data.",
            "Called when a user unsubscribes to an event. If the member or event is\nnot found in the internal cache, then this event will not be called.\nConsider using on_raw_scheduled_event_user_remove() instead.",
            "This requires Intents.scheduled_events to be enabled.",
            "event (ScheduledEvent) – The scheduled event unsubscribed from.",
            "member (Member) – The member who unsubscribed.",
            "Called when a user unsubscribes to an event. Unlike\non_scheduled_event_user_remove(), this will be called\nregardless of the state of the internal cache.",
            "This requires Intents.scheduled_events to be enabled.",
            "payload (RawScheduledEventSubscription) – The raw event payload data."
        ],
        "code": [
            "ScheduledEvent",
            "Intents.scheduled_events",
            "ScheduledEvent",
            "Intents.scheduled_events",
            "ScheduledEvent",
            "ScheduledEvent",
            "Intents.scheduled_events",
            "ScheduledEvent",
            "on_raw_scheduled_event_user_add()",
            "Intents.scheduled_events",
            "ScheduledEvent",
            "Member",
            "on_scheduled_event_user_add()",
            "Intents.scheduled_events",
            "RawScheduledEventSubscription",
            "on_raw_scheduled_event_user_remove()",
            "Intents.scheduled_events",
            "ScheduledEvent",
            "Member",
            "on_scheduled_event_user_remove()",
            "Intents.scheduled_events",
            "RawScheduledEventSubscription"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Stage Instances#",
        "content": [
            "Called when a StageInstance is created or deleted for a StageChannel.",
            "New in version 2.0.",
            "stage_instance (StageInstance) – The stage instance that was created or deleted.",
            "Called when a StageInstance is updated.",
            "The following, but not limited to, examples illustrate when this event is called:",
            "The topic is changed.",
            "The privacy level is changed.",
            "New in version 2.0.",
            "before (StageInstance) – The stage instance before the update.",
            "after (StageInstance) – The stage instance after the update."
        ],
        "code": [
            "StageInstance",
            "StageChannel",
            "StageInstance",
            "StageInstance",
            "StageInstance",
            "StageInstance"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Threads#",
        "content": [
            "Called whenever a thread is joined.",
            "Note that you can get the guild from Thread.guild.",
            "This requires Intents.guilds to be enabled.",
            "New in version 2.0.",
            "thread (Thread) – The thread that got joined.",
            "Called whenever a thread is created.",
            "Note that you can get the guild from Thread.guild.",
            "This requires Intents.guilds to be enabled.",
            "New in version 2.0.",
            "thread (Thread) – The thread that got created.",
            "Called whenever a thread is removed. This is different from a thread being deleted.",
            "Note that you can get the guild from Thread.guild.",
            "This requires Intents.guilds to be enabled.",
            "Warning",
            "Due to technical limitations, this event might not be called\nas soon as one expects. Since the library tracks thread membership\nlocally, the API only sends updated thread membership status upon being\nsynced by joining a thread.",
            "New in version 2.0.",
            "thread (Thread) – The thread that got removed.",
            "Called whenever a thread is deleted.  If the deleted thread isn’t found in internal cache\nthen this will not be called. Archived threads are not in the cache. Consider using on_raw_thread_delete()",
            "Note that you can get the guild from Thread.guild.",
            "This requires Intents.guilds to be enabled.",
            "New in version 2.0.",
            "thread (Thread) – The thread that got deleted.",
            "Called whenever a thread is deleted. Unlike on_thread_delete() this is called\nregardless of the state of the internal cache.",
            "payload (RawThreadDeleteEvent) – The raw event payload data.",
            "Called when a ThreadMember leaves or joins a Thread.",
            "You can get the thread a member belongs in by accessing ThreadMember.thread.",
            "This requires Intents.members to be enabled.",
            "New in version 2.0.",
            "member (ThreadMember) – The member who joined or left.",
            "Called when a ThreadMember leaves a Thread. Unlike on_thread_member_remove() this\nis called regardless of the member being in the thread’s internal cache of members or not.",
            "This requires Intents.members to be enabled.",
            "New in version 2.4.",
            "payload – The raw event payload data.",
            "Called whenever a thread is updated.",
            "This requires Intents.guilds to be enabled.",
            "If the thread could not be found in the internal cache, this event will not be called.\nThreads will not be in the cache if they are archived. Alternatively,\non_raw_thread_update() is called regardless of the internal cache.",
            "New in version 2.0.",
            "before (Thread) – The updated thread’s old info.",
            "after (Thread) – The updated thread’s new info.",
            "Called whenever a thread is updated.",
            "Unlike on_thread_update() this is called regardless of if the thread is in the\ninternal thread cache or not.",
            "This requires Intents.guilds to be enabled.",
            "New in version 2.4.",
            "payload (RawThreadUpdateEvent) – The raw event payload data."
        ],
        "code": [
            "Thread.guild",
            "Intents.guilds",
            "Thread",
            "Thread.guild",
            "Intents.guilds",
            "Thread",
            "Thread.guild",
            "Intents.guilds",
            "Thread",
            "on_raw_thread_delete()",
            "Thread.guild",
            "Intents.guilds",
            "Thread",
            "on_thread_delete()",
            "RawThreadDeleteEvent",
            "ThreadMember",
            "Thread",
            "ThreadMember.thread",
            "Intents.members",
            "ThreadMember",
            "ThreadMember",
            "Thread",
            "on_thread_member_remove()",
            "Intents.members",
            "Intents.guilds",
            "on_raw_thread_update()",
            "Thread",
            "Thread",
            "on_thread_update()",
            "Intents.guilds",
            "RawThreadUpdateEvent"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Typing#",
        "content": [
            "Called when someone begins typing a message.",
            "The channel parameter can be a abc.Messageable instance.\nWhich could either be TextChannel, GroupChannel, or\nDMChannel.",
            "If the channel is a TextChannel then the user parameter\nis a Member, otherwise it is a User.",
            "This requires Intents.typing to be enabled.",
            "channel (abc.Messageable) – The location where the typing originated from.",
            "user (Union[User, Member]) – The user that started typing.",
            "when (datetime.datetime) – When the typing started as an aware datetime in UTC.",
            "Called when someone begins typing a message. Unlike on_typing(), this is\ncalled regardless if the user can be found in the bot’s cache or not.",
            "If the typing event is occurring in a guild,\nthe member that started typing can be accessed via RawTypingEvent.member",
            "This requires Intents.typing to be enabled.",
            "payload (RawTypingEvent) – The raw typing payload."
        ],
        "code": [
            "channel",
            "abc.Messageable",
            "TextChannel",
            "GroupChannel",
            "DMChannel",
            "channel",
            "TextChannel",
            "user",
            "Member",
            "User",
            "Intents.typing",
            "abc.Messageable",
            "User",
            "Member",
            "datetime.datetime",
            "on_typing()",
            "RawTypingEvent.member",
            "Intents.typing",
            "RawTypingEvent"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Voice Channel Status Update#",
        "content": [
            "Called when someone updates a voice channel status.",
            "New in version 2.5.",
            "channel (abc.GuildChannel) – The channel where the voice channel status update originated from.",
            "before (Optional[str]) – The old voice channel status.",
            "after (Optional[str]) – The new voice channel status.",
            "Called when someone updates a voice channels status.",
            "New in version 2.5.",
            "payload (RawVoiceChannelStatusUpdateEvent) – The raw voice channel status update payload."
        ],
        "code": [
            "abc.GuildChannel",
            "str",
            "str",
            "RawVoiceChannelStatusUpdateEvent",
            "on_application_command()",
            "on_application_command_completion()",
            "on_application_command_error()",
            "on_unknown_application_command()",
            "on_audit_log_entry()",
            "on_raw_audit_log_entry()",
            "on_auto_moderation_rule_create()",
            "on_auto_moderation_rule_update()",
            "on_auto_moderation_rule_delete()",
            "on_auto_moderation_action_execution()",
            "on_member_ban()",
            "on_member_unban()",
            "on_private_channel_update()",
            "on_private_channel_pins_update()",
            "on_guild_channel_update()",
            "on_guild_channel_pins_update()",
            "on_guild_channel_delete()",
            "on_guild_channel_create()",
            "on_error()",
            "on_connect()",
            "on_shard_connect()",
            "on_disconnect()",
            "on_shard_disconnect()",
            "on_ready()",
            "on_shard_ready()",
            "on_resumed()",
            "on_shard_resumed()",
            "on_socket_event_type()",
            "on_socket_raw_receive()",
            "on_socket_raw_send()",
            "on_entitlement_create()",
            "on_entitlement_update()",
            "on_entitlement_delete()",
            "on_guild_join()",
            "on_guild_remove()",
            "on_guild_update()",
            "on_guild_role_create()",
            "on_guild_role_delete()",
            "on_guild_role_update()",
            "on_guild_emojis_update()",
            "on_guild_stickers_update()",
            "on_guild_available()",
            "on_guild_unavailable()",
            "on_webhooks_update()",
            "on_guild_integrations_update()",
            "on_integration_create()",
            "on_integration_update()",
            "on_raw_integration_delete()",
            "on_interaction()",
            "on_invite_create()",
            "on_invite_delete()",
            "on_member_join()",
            "on_member_remove()",
            "on_raw_member_remove()",
            "on_member_update()",
            "on_presence_update()",
            "on_voice_state_update()",
            "on_user_update()",
            "on_message()",
            "on_message_delete()",
            "on_bulk_message_delete()",
            "on_raw_message_delete()",
            "on_raw_bulk_message_delete()",
            "on_message_edit()",
            "on_raw_message_edit()",
            "on_poll_vote_add()",
            "on_raw_poll_vote_add()",
            "on_poll_vote_remove()",
            "on_raw_poll_vote_remove()",
            "on_reaction_add()",
            "on_raw_reaction_add()",
            "on_reaction_remove()",
            "on_raw_reaction_remove()",
            "on_reaction_clear()",
            "on_raw_reaction_clear()",
            "on_reaction_clear_emoji()",
            "on_raw_reaction_clear_emoji()",
            "on_scheduled_event_create()",
            "on_scheduled_event_update()",
            "on_scheduled_event_delete()",
            "on_scheduled_event_user_add()",
            "on_raw_scheduled_event_user_add()",
            "on_scheduled_event_user_remove()",
            "on_raw_scheduled_event_user_remove()",
            "on_stage_instance_create()",
            "on_stage_instance_delete()",
            "on_stage_instance_update()",
            "on_thread_join()",
            "on_thread_create()",
            "on_thread_remove()",
            "on_thread_delete()",
            "on_raw_thread_delete()",
            "on_thread_member_join()",
            "on_thread_member_remove()",
            "on_raw_thread_member_remove()",
            "on_thread_update()",
            "on_raw_thread_update()",
            "on_typing()",
            "on_raw_typing()",
            "on_voice_channel_status_update()",
            "on_raw_voice_channel_status_update()"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/events.html"
    },
    {
        "title": "Client Objects#",
        "content": [],
        "code": [],
        "url": "https://docs.pycord.dev/en/stable/api/clients.html"
    },
    {
        "title": "Bots#",
        "content": [
            "Represents a discord bot.",
            "This class is a subclass of discord.Client and as a result\nanything that you can do with a discord.Client you can do with\nthis bot.",
            "This class also subclasses ApplicationCommandMixin to provide the functionality\nto manage commands.",
            "New in version 2.0.",
            "The content prefixed into the default help message.",
            "str",
            "The user ID that owns the bot. If this is not set and is then queried via\nis_owner() then it is fetched automatically using\napplication_info().",
            "Optional[int]",
            "The user IDs that owns the bot. This is similar to owner_id.\nIf this is not set and the application is team based, then it is\nfetched automatically using application_info().\nFor performance reasons it is recommended to use a set\nfor the collection. You cannot set both owner_id and owner_ids.",
            "New in version 1.3.",
            "Optional[Collection[int]]",
            "Guild IDs of guilds to use for testing commands.\nThe bot will not create any global commands if debug guild IDs are passed.",
            "New in version 2.0.",
            "Optional[List[int]]",
            "Whether to automatically sync slash commands. This will call sync_commands() in discord.on_connect(), and in\nprocess_application_commands if the command is not found. Defaults to True.",
            "New in version 2.0.",
            "bool",
            "The default context types that the bot will use for commands.\nDefaults to a set containing InteractionContextType.guild, InteractionContextType.bot_dm, and\nInteractionContextType.private_channel.",
            "New in version 2.6.",
            "Collection[InteractionContextType]",
            "The default integration types that the bot will use for commands.\nDefaults to a set containing IntegrationType.guild_install.",
            "New in version 2.6.",
            "Collection[IntegrationType]]",
            "An alias for application_command().",
            "Note",
            "This decorator is overridden by discord.ext.commands.Bot.",
            "New in version 2.0.",
            "A decorator that converts the provided method into an ApplicationCommand, adds it to the bot,\nthen returns it.",
            "Callable[…, ApplicationCommand]",
            "A decorator that registers an event to listen to.",
            "You can find more info about the events on the documentation below.",
            "The events must be a coroutine, if not, TypeError is raised.",
            "Note",
            "This replaces any default handlers.\nDevelopers are encouraged to use listen() for adding additional handlers\ninstead of event() unless default method replacement is intended.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "Example",
            "coro (TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])) –",
            "TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])",
            "A shortcut decorator that invokes command() and adds it to\nthe internal command list via add_application_command().\nThis shortcut is made specifically for MessageCommand.",
            "New in version 2.0.",
            "A decorator that converts the provided method into a MessageCommand, adds it to the bot,\nthen returns it.",
            "Callable[…, MessageCommand]",
            "A shortcut decorator that invokes command() and adds it to\nthe internal command list via add_application_command().\nThis shortcut is made specifically for SlashCommand.",
            "New in version 2.0.",
            "A decorator that converts the provided method into a SlashCommand, adds it to the bot,\nthen returns it.",
            "Callable[…, SlashCommand]",
            "A shortcut decorator that invokes command() and adds it to\nthe internal command list via add_application_command().\nThis shortcut is made specifically for UserCommand.",
            "New in version 2.0.",
            "A decorator that converts the provided method into a UserCommand, adds it to the bot,\nthen returns it.",
            "Callable[…, UserCommand]",
            "A decorator that registers another function as an external\nevent listener. Basically this allows you to listen to multiple\nevents from different places e.g. such as on_ready()",
            "The functions being listened to must be a coroutine.",
            "TypeError – The function being listened to is not a coroutine.",
            "ValueError – The name (event name) does not start with ‘on_’",
            "Example",
            "Would print one and two in an unspecified order.",
            "name (str) –",
            "once (bool) –",
            "Callable[[TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])], TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])]",
            "The activity being used upon logging in.",
            "Optional[BaseActivity]",
            "Adds an ApplicationCommand into the internal list of commands.",
            "This is usually not called, instead the command() or\nother shortcut decorators are used instead.",
            "New in version 2.0.",
            "command (ApplicationCommand) – The command to add.",
            "None",
            "Adds a global check to the bot. This is the non-decorator interface to check() and\ncheck_once().",
            "func – The function that was used as a global check.",
            "call_once (bool) – If the function should only be called once per Bot.invoke() call.",
            "None",
            "Adds a “cog” to the bot.",
            "A cog is a class that has its own event listeners and commands.",
            "Changed in version 2.0: ClientException is raised when a cog with the same name\nis already loaded.",
            "cog (Cog) – The cog to register to the bot.",
            "override (bool) – If a previously loaded cog with the same name should be ejected\ninstead of raising an error.\n\nNew in version 2.0.",
            "If a previously loaded cog with the same name should be ejected\ninstead of raising an error.",
            "New in version 2.0.",
            "TypeError – The cog does not inherit from Cog.",
            "ApplicationCommandError – An error happened during loading.",
            "ClientException – A cog with the same name is already loaded.",
            "None",
            "The non decorator alternative to listen().",
            "func (coroutine) – The function to call.",
            "name (str) – The name of the event to listen for. Defaults to func.__name__.",
            "TypeError – The func parameter is not a coroutine function.",
            "ValueError – The name (event name) does not start with ‘on_’",
            "None",
            "Example",
            "Registers a View for persistent listening.",
            "This method should be used for when a view is comprised of components\nthat last longer than the lifecycle of the program.",
            "New in version 2.0.",
            "view (discord.ui.View) – The view to register for dispatching.",
            "message_id (Optional[int]) – The message ID that the view is attached to. This is currently used to\nrefresh the view’s state during message update events. If not given\nthen message update events are not propagated for the view.",
            "TypeError – A view was not passed.",
            "ValueError – The view is not persistent. A persistent view has no timeout\n    and all their components have an explicitly provided custom_id.",
            "None",
            "A decorator that registers a coroutine as a post-invoke hook.\nA post-invoke hook is called directly after the command is\ncalled. This makes it a useful function to clean-up database\nconnections or any type of clean up required.\nThis post-invoke hook takes a sole parameter, a Context.",
            "Note",
            "Similar to before_invoke(), this is not called unless\nchecks and argument parsing procedures succeed. This hook is,\nhowever, always called regardless of the internal command\ncallback raising an error (i.e. CommandInvokeError).\nThis makes it ideal for clean-up scenarios.",
            "coro (coroutine) – The coroutine to register as the post-invoke hook.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "The allowed mention configuration.",
            "New in version 1.4.",
            "A shortcut decorator that invokes command() and adds it to\nthe internal command list via add_application_command().",
            "New in version 2.0.",
            "A decorator that converts the provided method into an ApplicationCommand, adds it to the bot,\nthen returns it.",
            "Callable[…, ApplicationCommand]",
            "The client’s application flags.",
            "New in version 2.0.",
            "The client’s application ID.",
            "If this is not passed via __init__ then this is retrieved\nthrough the gateway when an event contains the data. Usually\nafter on_connect() is called.",
            "New in version 2.0.",
            "This function is a coroutine.",
            "Retrieves the bot’s application information.",
            "The bot’s application information.",
            "AppInfo",
            "HTTPException – Retrieving the information failed somehow.",
            "This function is a coroutine.",
            "A hook that is called before IDENTIFYing a session. This is useful\nif you wish to have more control over the synchronization of multiple\nIDENTIFYing clients.",
            "The default implementation sleeps for 5 seconds.",
            "New in version 1.4.",
            "shard_id (int) – The shard ID that requested being IDENTIFY’d",
            "initial (bool) – Whether this IDENTIFY is the first initial IDENTIFY.",
            "None",
            "A decorator that registers a coroutine as a pre-invoke hook.\nA pre-invoke hook is called directly before the command is\ncalled. This makes it a useful function to set up database\nconnections or any type of set up required.\nThis pre-invoke hook takes a sole parameter, a Context.",
            "Note",
            "The before_invoke() and after_invoke() hooks are\nonly called if all checks and argument parsing procedures pass\nwithout error. If any check or argument parsing procedures fail\nthen the hooks are not called.",
            "coro (coroutine) – The coroutine to register as the pre-invoke hook.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "Read-only list of messages the connected client has cached.",
            "New in version 1.1.",
            "This function is a coroutine.",
            "Changes the client’s presence.",
            "activity (Optional[BaseActivity]) – The activity being done. None if no currently active activity is done.",
            "status (Optional[Status]) – Indicates what status to change to. If None, then\nStatus.online is used.",
            "InvalidArgument – If the activity parameter is not the proper type.",
            "Example",
            "Changed in version 2.0: Removed the afk keyword-only parameter.",
            "A decorator that adds a global check to the bot. A global check is similar to a check() that is\napplied on a per-command basis except it is run before any command checks have been verified and applies to\nevery command the bot has.",
            "Note",
            "This function can either be a regular function or a coroutine. Similar to a command check(), this\ntakes a single parameter of type Context and can only raise exceptions inherited from\nApplicationCommandError.",
            "Example",
            "A decorator that adds a “call once” global check to the bot. Unlike regular global checks, this one is called\nonly once per Bot.invoke() call. Regular global checks are called whenever a command is called or\nCommand.can_run() is called. This type of check bypasses that and ensures that it’s called only once,\neven inside the default help command.",
            "Note",
            "When using this function the Context sent to a group subcommand may only parse the parent command\nand not the subcommands due to it being invoked once per Bot.invoke() call.",
            "Note",
            "This function can either be a regular function or a coroutine. Similar to a command check(),\nthis takes a single parameter of type Context and can only raise exceptions inherited from\nApplicationCommandError.",
            "Example",
            "Clears the internal state of the bot.",
            "After this, the bot can be considered “re-opened”, i.e. is_closed()\nand is_ready() both return False along with the bot’s internal\ncache cleared.",
            "None",
            "This function is a coroutine.",
            "Closes the connection to Discord.",
            "None",
            "A read-only mapping of cog name to cog.",
            "This function is a coroutine.",
            "Creates a WebSocket connection and lets the WebSocket listen\nto messages from Discord. This is a loop that runs the entire\nevent system and miscellaneous aspects of the library. Control\nis not resumed until the WebSocket connection is terminated.",
            "reconnect (bool) – If we should attempt reconnecting, either due to internet\nfailure or a specific failure on Discord’s part. Certain\ndisconnects that lead to bad state will not be handled (such as\ninvalid sharding payloads or bad tokens).",
            "GatewayNotFound – The gateway to connect to Discord is not found. Usually if this\n    is thrown then there is a Discord API outage.",
            "ConnectionClosed – The WebSocket connection has been terminated.",
            "None",
            "This function is a coroutine.",
            "Creates a DMChannel with this user.",
            "This should be rarely called, as this is done transparently for most\npeople.",
            "New in version 2.0.",
            "user (Snowflake) – The user to create a DM with.",
            "The channel that was created.",
            "DMChannel",
            "A shortcut method that creates a slash command group with no subcommands and adds it to the internal\ncommand list via add_application_command().",
            "New in version 2.0.",
            "name (str) – The name of the group to create.",
            "description (Optional[str]) – The description of the group to create.",
            "guild_ids (Optional[List[int]]) – A list of the IDs of each guild this group should be added to, making it a guild command.\nThis will be a global command if None is passed.",
            "kwargs – Any additional keyword arguments to pass to SlashCommandGroup.",
            "The slash command group that was created.",
            "SlashCommandGroup",
            "This function is a coroutine.",
            "Creates a Guild.",
            "Bot accounts in more than 10 guilds are not allowed to create guilds.",
            "name (str) – The name of the guild.",
            "icon (Optional[bytes]) – The bytes-like object representing the icon. See ClientUser.edit()\nfor more details on what is expected.",
            "code (str) – The code for a template to create the guild with.\n\nNew in version 1.4.",
            "The code for a template to create the guild with.",
            "New in version 1.4.",
            "The guild created. This is not the same guild that is\nadded to cache.",
            "Guild",
            "HTTPException – Guild creation failed.",
            "InvalidArgument – Invalid icon image format given. Must be PNG or JPG.",
            "This function is a coroutine.",
            "Revokes an Invite, URL, or ID to an invite.",
            "You must have the manage_channels permission in\nthe associated guild to do this.",
            "invite (Union[Invite, str]) – The invite to revoke.",
            "Forbidden – You do not have permissions to revoke invites.",
            "NotFound – The invite is invalid or expired.",
            "HTTPException – Revoking the invite failed.",
            "None",
            "The emojis that the connected client has.",
            "Returns an AsyncIterator that enables fetching the application’s entitlements.",
            "New in version 2.6.",
            "user (abc.Snowflake | None) – Limit the fetched entitlements to entitlements owned by this user.",
            "skus (list[abc.Snowflake] | None) – Limit the fetched entitlements to entitlements that are for these SKUs.",
            "before (abc.Snowflake | datetime.datetime | None) – Retrieves guilds before this date or object.\nIf a datetime is provided, it is recommended to use a UTC-aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (abc.Snowflake | datetime.datetime | None) – Retrieve guilds after this date or object.\nIf a datetime is provided, it is recommended to use a UTC-aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "limit (Optional[int]) – The number of entitlements to retrieve.\nIf None, retrieves every entitlement, which may be slow.\nDefaults to 100.",
            "guild (abc.Snowflake | None) – Limit the fetched entitlements to entitlements owned by this guild.",
            "exclude_ended (bool) – Whether to limit the fetched entitlements to those that have not ended.\nDefaults to False.",
            "Entitlement – The application’s entitlements.",
            "HTTPException – Retrieving the entitlements failed.",
            "EntitlementIterator",
            "Examples",
            "Usage",
            "Flattening into a list",
            "All parameters are optional.",
            "A read-only mapping of extension name to extension.",
            "This function is a coroutine.\nRetrieves a PartialAppInfo from an application ID.",
            "application_id (int) – The application ID to retrieve information from.",
            "The application information.",
            "PartialAppInfo",
            "NotFound – An application with this ID does not exist.",
            "HTTPException – Retrieving the application failed.",
            "This function is a coroutine.",
            "Retrieves a abc.GuildChannel, abc.PrivateChannel, or Thread with the specified ID.",
            "Note",
            "This method is an API call. For general usage, consider get_channel() instead.",
            "New in version 1.2.",
            "The channel from the ID.",
            "Union[abc.GuildChannel, abc.PrivateChannel, Thread]",
            "InvalidData – An unknown channel type was received from Discord.",
            "HTTPException – Retrieving the channel failed.",
            "NotFound – Invalid Channel ID.",
            "Forbidden – You do not have permission to fetch this channel.",
            "channel_id (int) –",
            "This function is a coroutine.",
            "Retrieves a Guild from an ID.",
            "Note",
            "Using this, you will not receive Guild.channels, Guild.members,\nMember.activity and Member.voice per Member.",
            "Note",
            "This method is an API call. For general usage, consider get_guild() instead.",
            "guild_id (int) – The guild’s ID to fetch from.",
            "with_counts (bool) – Whether to include count information in the guild. This fills the\nGuild.approximate_member_count and Guild.approximate_presence_count\nfields.\n\nNew in version 2.0.",
            "Whether to include count information in the guild. This fills the\nGuild.approximate_member_count and Guild.approximate_presence_count\nfields.",
            "New in version 2.0.",
            "The guild from the ID.",
            "Guild",
            "Forbidden – You do not have access to the guild.",
            "HTTPException – Getting the guild failed.",
            "Retrieves an AsyncIterator that enables receiving your guilds.",
            "Note",
            "Using this, you will only receive Guild.owner, Guild.icon,\nGuild.id, and Guild.name per Guild.",
            "Note",
            "This method is an API call. For general usage, consider guilds instead.",
            "limit (Optional[int]) – The number of guilds to retrieve.\nIf None, it retrieves every guild you have access to. Note, however,\nthat this would make it a slow operation.\nDefaults to 100.",
            "before (Union[abc.Snowflake, datetime.datetime]) – Retrieves guilds before this date or object.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Union[abc.Snowflake, datetime.datetime]) – Retrieve guilds after this date or object.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "Guild – The guild with the guild data parsed.",
            "HTTPException – Getting the guilds failed.",
            "GuildIterator",
            "Examples",
            "Usage",
            "Flattening into a list",
            "All parameters are optional.",
            "This function is a coroutine.",
            "Gets an Invite from a discord.gg URL or ID.",
            "Note",
            "If the invite is for a guild you have not joined, the guild and channel\nattributes of the returned Invite will be PartialInviteGuild and\nPartialInviteChannel respectively.",
            "url (Union[Invite, str]) – The Discord invite ID or URL (must be a discord.gg URL).",
            "with_counts (bool) – Whether to include count information in the invite. This fills the\nInvite.approximate_member_count and Invite.approximate_presence_count\nfields.",
            "with_expiration (bool) – Whether to include the expiration date of the invite. This fills the\nInvite.expires_at field.\n\nNew in version 2.0.",
            "Whether to include the expiration date of the invite. This fills the\nInvite.expires_at field.",
            "New in version 2.0.",
            "event_id (Optional[int]) – The ID of the scheduled event to be associated with the event.\nSee Invite.set_scheduled_event() for more\ninfo on event invite linking.\n\nNew in version 2.0.",
            "The ID of the scheduled event to be associated with the event.",
            "See Invite.set_scheduled_event() for more\ninfo on event invite linking.",
            "New in version 2.0.",
            "The invite from the URL/ID.",
            "Invite",
            "NotFound – The invite has expired or is invalid.",
            "HTTPException – Getting the invite failed.",
            "This function is a coroutine.",
            "Retrieves all available premium sticker packs.",
            "New in version 2.0.",
            "All available premium sticker packs.",
            "List[StickerPack]",
            "HTTPException – Retrieving the sticker packs failed.",
            "This function is a coroutine.",
            "Fetches the bot’s role connection metadata records.",
            "New in version 2.4.",
            "The bot’s role connection metadata records.",
            "List[ApplicationRoleConnectionMetadata]",
            "This function is a coroutine.",
            "Fetches the bot’s SKUs.",
            "New in version 2.5.",
            "The bot’s SKUs.",
            "List[SKU]",
            "This function is a coroutine.",
            "Gets a StageInstance for a stage channel id.",
            "New in version 2.0.",
            "channel_id (int) – The stage channel ID.",
            "The stage instance from the stage channel ID.",
            "StageInstance",
            "NotFound – The stage instance or channel could not be found.",
            "HTTPException – Getting the stage instance failed.",
            "This function is a coroutine.",
            "Retrieves a Sticker with the specified ID.",
            "New in version 2.0.",
            "The sticker you requested.",
            "Union[StandardSticker, GuildSticker]",
            "HTTPException – Retrieving the sticker failed.",
            "NotFound – Invalid sticker ID.",
            "sticker_id (int) –",
            "This function is a coroutine.",
            "Gets a Template from a discord.new URL or code.",
            "code (Union[Template, str]) – The Discord Template Code or URL (must be a discord.new URL).",
            "The template from the URL/code.",
            "Template",
            "NotFound – The template is invalid.",
            "HTTPException – Getting the template failed.",
            "This function is a coroutine.",
            "Retrieves a User based on their ID.\nYou do not have to share any guilds with the user to get this information,\nhowever many operations do require that you do.",
            "Note",
            "This method is an API call. If you have discord.Intents.members and member cache enabled,\nconsider get_user() instead.",
            "user_id (int) – The user’s ID to fetch from.",
            "The user you requested.",
            "User",
            "NotFound – A user with this ID does not exist.",
            "HTTPException – Fetching the user failed.",
            "This function is a coroutine.",
            "Retrieves a Webhook with the specified ID.",
            "The webhook you requested.",
            "Webhook",
            "HTTPException – Retrieving the webhook failed.",
            "NotFound – Invalid webhook ID.",
            "Forbidden – You do not have permission to fetch this webhook.",
            "webhook_id (int) –",
            "This function is a coroutine.",
            "Gets a Widget from a guild ID.",
            "Note",
            "The guild must have the widget enabled to get this information.",
            "guild_id (int) – The ID of the guild.",
            "The guild’s widget.",
            "Widget",
            "Forbidden – The widget for this guild is disabled.",
            "HTTPException – Retrieving the widget failed.",
            "A generator that retrieves every abc.GuildChannel the client can ‘access’.",
            "This is equivalent to:",
            "Generator[GuildChannel, None, None]",
            "Note",
            "Just because you receive a abc.GuildChannel does not mean that\nyou can communicate in said channel. abc.GuildChannel.permissions_for() should\nbe used for that.",
            "abc.GuildChannel – A channel the client can ‘access’.",
            "Returns a generator with every Member the client can see.",
            "This is equivalent to:",
            "Member – A member the client can see.",
            "Generator[Member, None, None]",
            "Get an ApplicationCommand from the internal list\nof commands.",
            "New in version 2.0.",
            "name (str) – The qualified name of the command to get.",
            "guild_ids (List[int]) – The guild ids associated to the command to get.",
            "type (Type[ApplicationCommand]) – The type of the command to get. Defaults to ApplicationCommand.",
            "The command that was requested. If not found, returns None.",
            "Optional[ApplicationCommand]",
            "This function is a coroutine.",
            "Returns the invocation context from the interaction.",
            "This is a more low-level counter-part for process_application_commands()\nto allow users more fine-grained control over the processing.",
            "interaction (discord.Interaction) – The interaction to get the invocation context from.",
            "cls (Any) – The factory class that will be used to create the context.\nBy default, this is ApplicationContext. Should a custom\nclass be provided, it must be similar enough to\nApplicationContext's interface.",
            "The invocation context. The type of this can change via the\ncls parameter.",
            "ApplicationContext",
            "This function is a coroutine.",
            "Returns the autocomplete context from the interaction.",
            "This is a more low-level counter-part for process_application_commands()\nto allow users more fine-grained control over the processing.",
            "interaction (discord.Interaction) – The interaction to get the invocation context from.",
            "cls (Any) – The factory class that will be used to create the context.\nBy default, this is AutocompleteContext. Should a custom\nclass be provided, it must be similar enough to\nAutocompleteContext's interface.",
            "The autocomplete context. The type of this can change via the\ncls parameter.",
            "AutocompleteContext",
            "Returns a channel or thread with the given ID.",
            "id (int) – The ID to search for.",
            "The returned channel or None if not found.",
            "Optional[Union[abc.GuildChannel, Thread, abc.PrivateChannel]]",
            "Gets the cog instance requested.",
            "If the cog is not found, None is returned instead.",
            "name (str) – The name of the cog you are requesting.\nThis is equivalent to the name passed via keyword\nargument in class creation or the class name if unspecified.",
            "The cog that was requested. If not found, returns None.",
            "Optional[Cog]",
            "Shortcut for get_application_command().",
            "Note",
            "Overridden in ext.commands.Bot.",
            "New in version 2.0.",
            "This function is a coroutine.",
            "Gets the list of commands that are desynced from discord. If guild_id is specified, it will only return\nguild commands that are desynced from said guild, else it will return global commands.",
            "Note",
            "This function is meant to be used internally, and should only be used if you want to override the default\ncommand registration behavior.",
            "New in version 2.0.",
            "guild_id (Optional[int]) – The guild id to get the desynced commands for, else global commands if unspecified.",
            "prefetched (Optional[List[ApplicationCommand]]) – If you already fetched the commands, you can pass them here to be used. Not recommended for typical usage.",
            "A list of the desynced commands. Each will come with at least the cmd and action keys, which\nrespectively contain the command and the action to perform. Other keys may also be present depending on\nthe action, including id.",
            "List[Dict[str, Any]]",
            "Returns an emoji with the given ID.",
            "id (int) – The ID to search for.",
            "The custom emoji or None if not found.",
            "Optional[Emoji]",
            "Returns a guild with the given ID.",
            "id (int) – The ID to search for.",
            "The guild or None if not found.",
            "Optional[Guild]",
            "Returns a message the given ID.",
            "This is useful if you have a message_id but don’t want to do an API call\nto access the message.",
            "id (int) – The ID to search for.",
            "The returned message or None if not found.",
            "Optional[Message]",
            "This function is a coroutine.",
            "Looks up a user in the user cache or fetches if not found.",
            "id (int) – The ID to search for.",
            "The user or None if not found.",
            "Optional[User]",
            "Returns a partial messageable with the given channel ID.",
            "This is useful if you have a channel_id but don’t want to do an API call\nto send messages to it.",
            "New in version 2.0.",
            "id (int) – The channel ID to create a partial messageable for.",
            "type (Optional[ChannelType]) – The underlying channel type for the partial messageable.",
            "The partial messageable",
            "PartialMessageable",
            "Returns a poll attached to the given message ID.",
            "id (int) – The message ID of the poll to search for.",
            "The poll or None if not found.",
            "Optional[Poll]",
            "Returns a stage instance with the given stage channel ID.",
            "New in version 2.0.",
            "id (int) – The ID to search for.",
            "The stage instance or None if not found.",
            "Optional[StageInstance]",
            "Returns a guild sticker with the given ID.",
            "New in version 2.0.",
            "Note",
            "To retrieve standard stickers, use fetch_sticker().\nor fetch_premium_sticker_packs().",
            "The sticker or None if not found.",
            "Optional[GuildSticker]",
            "id (int) –",
            "Returns a user with the given ID.",
            "id (int) – The ID to search for.",
            "The user or None if not found.",
            "Optional[User]",
            "A shortcut decorator that initializes the provided subclass of SlashCommandGroup\nand adds it to the internal command list via add_application_command().",
            "New in version 2.0.",
            "name (Optional[str]) – The name of the group to create. This will resolve to the name of the decorated class if None is passed.",
            "description (Optional[str]) – The description of the group to create.",
            "guild_ids (Optional[List[int]]) – A list of the IDs of each guild this group should be added to, making it a guild command.\nThis will be a global command if None is passed.",
            "The slash command group that was created.",
            "Callable[[Type[SlashCommandGroup]], SlashCommandGroup]",
            "The guilds that the connected client is a member of.",
            "The intents configured for this connection.",
            "New in version 1.5.",
            "This function is a coroutine.",
            "Invokes the application command given under the invocation\ncontext and handles all the internal event dispatch mechanisms.",
            "ctx (ApplicationCommand) – The invocation context to invoke.",
            "None",
            "Indicates if the WebSocket connection is closed.",
            "bool",
            "This function is a coroutine.",
            "Checks if a User or Member is the owner of\nthis bot.",
            "If an owner_id is not set, it is fetched automatically\nthrough the use of application_info().",
            "Changed in version 1.3: The function also checks if the application is team-owned if\nowner_ids is not set.",
            "user (abc.User) – The user to check for.",
            "Whether the user is the owner.",
            "bool",
            "Specifies if the client’s internal cache is ready for use.",
            "bool",
            "Whether the WebSocket is currently rate limited.",
            "This can be useful to know when deciding whether you should query members\nusing HTTP or via the gateway.\n:rtype: bool",
            "New in version 1.6.",
            "Measures latency between a HEARTBEAT and a HEARTBEAT_ACK in seconds.",
            "This could be referred to as the Discord WebSocket protocol latency.",
            "Loads an extension.",
            "An extension is a python module that contains commands, cogs, or\nlisteners.",
            "An extension must have a global function, setup defined as\nthe entry point on what to do when the extension is loaded. This entry\npoint must have a single argument, the bot.",
            "The extension passed can either be the direct name of a file within\nthe current working directory or a folder that contains multiple extensions.",
            "name (str) – The extension or folder name to load. It must be dot separated\nlike regular Python imports if accessing a submodule. e.g.\nfoo.test if you want to import foo/test.py.",
            "package (Optional[str]) – The package name to resolve relative imports with.\nThis is required when loading an extension using a relative\npath, e.g .foo.test.\nDefaults to None.\n\nNew in version 1.7.",
            "The package name to resolve relative imports with.\nThis is required when loading an extension using a relative\npath, e.g .foo.test.\nDefaults to None.",
            "New in version 1.7.",
            "recursive (Optional[bool]) – If subdirectories under the given head directory should be\nrecursively loaded.\nDefaults to False.\n\nNew in version 2.0.",
            "If subdirectories under the given head directory should be\nrecursively loaded.\nDefaults to False.",
            "New in version 2.0.",
            "store (Optional[bool]) – If exceptions should be stored or raised. If set to True,\nall exceptions encountered will be stored in a returned dictionary\nas a load status. If set to False, if any exceptions are\nencountered they will be raised and the bot will be closed.\nIf no exceptions are encountered, a list of loaded\nextension names will be returned.\nDefaults to False.\n\nNew in version 2.0.",
            "If exceptions should be stored or raised. If set to True,\nall exceptions encountered will be stored in a returned dictionary\nas a load status. If set to False, if any exceptions are\nencountered they will be raised and the bot will be closed.\nIf no exceptions are encountered, a list of loaded\nextension names will be returned.\nDefaults to False.",
            "New in version 2.0.",
            "If the store parameter is set to True, a dictionary will be returned that\ncontains keys to represent the loaded extension names. The values bound to\neach key can either be an exception that occurred when loading that extension\nor a True boolean representing a successful load. If the store parameter\nis set to False, either a list containing a list of loaded extensions or\nnothing due to an encountered exception.",
            "Optional[Union[Dict[str, Union[errors.ExtensionError, bool]], List[str]]]",
            "ExtensionNotFound – The extension could not be imported.\n    This is also raised if the name of the extension could not\n    be resolved using the provided package parameter.",
            "ExtensionAlreadyLoaded – The extension is already loaded.",
            "NoEntryPointError – The extension does not have a setup function.",
            "ExtensionFailed – The extension or its setup function had an execution error.",
            "Loads multiple extensions at once.",
            "This method simplifies the process of loading multiple\nextensions by handling the looping of load_extension.",
            "names (str) – The extension or folder names to load. It must be dot separated\nlike regular Python imports if accessing a submodule. e.g.\nfoo.test if you want to import foo/test.py.",
            "package (Optional[str]) – The package name to resolve relative imports with.\nThis is required when loading an extension using a relative\npath, e.g .foo.test.\nDefaults to None.\n\nNew in version 1.7.",
            "The package name to resolve relative imports with.\nThis is required when loading an extension using a relative\npath, e.g .foo.test.\nDefaults to None.",
            "New in version 1.7.",
            "recursive (Optional[bool]) – If subdirectories under the given head directory should be\nrecursively loaded.\nDefaults to False.\n\nNew in version 2.0.",
            "If subdirectories under the given head directory should be\nrecursively loaded.\nDefaults to False.",
            "New in version 2.0.",
            "store (Optional[bool]) – If exceptions should be stored or raised. If set to True,\nall exceptions encountered will be stored in a returned dictionary\nas a load status. If set to False, if any exceptions are\nencountered they will be raised and the bot will be closed.\nIf no exceptions are encountered, a list of loaded\nextension names will be returned.\nDefaults to False.\n\nNew in version 2.0.",
            "If exceptions should be stored or raised. If set to True,\nall exceptions encountered will be stored in a returned dictionary\nas a load status. If set to False, if any exceptions are\nencountered they will be raised and the bot will be closed.\nIf no exceptions are encountered, a list of loaded\nextension names will be returned.\nDefaults to False.",
            "New in version 2.0.",
            "If the store parameter is set to True, a dictionary will be returned that\ncontains keys to represent the loaded extension names. The values bound to\neach key can either be an exception that occurred when loading that extension\nor a True boolean representing a successful load. If the store parameter\nis set to False, either a list containing names of loaded extensions or\nnothing due to an encountered exception.",
            "Optional[Union[Dict[str, Union[errors.ExtensionError, bool]], List[str]]]",
            "ExtensionNotFound – A given extension could not be imported.\n    This is also raised if the name of the extension could not\n    be resolved using the provided package parameter.",
            "ExtensionAlreadyLoaded – A given extension is already loaded.",
            "NoEntryPointError – A given extension does not have a setup function.",
            "ExtensionFailed – A given extension or its setup function had an execution error.",
            "This function is a coroutine.",
            "Logs in the client with the specified credentials.",
            "token (str) – The authentication token. Do not prefix this token with\nanything as the library will do it for you.",
            "TypeError – The token was in invalid type.",
            "LoginFailure – The wrong credentials are passed.",
            "HTTPException – An unknown HTTP related error occurred,\n    usually when it isn’t 200 or the known incorrect credentials\n    passing status code.",
            "None",
            "This function is a coroutine.",
            "The default command error handler provided by the bot.",
            "By default, this prints to sys.stderr however it could be\noverridden to have a different implementation.",
            "This only fires if you do not specify any listeners for command error.",
            "context (ApplicationContext) –",
            "exception (DiscordException) –",
            "None",
            "This function is a coroutine.",
            "The default error handler provided by the client.",
            "By default, this prints to sys.stderr however it could be\noverridden to have a different implementation.\nCheck on_error() for more details.",
            "event_method (str) –",
            "args (Any) –",
            "kwargs (Any) –",
            "None",
            "A sequence of persistent views added to the client.",
            "New in version 2.0.",
            "The polls that the connected client has.",
            "New in version 2.6.",
            "The private channels that the connected client is participating on.",
            "Note",
            "This returns only up to 128 most recent private channels due to an internal working\non how Discord deals with private channels.",
            "This function is a coroutine.",
            "This function processes the commands that have been registered\nto the bot and other groups. Without this coroutine, none of the\ncommands will be triggered.",
            "By default, this coroutine is called inside the on_interaction()\nevent. If you choose to override the on_interaction() event, then\nyou should invoke this coroutine as well.",
            "This function finds a registered command matching the interaction id from\napplication commands and invokes it. If no matching command was\nfound, it replies to the interaction with a default message.",
            "New in version 2.0.",
            "interaction (discord.Interaction) – The interaction to process",
            "auto_sync (Optional[bool]) – Whether to automatically sync and unregister the command if it is not found in the internal cache. This will\ninvoke the sync_commands() method on the context of the command, either globally or per-guild,\nbased on the type of the command, respectively. Defaults to Bot.auto_sync_commands.",
            "None",
            "This function is a coroutine.",
            "Registers a command. If the command has guild_ids set, or if the guild_ids parameter is passed,\nthe command will be registered as a guild command for those guilds.",
            "command (ApplicationCommand) – The command to register.",
            "force (bool) – Whether to force the command to be registered. If this is set to False, the command will only be registered\nif it seems to already be registered and up to date with our internal cache. Defaults to True.",
            "guild_ids (list) – A list of guild ids to register the command for. If this is not set, the command’s\nApplicationCommand.guild_ids attribute will be used.",
            "The command that was registered",
            "ApplicationCommand",
            "This function is a coroutine.",
            "Register a list of commands.",
            "New in version 2.0.",
            "commands (Optional[List[ApplicationCommand]]) – A list of commands to register. If this is not set (None), then all commands will be registered.",
            "guild_id (Optional[int]) – If this is set, the commands will be registered as a guild command for the respective guild. If it is not\nset, the commands will be registered according to their ApplicationCommand.guild_ids attribute.",
            "method (Literal['individual', 'bulk', 'auto']) – The method to use when registering the commands. If this is set to “individual”, then each command will be\nregistered individually. If this is set to “bulk”, then all commands will be registered in bulk. If this is\nset to “auto”, then the method will be determined automatically. Defaults to “bulk”.",
            "force (bool) – Registers the commands regardless of the state of the command on Discord. This uses one less API call, but\ncan result in hitting rate limits more often. Defaults to False.",
            "delete_existing (bool) – Whether to delete existing commands that are not in the list of commands to register. Defaults to True.",
            "Atomically reloads an extension.",
            "This replaces the extension with the same extension, only refreshed. This is\nequivalent to a unload_extension() followed by a load_extension()\nexcept done in an atomic way. That is, if an operation fails mid-reload then\nthe bot will roll back to the prior working state.",
            "name (str) – The extension name to reload. It must be dot separated like\nregular Python imports if accessing a submodule. e.g.\nfoo.test if you want to import foo/test.py.",
            "package (Optional[str]) – The package name to resolve relative imports with.\nThis is required when reloading an extension using a relative path, e.g .foo.test.\nDefaults to None.\n\nNew in version 1.7.",
            "The package name to resolve relative imports with.\nThis is required when reloading an extension using a relative path, e.g .foo.test.\nDefaults to None.",
            "New in version 1.7.",
            "ExtensionNotLoaded – The extension was not loaded.",
            "ExtensionNotFound – The extension could not be imported.\n    This is also raised if the name of the extension could not\n    be resolved using the provided package parameter.",
            "NoEntryPointError – The extension does not have a setup function.",
            "ExtensionFailed – The extension setup function had an execution error.",
            "None",
            "Remove an ApplicationCommand from the internal list\nof commands.",
            "New in version 2.0.",
            "command (ApplicationCommand) – The command to remove.",
            "The command that was removed. If the command has not been added,\nNone is returned instead.",
            "Optional[ApplicationCommand]",
            "Removes a global check from the bot.\nThis function is idempotent and will not raise an exception\nif the function is not in the global checks.",
            "func – The function to remove from the global checks.",
            "call_once (bool) – If the function was added with call_once=True in\nthe Bot.add_check() call or using check_once().",
            "None",
            "Removes a cog from the bot and returns it.",
            "All registered commands and event listeners that the\ncog has registered will be removed as well.",
            "If no cog is found then this method has no effect.",
            "name (str) – The name of the cog to remove.",
            "The cog that was removed. None if not found.",
            "Optional[Cog]",
            "Removes a listener from the pool of listeners.",
            "func (TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])) – The function that was used as a listener to remove.",
            "name (str) – The name of the event we want to remove. Defaults to\nfunc.__name__.",
            "None",
            "A blocking call that abstracts away the event loop\ninitialisation from you.",
            "If you want more control over the event loop then this\nfunction should not be used. Use start() coroutine\nor connect() + login().",
            "Roughly Equivalent to:",
            "Warning",
            "This function must be the last function to call due to the fact that it\nis blocking. That means that registration of events or anything being\ncalled after this function call will not execute until it returns.",
            "args (Any) –",
            "kwargs (Any) –",
            "None",
            "A shortcut decorator that initializes the provided subclass of SlashCommandGroup\nand adds it to the internal command list via add_application_command().",
            "New in version 2.0.",
            "name (Optional[str]) – The name of the group to create. This will resolve to the name of the decorated class if None is passed.",
            "description (Optional[str]) – The description of the group to create.",
            "guild_ids (Optional[List[int]]) – A list of the IDs of each guild this group should be added to, making it a guild command.\nThis will be a global command if None is passed.",
            "The slash command group that was created.",
            "Callable[[Type[SlashCommandGroup]], SlashCommandGroup]",
            "This function is a coroutine.",
            "A shorthand coroutine for login() + connect().",
            "TypeError – An unexpected keyword argument was received.",
            "token (str) –",
            "reconnect (bool) –",
            "None",
            "The status being used upon logging on to Discord.",
            "The stickers that the connected client has.",
            "New in version 2.0.",
            "The URL that leads to the application’s store page for monetization.",
            "New in version 2.6.",
            "str",
            "This function is a coroutine.",
            "Registers all commands that have been added through add_application_command(). This method cleans up all\ncommands over the API and should sync them with the internal cache of commands. It attempts to register the\ncommands in the most efficient way possible, unless force is set to True, in which case it will always\nregister all commands.",
            "By default, this coroutine is called inside the on_connect() event. If you choose to override the\non_connect() event, then you should invoke this coroutine as well such as the following:",
            "Note",
            "If you remove all guild commands from a particular guild, the library may not be able to detect and update\nthe commands accordingly, as it would have to individually check for each guild. To force the library to\nunregister a guild’s commands, call this function with commands=[] and guild_ids=[guild_id].",
            "New in version 2.0.",
            "commands (Optional[List[ApplicationCommand]]) – A list of commands to register. If this is not set (None), then all commands will be registered.",
            "method (Literal['individual', 'bulk', 'auto']) – The method to use when registering the commands. If this is set to “individual”, then each command will be\nregistered individually. If this is set to “bulk”, then all commands will be registered in bulk. If this is\nset to “auto”, then the method will be determined automatically. Defaults to “bulk”.",
            "force (bool) – Registers the commands regardless of the state of the command on Discord. This uses one less API call, but\ncan result in hitting rate limits more often. Defaults to False.",
            "guild_ids (Optional[List[int]]) – A list of guild ids to register the commands for. If this is not set, the commands’\nguild_ids attribute will be used.",
            "register_guild_commands (bool) – Whether to register guild commands. Defaults to True.",
            "check_guilds (Optional[List[int]]) – A list of guilds ids to check for commands to unregister, since the bot would otherwise have to check all\nguilds. Unlike guild_ids, this does not alter the commands’ guild_ids\nattribute, instead it adds the guild ids to a list of guilds to sync commands for. If\nregister_guild_commands is set to False, then this parameter is ignored.",
            "delete_existing (bool) – Whether to delete existing commands that are not in the list of commands to register. Defaults to True.",
            "Unloads an extension.",
            "When the extension is unloaded, all commands, listeners, and cogs are\nremoved from the bot and the module is un-imported.",
            "The extension can provide an optional global function, teardown,\nto do miscellaneous clean-up if necessary. This function takes a single\nparameter, the bot, similar to setup from\nload_extension().",
            "name (str) – The extension name to unload. It must be dot separated like\nregular Python imports if accessing a submodule. e.g.\nfoo.test if you want to import foo/test.py.",
            "package (Optional[str]) – The package name to resolve relative imports with.\nThis is required when unloading an extension using a relative path, e.g .foo.test.\nDefaults to None.\n\nNew in version 1.7.",
            "The package name to resolve relative imports with.\nThis is required when unloading an extension using a relative path, e.g .foo.test.\nDefaults to None.",
            "New in version 1.7.",
            "ExtensionNotFound – The name of the extension could not\n    be resolved using the provided package parameter.",
            "ExtensionNotLoaded – The extension was not loaded.",
            "None",
            "This function is a coroutine.",
            "Updates the bot’s role connection metadata records.",
            "New in version 2.4.",
            "*role_connection_metadata (ApplicationRoleConnectionMetadata) – The new metadata records to send to Discord.",
            "The updated role connection metadata records.",
            "List[ApplicationRoleConnectionMetadata]",
            "Represents the connected client. None if not logged in.",
            "Returns a list of all the users the bot can see.",
            "Represents a list of voice connections.",
            "These are usually VoiceClient instances.",
            "This function is a coroutine.",
            "Waits for a WebSocket event to be dispatched.",
            "This could be used to wait for a user to reply to a message,\nor to react to a message, or to edit a message in a self-contained\nway.",
            "The timeout parameter is passed onto asyncio.wait_for(). By default,\nit does not timeout. Note that this does propagate the\nasyncio.TimeoutError for you in case of timeout and is provided for\nease of use.",
            "In case the event returns multiple arguments, a tuple containing those\narguments is returned instead. Please check the\ndocumentation for a list of events and their\nparameters.",
            "This function returns the first event that meets the requirements.",
            "event (str) – The event name, similar to the event reference,\nbut without the on_ prefix, to wait for.",
            "check (Optional[Callable[…, bool]]) – A predicate to check what to wait for. The arguments must meet the\nparameters of the event being waited for.",
            "timeout (Optional[float]) – The number of seconds to wait before timing out and raising\nasyncio.TimeoutError.",
            "Returns no arguments, a single argument, or a tuple of multiple\narguments that mirrors the parameters passed in the\nevent reference.",
            "Any",
            "asyncio.TimeoutError – Raised if a timeout is provided and reached.",
            "Examples",
            "Waiting for a user reply:",
            "Waiting for a thumbs up reaction from the message author:",
            "This function is a coroutine.",
            "Waits until the client’s internal cache is all ready.",
            "None",
            "An iterator that recursively walks through all application commands and subcommands.",
            "ApplicationCommand – An application command from the internal list of application commands.",
            "Generator[ApplicationCommand, None, None]",
            "This is similar to Bot except that it is inherited from\ndiscord.AutoShardedClient instead.",
            "New in version 2.0."
        ],
        "code": [
            "discord.Client",
            "discord.Client",
            "ApplicationCommandMixin",
            "str",
            "is_owner()",
            "application_info()",
            "int",
            "owner_id",
            "application_info()",
            "set",
            "owner_id",
            "owner_ids",
            "int",
            "int",
            "sync_commands()",
            "discord.on_connect()",
            "process_application_commands",
            "True",
            "bool",
            "InteractionContextType.guild",
            "InteractionContextType.bot_dm",
            "InteractionContextType.private_channel",
            "InteractionContextType",
            "IntegrationType.guild_install",
            "IntegrationType",
            "application_command()",
            "discord.ext.commands.Bot",
            "ApplicationCommand",
            "ApplicationCommand",
            "TypeError",
            "listen()",
            "event()",
            "@client.event\nasync def on_ready():\n    print('Ready!')",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "command()",
            "add_application_command()",
            "MessageCommand",
            "MessageCommand",
            "MessageCommand",
            "command()",
            "add_application_command()",
            "SlashCommand",
            "SlashCommand",
            "SlashCommand",
            "command()",
            "add_application_command()",
            "UserCommand",
            "UserCommand",
            "UserCommand",
            "on_ready()",
            "name",
            "@client.listen()\nasync def on_message(message):\n    print('one')\n\n# in some other file...\n\n@client.listen('on_message')\nasync def my_message(message):\n    print('two')\n\n# listen to the first event only\n@client.listen('on_ready', once=True)\nasync def on_ready():\n    print('ready!')",
            "str",
            "bool",
            "Callable",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "BaseActivity",
            "ApplicationCommand",
            "command()",
            "ApplicationCommand",
            "None",
            "check()",
            "check_once()",
            "bool",
            "Bot.invoke()",
            "None",
            "ClientException",
            "Cog",
            "bool",
            "Cog",
            "None",
            "listen()",
            "str",
            "func.__name__",
            "func",
            "name",
            "None",
            "async def on_ready(): pass\nasync def my_message(message): pass\n\nclient.add_listener(on_ready)\nclient.add_listener(my_message, 'on_message')",
            "View",
            "discord.ui.View",
            "int",
            "custom_id",
            "Context",
            "before_invoke()",
            "CommandInvokeError",
            "command()",
            "add_application_command()",
            "ApplicationCommand",
            "ApplicationCommand",
            "__init__",
            "on_connect()",
            "AppInfo",
            "int",
            "bool",
            "Context",
            "before_invoke()",
            "after_invoke()",
            "BaseActivity",
            "None",
            "Status",
            "None",
            "Status.online",
            "activity",
            "game = discord.Game(\"with the API\")\nawait client.change_presence(status=discord.Status.idle, activity=game)",
            "afk",
            "check()",
            "check()",
            "Context",
            "ApplicationCommandError",
            "@bot.check\ndef check_commands(ctx):\n    return ctx.command.qualified_name in allowed_commands",
            "Bot.invoke()",
            "Command.can_run()",
            "Context",
            "Bot.invoke()",
            "check()",
            "Context",
            "ApplicationCommandError",
            "@bot.check_once\ndef whitelist(ctx):\n    return ctx.message.author.id in my_whitelist",
            "is_closed()",
            "is_ready()",
            "False",
            "None",
            "None",
            "bool",
            "None",
            "DMChannel",
            "Snowflake",
            "DMChannel",
            "add_application_command()",
            "str",
            "str",
            "int",
            "None",
            "SlashCommandGroup",
            "Guild",
            "str",
            "bytes",
            "ClientUser.edit()",
            "str",
            "Guild",
            "Invite",
            "manage_channels",
            "Invite",
            "str",
            "AsyncIterator",
            "abc.Snowflake",
            "abc.Snowflake",
            "abc.Snowflake",
            "datetime.datetime",
            "abc.Snowflake",
            "datetime.datetime",
            "int",
            "None",
            "100",
            "abc.Snowflake",
            "bool",
            "False",
            "Entitlement",
            "async for entitlement in client.entitlements():\n    print(entitlement.user_id)",
            "entitlements = await user.entitlements().flatten()",
            "PartialAppInfo",
            "int",
            "PartialAppInfo",
            "abc.GuildChannel",
            "abc.PrivateChannel",
            "Thread",
            "get_channel()",
            "abc.GuildChannel",
            "abc.PrivateChannel",
            "Thread",
            "Guild",
            "Guild.channels",
            "Guild.members",
            "Member.activity",
            "Member.voice",
            "Member",
            "get_guild()",
            "int",
            "bool",
            "Guild.approximate_member_count",
            "Guild.approximate_presence_count",
            "Guild",
            "AsyncIterator",
            "Guild.owner",
            "Guild.icon",
            "Guild.id",
            "Guild.name",
            "Guild",
            "guilds",
            "int",
            "None",
            "100",
            "abc.Snowflake",
            "datetime.datetime",
            "abc.Snowflake",
            "datetime.datetime",
            "Guild",
            "async for guild in client.fetch_guilds(limit=150):\n    print(guild.name)",
            "guilds = await client.fetch_guilds(limit=150).flatten()\n# guilds is now a list of Guild...",
            "Invite",
            "Invite",
            "PartialInviteGuild",
            "PartialInviteChannel",
            "Invite",
            "str",
            "bool",
            "Invite.approximate_member_count",
            "Invite.approximate_presence_count",
            "bool",
            "Invite.expires_at",
            "int",
            "Invite.set_scheduled_event()",
            "Invite",
            "StickerPack",
            "ApplicationRoleConnectionMetadata",
            "SKU",
            "StageInstance",
            "int",
            "StageInstance",
            "Sticker",
            "StandardSticker",
            "GuildSticker",
            "Template",
            "Template",
            "str",
            "Template",
            "User",
            "discord.Intents.members",
            "get_user()",
            "int",
            "User",
            "Webhook",
            "Webhook",
            "int",
            "Widget",
            "int",
            "Widget",
            "abc.GuildChannel",
            "for guild in client.guilds:\n    for channel in guild.channels:\n        yield channel",
            "Generator",
            "GuildChannel",
            "None",
            "None",
            "abc.GuildChannel",
            "abc.GuildChannel.permissions_for()",
            "abc.GuildChannel",
            "Member",
            "for guild in client.guilds:\n    for member in guild.members:\n        yield member",
            "Member",
            "Generator",
            "Member",
            "None",
            "None",
            "ApplicationCommand",
            "str",
            "int",
            "ApplicationCommand",
            "ApplicationCommand",
            "None",
            "ApplicationCommand",
            "process_application_commands()",
            "discord.Interaction",
            "Any",
            "ApplicationContext",
            "ApplicationContext",
            "cls",
            "ApplicationContext",
            "process_application_commands()",
            "discord.Interaction",
            "Any",
            "AutocompleteContext",
            "AutocompleteContext",
            "cls",
            "AutocompleteContext",
            "int",
            "None",
            "abc.GuildChannel",
            "Thread",
            "abc.PrivateChannel",
            "None",
            "str",
            "None",
            "Cog",
            "get_application_command()",
            "ext.commands.Bot",
            "guild_id",
            "int",
            "ApplicationCommand",
            "cmd",
            "action",
            "id",
            "str",
            "int",
            "None",
            "Emoji",
            "int",
            "None",
            "Guild",
            "int",
            "None",
            "Message",
            "int",
            "None",
            "User",
            "int",
            "ChannelType",
            "PartialMessageable",
            "int",
            "None",
            "Poll",
            "int",
            "None",
            "StageInstance",
            "fetch_sticker()",
            "fetch_premium_sticker_packs()",
            "None",
            "GuildSticker",
            "int",
            "None",
            "User",
            "SlashCommandGroup",
            "add_application_command()",
            "str",
            "None",
            "str",
            "int",
            "None",
            "ApplicationCommand",
            "None",
            "bool",
            "User",
            "Member",
            "owner_id",
            "application_info()",
            "owner_ids",
            "abc.User",
            "bool",
            "bool",
            "bool",
            "setup",
            "bot",
            "str",
            "foo.test",
            "foo/test.py",
            "str",
            ".foo.test",
            "None",
            "bool",
            "False",
            "bool",
            "True",
            "False",
            "False",
            "True",
            "True",
            "False",
            "str",
            "errors.ExtensionError",
            "bool",
            "str",
            "package",
            "load_extension",
            "str",
            "foo.test",
            "foo/test.py",
            "str",
            ".foo.test",
            "None",
            "bool",
            "False",
            "bool",
            "True",
            "False",
            "False",
            "True",
            "True",
            "False",
            "str",
            "errors.ExtensionError",
            "bool",
            "str",
            "package",
            "str",
            "None",
            "sys.stderr",
            "ApplicationContext",
            "DiscordException",
            "None",
            "sys.stderr",
            "on_error()",
            "str",
            "Any",
            "Any",
            "None",
            "on_interaction()",
            "on_interaction()",
            "discord.Interaction",
            "bool",
            "sync_commands()",
            "Bot.auto_sync_commands",
            "guild_ids",
            "guild_ids",
            "ApplicationCommand",
            "bool",
            "list",
            "ApplicationCommand.guild_ids",
            "ApplicationCommand",
            "ApplicationCommand",
            "None",
            "ApplicationCommand.guild_ids",
            "bool",
            "bool",
            "unload_extension()",
            "load_extension()",
            "str",
            "foo.test",
            "foo/test.py",
            "str",
            ".foo.test",
            "None",
            "package",
            "ApplicationCommand",
            "ApplicationCommand",
            "None",
            "ApplicationCommand",
            "bool",
            "call_once=True",
            "Bot.add_check()",
            "check_once()",
            "None",
            "str",
            "None",
            "Cog",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "str",
            "func.__name__",
            "None",
            "start()",
            "connect()",
            "login()",
            "try:\n    loop.run_until_complete(start(*args, **kwargs))\nexcept KeyboardInterrupt:\n    loop.run_until_complete(close())\n    # cancel all tasks lingering\nfinally:\n    loop.close()",
            "Any",
            "Any",
            "None",
            "SlashCommandGroup",
            "add_application_command()",
            "str",
            "None",
            "str",
            "int",
            "None",
            "login()",
            "connect()",
            "str",
            "bool",
            "None",
            "str",
            "add_application_command()",
            "force",
            "True",
            "on_connect()",
            "on_connect()",
            "@bot.event\nasync def on_connect():\n    if bot.auto_sync_commands:\n        await bot.sync_commands()\n    print(f\"{bot.user.name} connected.\")",
            "commands=[]",
            "guild_ids=[guild_id]",
            "ApplicationCommand",
            "bool",
            "int",
            "guild_ids",
            "bool",
            "int",
            "guild_ids",
            "guild_ids",
            "register_guild_commands",
            "bool",
            "teardown",
            "bot",
            "setup",
            "load_extension()",
            "str",
            "foo.test",
            "foo/test.py",
            "str",
            ".foo.test",
            "None",
            "package",
            "ApplicationRoleConnectionMetadata",
            "ApplicationRoleConnectionMetadata",
            "None",
            "VoiceClient",
            "timeout",
            "asyncio.wait_for()",
            "asyncio.TimeoutError",
            "tuple",
            "str",
            "on_",
            "bool",
            "float",
            "asyncio.TimeoutError",
            "tuple",
            "@client.event\nasync def on_message(message):\n    if message.content.startswith('$greet'):\n        channel = message.channel\n        await channel.send('Say hello!')\n\n        def check(m):\n            return m.content == 'hello' and m.channel == channel\n\n        msg = await client.wait_for('message', check=check)\n        await channel.send(f'Hello {msg.author}!')",
            "@client.event\nasync def on_message(message):\n    if message.content.startswith('$thumb'):\n        channel = message.channel\n        await channel.send('Send me that 👍 reaction, mate')\n\n        def check(reaction, user):\n            return user == message.author and str(reaction.emoji) == '👍'\n\n        try:\n            reaction, user = await client.wait_for('reaction_add', timeout=60.0, check=check)\n        except asyncio.TimeoutError:\n            await channel.send('👎')\n        else:\n            await channel.send('👍')",
            "None",
            "ApplicationCommand",
            "Generator",
            "ApplicationCommand",
            "None",
            "None",
            "Bot",
            "discord.AutoShardedClient"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/clients.html"
    },
    {
        "title": "Clients#",
        "content": [
            "Represents a client connection that connects to Discord.\nThis class is used to interact with the Discord WebSocket and API.",
            "A number of options can be passed to the Client.",
            "max_messages (Optional[int]) – The maximum number of messages to store in the internal message cache.\nThis defaults to 1000. Passing in None disables the message cache.\n\nChanged in version 1.3: Allow disabling the message cache and change the default size to 1000.",
            "The maximum number of messages to store in the internal message cache.\nThis defaults to 1000. Passing in None disables the message cache.",
            "Changed in version 1.3: Allow disabling the message cache and change the default size to 1000.",
            "loop (Optional[asyncio.AbstractEventLoop]) – The asyncio.AbstractEventLoop to use for asynchronous operations.\nDefaults to None, in which case the default event loop is used via\nasyncio.get_event_loop().",
            "connector (Optional[aiohttp.BaseConnector]) – The connector to use for connection pooling.",
            "proxy (Optional[str]) – Proxy URL.",
            "proxy_auth (Optional[aiohttp.BasicAuth]) – An object that represents proxy HTTP Basic Authorization.",
            "shard_id (Optional[int]) – Integer starting at 0 and less than shard_count.",
            "shard_count (Optional[int]) – The total number of shards.",
            "application_id (int) – The client’s application ID.",
            "intents (Intents) – The intents that you want to enable for the session. This is a way of\ndisabling and enabling certain gateway events from triggering and being sent.\nIf not given, defaults to a regularly constructed Intents class.\n\nNew in version 1.5.",
            "The intents that you want to enable for the session. This is a way of\ndisabling and enabling certain gateway events from triggering and being sent.\nIf not given, defaults to a regularly constructed Intents class.",
            "New in version 1.5.",
            "member_cache_flags (MemberCacheFlags) – Allows for finer control over how the library caches members.\nIf not given, defaults to cache as much as possible with the\ncurrently selected intents.\n\nNew in version 1.5.",
            "Allows for finer control over how the library caches members.\nIf not given, defaults to cache as much as possible with the\ncurrently selected intents.",
            "New in version 1.5.",
            "chunk_guilds_at_startup (bool) – Indicates if on_ready() should be delayed to chunk all guilds\nat start-up if necessary. This operation is incredibly slow for large\namounts of guilds. The default is True if Intents.members\nis True.\n\nNew in version 1.5.",
            "Indicates if on_ready() should be delayed to chunk all guilds\nat start-up if necessary. This operation is incredibly slow for large\namounts of guilds. The default is True if Intents.members\nis True.",
            "New in version 1.5.",
            "status (Optional[Status]) – A status to start your presence with upon logging on to Discord.",
            "activity (Optional[BaseActivity]) – An activity to start your presence with upon logging on to Discord.",
            "allowed_mentions (Optional[AllowedMentions]) – Control how the client handles mentions by default on every message sent.\n\nNew in version 1.4.",
            "Control how the client handles mentions by default on every message sent.",
            "New in version 1.4.",
            "heartbeat_timeout (float) – The maximum numbers of seconds before timing out and restarting the\nWebSocket in the case of not receiving a HEARTBEAT_ACK. Useful if\nprocessing the initial packets take too long to the point of disconnecting\nyou. The default timeout is 60 seconds.",
            "guild_ready_timeout (float) – The maximum number of seconds to wait for the GUILD_CREATE stream to end before\npreparing the member cache and firing READY. The default timeout is 2 seconds.\n\nNew in version 1.4.",
            "The maximum number of seconds to wait for the GUILD_CREATE stream to end before\npreparing the member cache and firing READY. The default timeout is 2 seconds.",
            "New in version 1.4.",
            "assume_unsync_clock (bool) – Whether to assume the system clock is unsynced. This applies to the ratelimit handling\ncode. If this is set to True, the default, then the library uses the time to reset\na rate limit bucket given by Discord. If this is False then your system clock is\nused to calculate how long to sleep for. If this is set to False it is recommended to\nsync your system clock to Google’s NTP server.\n\nNew in version 1.3.",
            "Whether to assume the system clock is unsynced. This applies to the ratelimit handling\ncode. If this is set to True, the default, then the library uses the time to reset\na rate limit bucket given by Discord. If this is False then your system clock is\nused to calculate how long to sleep for. If this is set to False it is recommended to\nsync your system clock to Google’s NTP server.",
            "New in version 1.3.",
            "enable_debug_events (bool) – Whether to enable events that are useful only for debugging gateway related information.\nRight now this involves on_socket_raw_receive() and on_socket_raw_send(). If\nthis is False then those events will not be dispatched (due to performance considerations).\nTo enable these events, this must be set to True. Defaults to False.\n\nNew in version 2.0.",
            "Whether to enable events that are useful only for debugging gateway related information.",
            "Right now this involves on_socket_raw_receive() and on_socket_raw_send(). If\nthis is False then those events will not be dispatched (due to performance considerations).\nTo enable these events, this must be set to True. Defaults to False.",
            "New in version 2.0.",
            "The WebSocket gateway the client is currently connected to. Could be None.",
            "The event loop that the client uses for asynchronous operations.",
            "asyncio.AbstractEventLoop",
            "options (Any) –",
            "A decorator that registers an event to listen to.",
            "You can find more info about the events on the documentation below.",
            "The events must be a coroutine, if not, TypeError is raised.",
            "Note",
            "This replaces any default handlers.\nDevelopers are encouraged to use listen() for adding additional handlers\ninstead of event() unless default method replacement is intended.",
            "TypeError – The coroutine passed is not actually a coroutine.",
            "Example",
            "coro (TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])) –",
            "TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])",
            "Retrieves an AsyncIterator that enables receiving your guilds.",
            "Note",
            "Using this, you will only receive Guild.owner, Guild.icon,\nGuild.id, and Guild.name per Guild.",
            "Note",
            "This method is an API call. For general usage, consider guilds instead.",
            "limit (Optional[int]) – The number of guilds to retrieve.\nIf None, it retrieves every guild you have access to. Note, however,\nthat this would make it a slow operation.\nDefaults to 100.",
            "before (Union[abc.Snowflake, datetime.datetime]) – Retrieves guilds before this date or object.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (Union[abc.Snowflake, datetime.datetime]) – Retrieve guilds after this date or object.\nIf a datetime is provided, it is recommended to use a UTC aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "Guild – The guild with the guild data parsed.",
            "HTTPException – Getting the guilds failed.",
            "GuildIterator",
            "Examples",
            "Usage",
            "Flattening into a list",
            "All parameters are optional.",
            "A decorator that registers another function as an external\nevent listener. Basically this allows you to listen to multiple\nevents from different places e.g. such as on_ready()",
            "The functions being listened to must be a coroutine.",
            "TypeError – The function being listened to is not a coroutine.",
            "ValueError – The name (event name) does not start with ‘on_’",
            "Example",
            "Would print one and two in an unspecified order.",
            "name (str) –",
            "once (bool) –",
            "Callable[[TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])], TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])]",
            "Measures latency between a HEARTBEAT and a HEARTBEAT_ACK in seconds.",
            "This could be referred to as the Discord WebSocket protocol latency.",
            "Whether the WebSocket is currently rate limited.",
            "This can be useful to know when deciding whether you should query members\nusing HTTP or via the gateway.\n:rtype: bool",
            "New in version 1.6.",
            "Represents the connected client. None if not logged in.",
            "The guilds that the connected client is a member of.",
            "The emojis that the connected client has.",
            "The stickers that the connected client has.",
            "New in version 2.0.",
            "The polls that the connected client has.",
            "New in version 2.6.",
            "Read-only list of messages the connected client has cached.",
            "New in version 1.1.",
            "The private channels that the connected client is participating on.",
            "Note",
            "This returns only up to 128 most recent private channels due to an internal working\non how Discord deals with private channels.",
            "Represents a list of voice connections.",
            "These are usually VoiceClient instances.",
            "The client’s application ID.",
            "If this is not passed via __init__ then this is retrieved\nthrough the gateway when an event contains the data. Usually\nafter on_connect() is called.",
            "New in version 2.0.",
            "The client’s application flags.",
            "New in version 2.0.",
            "Specifies if the client’s internal cache is ready for use.",
            "bool",
            "This function is a coroutine.",
            "The default error handler provided by the client.",
            "By default, this prints to sys.stderr however it could be\noverridden to have a different implementation.\nCheck on_error() for more details.",
            "event_method (str) –",
            "args (Any) –",
            "kwargs (Any) –",
            "None",
            "This function is a coroutine.",
            "A hook that is called before IDENTIFYing a session. This is useful\nif you wish to have more control over the synchronization of multiple\nIDENTIFYing clients.",
            "The default implementation sleeps for 5 seconds.",
            "New in version 1.4.",
            "shard_id (int) – The shard ID that requested being IDENTIFY’d",
            "initial (bool) – Whether this IDENTIFY is the first initial IDENTIFY.",
            "None",
            "This function is a coroutine.",
            "Logs in the client with the specified credentials.",
            "token (str) – The authentication token. Do not prefix this token with\nanything as the library will do it for you.",
            "TypeError – The token was in invalid type.",
            "LoginFailure – The wrong credentials are passed.",
            "HTTPException – An unknown HTTP related error occurred,\n    usually when it isn’t 200 or the known incorrect credentials\n    passing status code.",
            "None",
            "This function is a coroutine.",
            "Creates a WebSocket connection and lets the WebSocket listen\nto messages from Discord. This is a loop that runs the entire\nevent system and miscellaneous aspects of the library. Control\nis not resumed until the WebSocket connection is terminated.",
            "reconnect (bool) – If we should attempt reconnecting, either due to internet\nfailure or a specific failure on Discord’s part. Certain\ndisconnects that lead to bad state will not be handled (such as\ninvalid sharding payloads or bad tokens).",
            "GatewayNotFound – The gateway to connect to Discord is not found. Usually if this\n    is thrown then there is a Discord API outage.",
            "ConnectionClosed – The WebSocket connection has been terminated.",
            "None",
            "This function is a coroutine.",
            "Closes the connection to Discord.",
            "None",
            "Clears the internal state of the bot.",
            "After this, the bot can be considered “re-opened”, i.e. is_closed()\nand is_ready() both return False along with the bot’s internal\ncache cleared.",
            "None",
            "This function is a coroutine.",
            "A shorthand coroutine for login() + connect().",
            "TypeError – An unexpected keyword argument was received.",
            "token (str) –",
            "reconnect (bool) –",
            "None",
            "A blocking call that abstracts away the event loop\ninitialisation from you.",
            "If you want more control over the event loop then this\nfunction should not be used. Use start() coroutine\nor connect() + login().",
            "Roughly Equivalent to:",
            "Warning",
            "This function must be the last function to call due to the fact that it\nis blocking. That means that registration of events or anything being\ncalled after this function call will not execute until it returns.",
            "args (Any) –",
            "kwargs (Any) –",
            "None",
            "Indicates if the WebSocket connection is closed.",
            "bool",
            "The activity being used upon logging in.",
            "Optional[BaseActivity]",
            "The status being used upon logging on to Discord.",
            "The allowed mention configuration.",
            "New in version 1.4.",
            "The intents configured for this connection.",
            "New in version 1.5.",
            "Returns a list of all the users the bot can see.",
            "This function is a coroutine.\nRetrieves a PartialAppInfo from an application ID.",
            "application_id (int) – The application ID to retrieve information from.",
            "The application information.",
            "PartialAppInfo",
            "NotFound – An application with this ID does not exist.",
            "HTTPException – Retrieving the application failed.",
            "Returns a channel or thread with the given ID.",
            "id (int) – The ID to search for.",
            "The returned channel or None if not found.",
            "Optional[Union[abc.GuildChannel, Thread, abc.PrivateChannel]]",
            "Returns a message the given ID.",
            "This is useful if you have a message_id but don’t want to do an API call\nto access the message.",
            "id (int) – The ID to search for.",
            "The returned message or None if not found.",
            "Optional[Message]",
            "Returns a partial messageable with the given channel ID.",
            "This is useful if you have a channel_id but don’t want to do an API call\nto send messages to it.",
            "New in version 2.0.",
            "id (int) – The channel ID to create a partial messageable for.",
            "type (Optional[ChannelType]) – The underlying channel type for the partial messageable.",
            "The partial messageable",
            "PartialMessageable",
            "Returns a stage instance with the given stage channel ID.",
            "New in version 2.0.",
            "id (int) – The ID to search for.",
            "The stage instance or None if not found.",
            "Optional[StageInstance]",
            "Returns a guild with the given ID.",
            "id (int) – The ID to search for.",
            "The guild or None if not found.",
            "Optional[Guild]",
            "Returns a user with the given ID.",
            "id (int) – The ID to search for.",
            "The user or None if not found.",
            "Optional[User]",
            "Returns an emoji with the given ID.",
            "id (int) – The ID to search for.",
            "The custom emoji or None if not found.",
            "Optional[Emoji]",
            "Returns a guild sticker with the given ID.",
            "New in version 2.0.",
            "Note",
            "To retrieve standard stickers, use fetch_sticker().\nor fetch_premium_sticker_packs().",
            "The sticker or None if not found.",
            "Optional[GuildSticker]",
            "id (int) –",
            "Returns a poll attached to the given message ID.",
            "id (int) – The message ID of the poll to search for.",
            "The poll or None if not found.",
            "Optional[Poll]",
            "A generator that retrieves every abc.GuildChannel the client can ‘access’.",
            "This is equivalent to:",
            "Generator[GuildChannel, None, None]",
            "Note",
            "Just because you receive a abc.GuildChannel does not mean that\nyou can communicate in said channel. abc.GuildChannel.permissions_for() should\nbe used for that.",
            "abc.GuildChannel – A channel the client can ‘access’.",
            "Returns a generator with every Member the client can see.",
            "This is equivalent to:",
            "Member – A member the client can see.",
            "Generator[Member, None, None]",
            "This function is a coroutine.",
            "Looks up a user in the user cache or fetches if not found.",
            "id (int) – The ID to search for.",
            "The user or None if not found.",
            "Optional[User]",
            "This function is a coroutine.",
            "Waits until the client’s internal cache is all ready.",
            "None",
            "This function is a coroutine.",
            "Waits for a WebSocket event to be dispatched.",
            "This could be used to wait for a user to reply to a message,\nor to react to a message, or to edit a message in a self-contained\nway.",
            "The timeout parameter is passed onto asyncio.wait_for(). By default,\nit does not timeout. Note that this does propagate the\nasyncio.TimeoutError for you in case of timeout and is provided for\nease of use.",
            "In case the event returns multiple arguments, a tuple containing those\narguments is returned instead. Please check the\ndocumentation for a list of events and their\nparameters.",
            "This function returns the first event that meets the requirements.",
            "event (str) – The event name, similar to the event reference,\nbut without the on_ prefix, to wait for.",
            "check (Optional[Callable[…, bool]]) – A predicate to check what to wait for. The arguments must meet the\nparameters of the event being waited for.",
            "timeout (Optional[float]) – The number of seconds to wait before timing out and raising\nasyncio.TimeoutError.",
            "Returns no arguments, a single argument, or a tuple of multiple\narguments that mirrors the parameters passed in the\nevent reference.",
            "Any",
            "asyncio.TimeoutError – Raised if a timeout is provided and reached.",
            "Examples",
            "Waiting for a user reply:",
            "Waiting for a thumbs up reaction from the message author:",
            "The non decorator alternative to listen().",
            "func (coroutine) – The function to call.",
            "name (str) – The name of the event to listen for. Defaults to func.__name__.",
            "TypeError – The func parameter is not a coroutine function.",
            "ValueError – The name (event name) does not start with ‘on_’",
            "None",
            "Example",
            "Removes a listener from the pool of listeners.",
            "func (TypeVar(Coro, bound= Callable[..., Coroutine[Any, Any, Any]])) – The function that was used as a listener to remove.",
            "name (str) – The name of the event we want to remove. Defaults to\nfunc.__name__.",
            "None",
            "This function is a coroutine.",
            "Changes the client’s presence.",
            "activity (Optional[BaseActivity]) – The activity being done. None if no currently active activity is done.",
            "status (Optional[Status]) – Indicates what status to change to. If None, then\nStatus.online is used.",
            "InvalidArgument – If the activity parameter is not the proper type.",
            "Example",
            "Changed in version 2.0: Removed the afk keyword-only parameter.",
            "This function is a coroutine.",
            "Gets a Template from a discord.new URL or code.",
            "code (Union[Template, str]) – The Discord Template Code or URL (must be a discord.new URL).",
            "The template from the URL/code.",
            "Template",
            "NotFound – The template is invalid.",
            "HTTPException – Getting the template failed.",
            "This function is a coroutine.",
            "Retrieves a Guild from an ID.",
            "Note",
            "Using this, you will not receive Guild.channels, Guild.members,\nMember.activity and Member.voice per Member.",
            "Note",
            "This method is an API call. For general usage, consider get_guild() instead.",
            "guild_id (int) – The guild’s ID to fetch from.",
            "with_counts (bool) – Whether to include count information in the guild. This fills the\nGuild.approximate_member_count and Guild.approximate_presence_count\nfields.\n\nNew in version 2.0.",
            "Whether to include count information in the guild. This fills the\nGuild.approximate_member_count and Guild.approximate_presence_count\nfields.",
            "New in version 2.0.",
            "The guild from the ID.",
            "Guild",
            "Forbidden – You do not have access to the guild.",
            "HTTPException – Getting the guild failed.",
            "This function is a coroutine.",
            "Creates a Guild.",
            "Bot accounts in more than 10 guilds are not allowed to create guilds.",
            "name (str) – The name of the guild.",
            "icon (Optional[bytes]) – The bytes-like object representing the icon. See ClientUser.edit()\nfor more details on what is expected.",
            "code (str) – The code for a template to create the guild with.\n\nNew in version 1.4.",
            "The code for a template to create the guild with.",
            "New in version 1.4.",
            "The guild created. This is not the same guild that is\nadded to cache.",
            "Guild",
            "HTTPException – Guild creation failed.",
            "InvalidArgument – Invalid icon image format given. Must be PNG or JPG.",
            "This function is a coroutine.",
            "Gets a StageInstance for a stage channel id.",
            "New in version 2.0.",
            "channel_id (int) – The stage channel ID.",
            "The stage instance from the stage channel ID.",
            "StageInstance",
            "NotFound – The stage instance or channel could not be found.",
            "HTTPException – Getting the stage instance failed.",
            "This function is a coroutine.",
            "Gets an Invite from a discord.gg URL or ID.",
            "Note",
            "If the invite is for a guild you have not joined, the guild and channel\nattributes of the returned Invite will be PartialInviteGuild and\nPartialInviteChannel respectively.",
            "url (Union[Invite, str]) – The Discord invite ID or URL (must be a discord.gg URL).",
            "with_counts (bool) – Whether to include count information in the invite. This fills the\nInvite.approximate_member_count and Invite.approximate_presence_count\nfields.",
            "with_expiration (bool) – Whether to include the expiration date of the invite. This fills the\nInvite.expires_at field.\n\nNew in version 2.0.",
            "Whether to include the expiration date of the invite. This fills the\nInvite.expires_at field.",
            "New in version 2.0.",
            "event_id (Optional[int]) – The ID of the scheduled event to be associated with the event.\nSee Invite.set_scheduled_event() for more\ninfo on event invite linking.\n\nNew in version 2.0.",
            "The ID of the scheduled event to be associated with the event.",
            "See Invite.set_scheduled_event() for more\ninfo on event invite linking.",
            "New in version 2.0.",
            "The invite from the URL/ID.",
            "Invite",
            "NotFound – The invite has expired or is invalid.",
            "HTTPException – Getting the invite failed.",
            "This function is a coroutine.",
            "Revokes an Invite, URL, or ID to an invite.",
            "You must have the manage_channels permission in\nthe associated guild to do this.",
            "invite (Union[Invite, str]) – The invite to revoke.",
            "Forbidden – You do not have permissions to revoke invites.",
            "NotFound – The invite is invalid or expired.",
            "HTTPException – Revoking the invite failed.",
            "None",
            "This function is a coroutine.",
            "Gets a Widget from a guild ID.",
            "Note",
            "The guild must have the widget enabled to get this information.",
            "guild_id (int) – The ID of the guild.",
            "The guild’s widget.",
            "Widget",
            "Forbidden – The widget for this guild is disabled.",
            "HTTPException – Retrieving the widget failed.",
            "This function is a coroutine.",
            "Retrieves the bot’s application information.",
            "The bot’s application information.",
            "AppInfo",
            "HTTPException – Retrieving the information failed somehow.",
            "This function is a coroutine.",
            "Retrieves a User based on their ID.\nYou do not have to share any guilds with the user to get this information,\nhowever many operations do require that you do.",
            "Note",
            "This method is an API call. If you have discord.Intents.members and member cache enabled,\nconsider get_user() instead.",
            "user_id (int) – The user’s ID to fetch from.",
            "The user you requested.",
            "User",
            "NotFound – A user with this ID does not exist.",
            "HTTPException – Fetching the user failed.",
            "This function is a coroutine.",
            "Retrieves a abc.GuildChannel, abc.PrivateChannel, or Thread with the specified ID.",
            "Note",
            "This method is an API call. For general usage, consider get_channel() instead.",
            "New in version 1.2.",
            "The channel from the ID.",
            "Union[abc.GuildChannel, abc.PrivateChannel, Thread]",
            "InvalidData – An unknown channel type was received from Discord.",
            "HTTPException – Retrieving the channel failed.",
            "NotFound – Invalid Channel ID.",
            "Forbidden – You do not have permission to fetch this channel.",
            "channel_id (int) –",
            "This function is a coroutine.",
            "Retrieves a Webhook with the specified ID.",
            "The webhook you requested.",
            "Webhook",
            "HTTPException – Retrieving the webhook failed.",
            "NotFound – Invalid webhook ID.",
            "Forbidden – You do not have permission to fetch this webhook.",
            "webhook_id (int) –",
            "This function is a coroutine.",
            "Retrieves a Sticker with the specified ID.",
            "New in version 2.0.",
            "The sticker you requested.",
            "Union[StandardSticker, GuildSticker]",
            "HTTPException – Retrieving the sticker failed.",
            "NotFound – Invalid sticker ID.",
            "sticker_id (int) –",
            "This function is a coroutine.",
            "Retrieves all available premium sticker packs.",
            "New in version 2.0.",
            "All available premium sticker packs.",
            "List[StickerPack]",
            "HTTPException – Retrieving the sticker packs failed.",
            "This function is a coroutine.",
            "Creates a DMChannel with this user.",
            "This should be rarely called, as this is done transparently for most\npeople.",
            "New in version 2.0.",
            "user (Snowflake) – The user to create a DM with.",
            "The channel that was created.",
            "DMChannel",
            "Registers a View for persistent listening.",
            "This method should be used for when a view is comprised of components\nthat last longer than the lifecycle of the program.",
            "New in version 2.0.",
            "view (discord.ui.View) – The view to register for dispatching.",
            "message_id (Optional[int]) – The message ID that the view is attached to. This is currently used to\nrefresh the view’s state during message update events. If not given\nthen message update events are not propagated for the view.",
            "TypeError – A view was not passed.",
            "ValueError – The view is not persistent. A persistent view has no timeout\n    and all their components have an explicitly provided custom_id.",
            "None",
            "A sequence of persistent views added to the client.",
            "New in version 2.0.",
            "This function is a coroutine.",
            "Fetches the bot’s role connection metadata records.",
            "New in version 2.4.",
            "The bot’s role connection metadata records.",
            "List[ApplicationRoleConnectionMetadata]",
            "This function is a coroutine.",
            "Updates the bot’s role connection metadata records.",
            "New in version 2.4.",
            "*role_connection_metadata (ApplicationRoleConnectionMetadata) – The new metadata records to send to Discord.",
            "The updated role connection metadata records.",
            "List[ApplicationRoleConnectionMetadata]",
            "This function is a coroutine.",
            "Fetches the bot’s SKUs.",
            "New in version 2.5.",
            "The bot’s SKUs.",
            "List[SKU]",
            "Returns an AsyncIterator that enables fetching the application’s entitlements.",
            "New in version 2.6.",
            "user (abc.Snowflake | None) – Limit the fetched entitlements to entitlements owned by this user.",
            "skus (list[abc.Snowflake] | None) – Limit the fetched entitlements to entitlements that are for these SKUs.",
            "before (abc.Snowflake | datetime.datetime | None) – Retrieves guilds before this date or object.\nIf a datetime is provided, it is recommended to use a UTC-aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "after (abc.Snowflake | datetime.datetime | None) – Retrieve guilds after this date or object.\nIf a datetime is provided, it is recommended to use a UTC-aware datetime.\nIf the datetime is naive, it is assumed to be local time.",
            "limit (Optional[int]) – The number of entitlements to retrieve.\nIf None, retrieves every entitlement, which may be slow.\nDefaults to 100.",
            "guild (abc.Snowflake | None) – Limit the fetched entitlements to entitlements owned by this guild.",
            "exclude_ended (bool) – Whether to limit the fetched entitlements to those that have not ended.\nDefaults to False.",
            "Entitlement – The application’s entitlements.",
            "HTTPException – Retrieving the entitlements failed.",
            "EntitlementIterator",
            "Examples",
            "Usage",
            "Flattening into a list",
            "All parameters are optional.",
            "The URL that leads to the application’s store page for monetization.",
            "New in version 2.6.",
            "str",
            "A client similar to Client except it handles the complications\nof sharding for the user into a more manageable and transparent single\nprocess bot.",
            "When using this client, you will be able to use it as-if it was a regular\nClient with a single shard when implementation wise internally it\nis split up into multiple shards. This allows you to not have to deal with\nIPC or other complicated infrastructure.",
            "It is recommended to use this client only if you have surpassed at least\n1000 guilds.",
            "If no shard_count is provided, then the library will use the\nBot Gateway endpoint call to figure out how many shards to use.",
            "If a shard_ids parameter is given, then those shard IDs will be used\nto launch the internal shards. Note that shard_count must be provided\nif this is used. By default, when omitted, the client will launch shards from\n0 to shard_count - 1.",
            "An optional list of shard_ids to launch the shards with.",
            "Optional[List[int]]",
            "args (Any) –",
            "loop (asyncio.AbstractEventLoop | None) –",
            "kwargs (Any) –",
            "Measures latency between a HEARTBEAT and a HEARTBEAT_ACK in seconds.",
            "This operates similarly to Client.latency() except it uses the average\nlatency of every shard’s latency. To get a list of shard latency, check the\nlatencies property. Returns nan if there are no shards ready.",
            "A list of latencies between a\nHEARTBEAT and a HEARTBEAT_ACK in seconds.",
            "This returns a list of tuples with elements (shard_id, latency).",
            "Gets the shard information at a given shard ID or None if not found.",
            "shard_id (int) –",
            "ShardInfo | None",
            "Returns a mapping of shard IDs to their respective info object.",
            "This function is a coroutine.",
            "Creates a WebSocket connection and lets the WebSocket listen\nto messages from Discord. This is a loop that runs the entire\nevent system and miscellaneous aspects of the library. Control\nis not resumed until the WebSocket connection is terminated.",
            "reconnect (bool) – If we should attempt reconnecting, either due to internet\nfailure or a specific failure on Discord’s part. Certain\ndisconnects that lead to bad state will not be handled (such as\ninvalid sharding payloads or bad tokens).",
            "GatewayNotFound – The gateway to connect to Discord is not found. Usually if this\n    is thrown then there is a Discord API outage.",
            "ConnectionClosed – The WebSocket connection has been terminated.",
            "None",
            "This function is a coroutine.",
            "Closes the connection to Discord.",
            "None",
            "This function is a coroutine.",
            "Changes the client’s presence.",
            "Example:",
            "Changed in version 2.0: Removed the afk keyword-only parameter.",
            "activity (Optional[BaseActivity]) – The activity being done. None if no currently active activity is done.",
            "status (Optional[Status]) – Indicates what status to change to. If None, then\nStatus.online is used.",
            "shard_id (Optional[int]) – The shard_id to change the presence to. If not specified\nor None, then it will change the presence of every\nshard the bot can see.",
            "InvalidArgument – If the activity parameter is not of proper type.",
            "None",
            "Whether the websocket is currently rate limited.",
            "This can be useful to know when deciding whether you should query members\nusing HTTP or via the gateway.",
            "This implementation checks if any of the shards are rate limited.\nFor more granular control, consider ShardInfo.is_ws_ratelimited().\n:rtype: bool",
            "New in version 1.6."
        ],
        "code": [
            "Client",
            "int",
            "1000",
            "None",
            "1000",
            "asyncio.AbstractEventLoop",
            "asyncio.AbstractEventLoop",
            "None",
            "asyncio.get_event_loop()",
            "aiohttp.BaseConnector",
            "str",
            "aiohttp.BasicAuth",
            "int",
            "0",
            "shard_count",
            "int",
            "int",
            "Intents",
            "Intents",
            "MemberCacheFlags",
            "bool",
            "on_ready()",
            "True",
            "Intents.members",
            "True",
            "Status",
            "BaseActivity",
            "AllowedMentions",
            "float",
            "float",
            "bool",
            "True",
            "False",
            "False",
            "bool",
            "on_socket_raw_receive()",
            "on_socket_raw_send()",
            "False",
            "True",
            "False",
            "None",
            "asyncio.AbstractEventLoop",
            "TypeError",
            "listen()",
            "event()",
            "@client.event\nasync def on_ready():\n    print('Ready!')",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "AsyncIterator",
            "Guild.owner",
            "Guild.icon",
            "Guild.id",
            "Guild.name",
            "Guild",
            "guilds",
            "int",
            "None",
            "100",
            "abc.Snowflake",
            "datetime.datetime",
            "abc.Snowflake",
            "datetime.datetime",
            "Guild",
            "async for guild in client.fetch_guilds(limit=150):\n    print(guild.name)",
            "guilds = await client.fetch_guilds(limit=150).flatten()\n# guilds is now a list of Guild...",
            "on_ready()",
            "name",
            "@client.listen()\nasync def on_message(message):\n    print('one')\n\n# in some other file...\n\n@client.listen('on_message')\nasync def my_message(message):\n    print('two')\n\n# listen to the first event only\n@client.listen('on_ready', once=True)\nasync def on_ready():\n    print('ready!')",
            "str",
            "bool",
            "Callable",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "bool",
            "None",
            "VoiceClient",
            "__init__",
            "on_connect()",
            "bool",
            "sys.stderr",
            "on_error()",
            "str",
            "Any",
            "Any",
            "None",
            "int",
            "bool",
            "str",
            "None",
            "bool",
            "None",
            "None",
            "is_closed()",
            "is_ready()",
            "False",
            "None",
            "login()",
            "connect()",
            "str",
            "bool",
            "None",
            "start()",
            "connect()",
            "login()",
            "try:\n    loop.run_until_complete(start(*args, **kwargs))\nexcept KeyboardInterrupt:\n    loop.run_until_complete(close())\n    # cancel all tasks lingering\nfinally:\n    loop.close()",
            "Any",
            "Any",
            "None",
            "bool",
            "BaseActivity",
            "PartialAppInfo",
            "int",
            "PartialAppInfo",
            "int",
            "None",
            "abc.GuildChannel",
            "Thread",
            "abc.PrivateChannel",
            "int",
            "None",
            "Message",
            "int",
            "ChannelType",
            "PartialMessageable",
            "int",
            "None",
            "StageInstance",
            "int",
            "None",
            "Guild",
            "int",
            "None",
            "User",
            "int",
            "None",
            "Emoji",
            "fetch_sticker()",
            "fetch_premium_sticker_packs()",
            "None",
            "GuildSticker",
            "int",
            "None",
            "Poll",
            "abc.GuildChannel",
            "for guild in client.guilds:\n    for channel in guild.channels:\n        yield channel",
            "Generator",
            "GuildChannel",
            "None",
            "None",
            "abc.GuildChannel",
            "abc.GuildChannel.permissions_for()",
            "abc.GuildChannel",
            "Member",
            "for guild in client.guilds:\n    for member in guild.members:\n        yield member",
            "Member",
            "Generator",
            "Member",
            "None",
            "None",
            "int",
            "None",
            "User",
            "None",
            "timeout",
            "asyncio.wait_for()",
            "asyncio.TimeoutError",
            "tuple",
            "str",
            "on_",
            "bool",
            "float",
            "asyncio.TimeoutError",
            "tuple",
            "@client.event\nasync def on_message(message):\n    if message.content.startswith('$greet'):\n        channel = message.channel\n        await channel.send('Say hello!')\n\n        def check(m):\n            return m.content == 'hello' and m.channel == channel\n\n        msg = await client.wait_for('message', check=check)\n        await channel.send(f'Hello {msg.author}!')",
            "@client.event\nasync def on_message(message):\n    if message.content.startswith('$thumb'):\n        channel = message.channel\n        await channel.send('Send me that 👍 reaction, mate')\n\n        def check(reaction, user):\n            return user == message.author and str(reaction.emoji) == '👍'\n\n        try:\n            reaction, user = await client.wait_for('reaction_add', timeout=60.0, check=check)\n        except asyncio.TimeoutError:\n            await channel.send('👎')\n        else:\n            await channel.send('👍')",
            "listen()",
            "str",
            "func.__name__",
            "func",
            "name",
            "None",
            "async def on_ready(): pass\nasync def my_message(message): pass\n\nclient.add_listener(on_ready)\nclient.add_listener(my_message, 'on_message')",
            "TypeVar",
            "Coro",
            "Callable",
            "...",
            "Coroutine",
            "Any",
            "Any",
            "Any",
            "str",
            "func.__name__",
            "None",
            "BaseActivity",
            "None",
            "Status",
            "None",
            "Status.online",
            "activity",
            "game = discord.Game(\"with the API\")\nawait client.change_presence(status=discord.Status.idle, activity=game)",
            "afk",
            "Template",
            "Template",
            "str",
            "Template",
            "Guild",
            "Guild.channels",
            "Guild.members",
            "Member.activity",
            "Member.voice",
            "Member",
            "get_guild()",
            "int",
            "bool",
            "Guild.approximate_member_count",
            "Guild.approximate_presence_count",
            "Guild",
            "Guild",
            "str",
            "bytes",
            "ClientUser.edit()",
            "str",
            "Guild",
            "StageInstance",
            "int",
            "StageInstance",
            "Invite",
            "Invite",
            "PartialInviteGuild",
            "PartialInviteChannel",
            "Invite",
            "str",
            "bool",
            "Invite.approximate_member_count",
            "Invite.approximate_presence_count",
            "bool",
            "Invite.expires_at",
            "int",
            "Invite.set_scheduled_event()",
            "Invite",
            "Invite",
            "manage_channels",
            "Invite",
            "str",
            "Widget",
            "int",
            "Widget",
            "AppInfo",
            "User",
            "discord.Intents.members",
            "get_user()",
            "int",
            "User",
            "abc.GuildChannel",
            "abc.PrivateChannel",
            "Thread",
            "get_channel()",
            "abc.GuildChannel",
            "abc.PrivateChannel",
            "Thread",
            "Webhook",
            "Webhook",
            "int",
            "Sticker",
            "StandardSticker",
            "GuildSticker",
            "StickerPack",
            "DMChannel",
            "Snowflake",
            "DMChannel",
            "View",
            "discord.ui.View",
            "int",
            "custom_id",
            "ApplicationRoleConnectionMetadata",
            "ApplicationRoleConnectionMetadata",
            "ApplicationRoleConnectionMetadata",
            "SKU",
            "AsyncIterator",
            "abc.Snowflake",
            "abc.Snowflake",
            "abc.Snowflake",
            "datetime.datetime",
            "abc.Snowflake",
            "datetime.datetime",
            "int",
            "None",
            "100",
            "abc.Snowflake",
            "bool",
            "False",
            "Entitlement",
            "async for entitlement in client.entitlements():\n    print(entitlement.user_id)",
            "entitlements = await user.entitlements().flatten()",
            "str",
            "Client",
            "Client",
            "shard_count",
            "shard_ids",
            "shard_count",
            "shard_count - 1",
            "int",
            "Client.latency()",
            "latencies",
            "nan",
            "(shard_id, latency)",
            "None",
            "bool",
            "None",
            "None",
            "game = discord.Game(\"with the API\")\nawait client.change_presence(status=discord.Status.idle, activity=game)",
            "afk",
            "BaseActivity",
            "None",
            "Status",
            "None",
            "Status.online",
            "int",
            "None",
            "activity",
            "ShardInfo.is_ws_ratelimited()",
            "bool",
            "Bot",
            "description",
            "owner_id",
            "owner_ids",
            "debug_guilds",
            "auto_sync_commands",
            "default_command_contexts",
            "default_command_integration_types",
            "command()",
            "event()",
            "message_command()",
            "slash_command()",
            "user_command()",
            "listen()",
            "activity",
            "add_application_command()",
            "add_check()",
            "add_cog()",
            "add_listener()",
            "add_view()",
            "after_invoke()",
            "allowed_mentions",
            "application_command()",
            "application_flags",
            "application_id",
            "application_info()",
            "before_identify_hook()",
            "before_invoke()",
            "cached_messages",
            "change_presence()",
            "check()",
            "check_once()",
            "clear()",
            "close()",
            "cogs",
            "connect()",
            "create_dm()",
            "create_group()",
            "create_guild()",
            "delete_invite()",
            "emojis",
            "entitlements()",
            "extensions",
            "fetch_application()",
            "fetch_channel()",
            "fetch_guild()",
            "fetch_guilds()",
            "fetch_invite()",
            "fetch_premium_sticker_packs()",
            "fetch_role_connection_metadata_records()",
            "fetch_skus()",
            "fetch_stage_instance()",
            "fetch_sticker()",
            "fetch_template()",
            "fetch_user()",
            "fetch_webhook()",
            "fetch_widget()",
            "get_all_channels()",
            "get_all_members()",
            "get_application_command()",
            "get_application_context()",
            "get_autocomplete_context()",
            "get_channel()",
            "get_cog()",
            "get_command",
            "get_desynced_commands()",
            "get_emoji()",
            "get_guild()",
            "get_message()",
            "get_or_fetch_user()",
            "get_partial_messageable()",
            "get_poll()",
            "get_stage_instance()",
            "get_sticker()",
            "get_user()",
            "group()",
            "guilds",
            "intents",
            "invoke_application_command()",
            "is_closed()",
            "is_owner()",
            "is_ready()",
            "is_ws_ratelimited()",
            "latency",
            "load_extension()",
            "load_extensions()",
            "login()",
            "on_application_command_error()",
            "on_error()",
            "persistent_views",
            "polls",
            "private_channels",
            "process_application_commands()",
            "register_command()",
            "register_commands()",
            "reload_extension()",
            "remove_application_command()",
            "remove_check()",
            "remove_cog()",
            "remove_listener()",
            "run()",
            "slash_group()",
            "start()",
            "status",
            "stickers",
            "store_url",
            "sync_commands()",
            "unload_extension()",
            "update_role_connection_metadata_records()",
            "user",
            "users",
            "voice_clients",
            "wait_for()",
            "wait_until_ready()",
            "walk_application_commands()",
            "AutoShardedBot",
            "Client",
            "ws",
            "loop",
            "event()",
            "fetch_guilds()",
            "listen()",
            "latency",
            "is_ws_ratelimited()",
            "user",
            "guilds",
            "emojis",
            "stickers",
            "polls",
            "cached_messages",
            "private_channels",
            "voice_clients",
            "application_id",
            "application_flags",
            "is_ready()",
            "on_error()",
            "before_identify_hook()",
            "login()",
            "connect()",
            "close()",
            "clear()",
            "start()",
            "run()",
            "is_closed()",
            "activity",
            "status",
            "allowed_mentions",
            "intents",
            "users",
            "fetch_application()",
            "get_channel()",
            "get_message()",
            "get_partial_messageable()",
            "get_stage_instance()",
            "get_guild()",
            "get_user()",
            "get_emoji()",
            "get_sticker()",
            "get_poll()",
            "get_all_channels()",
            "get_all_members()",
            "get_or_fetch_user()",
            "wait_until_ready()",
            "wait_for()",
            "add_listener()",
            "remove_listener()",
            "change_presence()",
            "fetch_template()",
            "fetch_guild()",
            "create_guild()",
            "fetch_stage_instance()",
            "fetch_invite()",
            "delete_invite()",
            "fetch_widget()",
            "application_info()",
            "fetch_user()",
            "fetch_channel()",
            "fetch_webhook()",
            "fetch_sticker()",
            "fetch_premium_sticker_packs()",
            "create_dm()",
            "add_view()",
            "persistent_views",
            "fetch_role_connection_metadata_records()",
            "update_role_connection_metadata_records()",
            "fetch_skus()",
            "entitlements()",
            "store_url",
            "AutoShardedClient",
            "shard_ids",
            "latency",
            "latencies",
            "get_shard()",
            "shards",
            "connect()",
            "close()",
            "change_presence()",
            "is_ws_ratelimited()"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/clients.html"
    },
    {
        "title": "Async Iterator#",
        "content": [
            "Some API functions return an “async iterator”. An async iterator is something that is\ncapable of being used in an async for statement.",
            "These async iterators can be used as follows:",
            "Certain utilities make working with async iterators easier, detailed below.",
            "Represents the “AsyncIterator” concept. Note that no such class exists,\nit is purely abstract.",
            "Iterates over the contents of the async iterator.",
            "This function is a coroutine.",
            "Advances the iterator by one, if possible. If no more items are found\nthen this raises NoMoreItems.",
            "This function is a coroutine.",
            "Similar to utils.get() except run over the async iterator.",
            "Getting the last message by a user named ‘Dave’ or None:",
            "This function is a coroutine.",
            "Similar to utils.find() except run over the async iterator.",
            "Unlike utils.find(), the predicate provided can be a\ncoroutine.",
            "Getting the last audit log with a reason or None:",
            "predicate – The predicate to use. Could be a coroutine.",
            "The first element that returns True for the predicate or None.",
            "This function is a coroutine.",
            "Flattens the async iterator into a list with all the elements.",
            "A list of every element in the async iterator.",
            "list",
            "Collects items into chunks of up to a given maximum size.\nAnother AsyncIterator is returned which collects items into\nlists of a given size. The maximum chunk size must be a positive integer.",
            "New in version 1.6.",
            "Collecting groups of users:",
            "Warning",
            "The last chunk collected may not be as large as max_size.",
            "max_size – The size of individual chunks.",
            "AsyncIterator",
            "This is similar to the built-in map function. Another\nAsyncIterator is returned that executes the function on\nevery element it is iterating over. This function can either be a\nregular function or a coroutine.",
            "Creating a content iterator:",
            "func – The function to call on every element. Could be a coroutine.",
            "AsyncIterator",
            "This is similar to the built-in filter function. Another\nAsyncIterator is returned that filters over the original\nasync iterator. This predicate can be a regular function or a coroutine.",
            "Getting messages by non-bot accounts:",
            "predicate – The predicate to call on every element. Could be a coroutine.",
            "AsyncIterator"
        ],
        "code": [
            "async for elem in channel.history():\n    # do stuff with elem here",
            "NoMoreItems",
            "utils.get()",
            "None",
            "msg = await channel.history().get(author__name='Dave')",
            "utils.find()",
            "utils.find()",
            "None",
            "def predicate(event):\n    return event.reason is not None\n\nevent = await guild.audit_logs().find(predicate)",
            "True",
            "None",
            "list",
            "AsyncIterator",
            "list",
            "async for leader, *users in reaction.users().chunk(3):\n    ...",
            "max_size",
            "AsyncIterator",
            "map",
            "AsyncIterator",
            "def transform(message):\n    return message.content\n\nasync for content in channel.history().map(transform):\n    message_length = len(content)",
            "AsyncIterator",
            "filter",
            "AsyncIterator",
            "def predicate(message):\n    return not message.author.bot\n\nasync for elem in channel.history().filter(predicate):\n    ...",
            "AsyncIterator",
            "AsyncIterator",
            "next()",
            "get()",
            "find()",
            "flatten()",
            "chunk()",
            "map()",
            "filter()"
        ],
        "url": "https://docs.pycord.dev/en/stable/api/async_iter.html"
    }
]